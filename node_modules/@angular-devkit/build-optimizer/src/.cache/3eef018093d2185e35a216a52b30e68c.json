{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/InstantSearch.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/InstantSearch.js","mtime":1581861144647},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START algoliasearch_src_browser_builds_algoliasearchLite.js,algoliasearch_helper,lodash_forEach,lodash_mergeWith,lodash_union,lodash_isPlainObject,events,_url_sync.js,_RoutingManager.js,_stateMappings_simple.js,_routers_history.js,_version.js,_createHelpers.js,_utils PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nvar _createClass = /*@__PURE__*/ function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n        descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n} } return function (Constructor, protoProps, staticProps) { if (protoProps)\n    defineProperties(Constructor.prototype, protoProps); if (staticProps)\n    defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n} }\nfunction _possibleConstructorReturn(self, call) { if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n} return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n} subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)\n    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n// we use the full path to the lite build to solve a meteor.js issue:\n// https://github.com/algolia/instantsearch.js/issues/1024#issuecomment-221618284\nimport algoliasearch from 'algoliasearch/src/browser/builds/algoliasearchLite.js';\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport forEach from 'lodash/forEach';\nimport mergeWith from 'lodash/mergeWith';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport EventEmitter from 'events';\nimport urlSyncWidget from './url-sync.js';\nimport RoutingManager from './RoutingManager.js';\nimport simpleMapping from './stateMappings/simple.js';\nimport historyRouter from './routers/history.js';\nimport version from './version.js';\nimport createHelpers from './createHelpers.js';\nimport { warn } from './utils';\nvar ROUTING_DEFAULT_OPTIONS = {\n    stateMapping: /*@__PURE__*/ simpleMapping(),\n    router: /*@__PURE__*/ historyRouter()\n};\nfunction defaultCreateURL() {\n    return '#';\n}\nvar defaultCreateAlgoliaClient = function defaultCreateAlgoliaClient(defaultAlgoliasearch, appId, apiKey) {\n    return defaultAlgoliasearch(appId, apiKey);\n};\nvar checkOptions = function checkOptions(_ref) {\n    var appId = _ref.appId, apiKey = _ref.apiKey, indexName = _ref.indexName, createAlgoliaClient = _ref.createAlgoliaClient, searchClient = _ref.searchClient;\n    if (!searchClient) {\n        if (appId === null || apiKey === null || indexName === null) {\n            var usage = '\\nUsage: instantsearch({\\n  appId: \\'my_application_id\\',\\n  apiKey: \\'my_search_api_key\\',\\n  indexName: \\'my_index_name\\'\\n});';\n            throw new Error(usage);\n        }\n    }\n    else if (searchClient && (indexName === null || appId !== null || apiKey !== null || createAlgoliaClient !== defaultCreateAlgoliaClient)) {\n        var _usage = '\\nUsage: instantsearch({\\n  indexName: \\'my_index_name\\',\\n  searchClient: algoliasearch(\\'appId\\', \\'apiKey\\')\\n});';\n        throw new Error(_usage);\n    }\n};\n/**\n * Widgets are the building blocks of InstantSearch.js. Any\n * valid widget must have at least a `render` or a `init` function.\n * @typedef {Object} Widget\n * @property {function} [render] Called after each search response has been received\n * @property {function} [getConfiguration] Let the widget update the configuration\n * of the search with new parameters\n * @property {function} [init] Called once before the first search\n */\n/**\n * The actual implementation of the InstantSearch. This is\n * created using the `instantsearch` factory function.\n * @fires Instantsearch#render This event is triggered each time a render is done\n */\nvar InstantSearch = /*@__PURE__*/ function (_EventEmitter) {\n    _inherits(InstantSearch, _EventEmitter);\n    function InstantSearch(options) {\n        _classCallCheck(this, InstantSearch);\n        var _this = _possibleConstructorReturn(this, (InstantSearch.__proto__ || Object.getPrototypeOf(InstantSearch)).call(this));\n        var _options$appId = options.appId, appId = _options$appId === undefined ? null : _options$appId, _options$apiKey = options.apiKey, apiKey = _options$apiKey === undefined ? null : _options$apiKey, _options$indexName = options.indexName, indexName = _options$indexName === undefined ? null : _options$indexName, numberLocale = options.numberLocale, _options$searchParame = options.searchParameters, searchParameters = _options$searchParame === undefined ? {} : _options$searchParame, _options$urlSync = options.urlSync, urlSync = _options$urlSync === undefined ? null : _options$urlSync, _options$routing = options.routing, routing = _options$routing === undefined ? null : _options$routing, searchFunction = options.searchFunction, _options$createAlgoli = options.createAlgoliaClient, createAlgoliaClient = _options$createAlgoli === undefined ? defaultCreateAlgoliaClient : _options$createAlgoli, _options$stalledSearc = options.stalledSearchDelay, stalledSearchDelay = _options$stalledSearc === undefined ? 200 : _options$stalledSearc, _options$searchClient = options.searchClient, searchClient = _options$searchClient === undefined ? null : _options$searchClient;\n        checkOptions({\n            appId: appId,\n            apiKey: apiKey,\n            indexName: indexName,\n            createAlgoliaClient: createAlgoliaClient,\n            searchClient: searchClient\n        });\n        if (searchClient && typeof searchClient.search !== 'function') {\n            throw new Error('InstantSearch configuration error: `searchClient` must implement a `search(requests)` method.');\n        }\n        var client = searchClient || createAlgoliaClient(algoliasearch, appId, apiKey);\n        if (typeof client.addAlgoliaAgent === 'function') {\n            client.addAlgoliaAgent('instantsearch.js ' + version);\n        }\n        _this.client = client;\n        _this.helper = null;\n        _this.indexName = indexName;\n        _this.searchParameters = _extends({}, searchParameters, { index: indexName });\n        _this.widgets = [];\n        _this.templatesConfig = {\n            helpers: createHelpers({ numberLocale: numberLocale }),\n            compileOptions: {}\n        };\n        _this._stalledSearchDelay = stalledSearchDelay;\n        if (searchFunction) {\n            _this._searchFunction = searchFunction;\n        }\n        if (urlSync !== null) {\n            if (routing !== null) {\n                throw new Error('InstantSearch configuration error: it is not possible to use `urlSync` and `routing` at the same time');\n            }\n            warn('`urlSync` option is deprecated and will be removed in the next major version.\\n' + 'You can now use the new `routing` option.');\n            if (urlSync === true) {\n                // when using urlSync: true\n                warn('Use it like this: `routing: true`');\n            }\n            warn('For advanced use cases, checkout the documentation: https://community.algolia.com/instantsearch.js/v2/guides/routing.html#migrating-from-urlsync');\n        }\n        _this.urlSync = urlSync === true ? {} : urlSync;\n        if (routing === true)\n            _this.routing = ROUTING_DEFAULT_OPTIONS;\n        else if (isPlainObject(routing))\n            _this.routing = _extends({}, ROUTING_DEFAULT_OPTIONS, routing);\n        if (options.createAlgoliaClient) {\n            warn('\\n`createAlgoliaClient` option is deprecated and will be removed in the next major version.\\nPlease use `searchClient` instead: https://community.algolia.com/instantsearch.js/v2/instantsearch.html#struct-InstantSearchOptions-searchClient.\\nTo help you migrate, please refer to the migration guide: https://community.algolia.com/instantsearch.js/v2/guides/prepare-for-v3.html');\n        }\n        return _this;\n    }\n    /**\n     * Adds a widget. This can be done before and after InstantSearch has been started. Adding a\n     * widget after InstantSearch started is considered **EXPERIMENTAL** and therefore\n     * it is possibly buggy, if you find anything please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20hot%20addWidget).\n     * @param  {Widget} widget The widget to add to InstantSearch. Widgets are simple objects\n     * that have methods that map the search life cycle in a UI perspective. Usually widgets are\n     * created by [widget factories](widgets.html) like the one provided with InstantSearch.js.\n     * @return {undefined} This method does not return anything\n     */\n    _createClass(InstantSearch, [{\n            key: 'addWidget',\n            value: function addWidget(widget) {\n                this.addWidgets([widget]);\n            }\n            /**\n             * Adds multiple widgets. This can be done before and after the InstantSearch has been started. This feature\n             * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n             * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20addWidgets).\n             * @param  {Widget[]} widgets The array of widgets to add to InstantSearch.\n             * @return {undefined} This method does not return anything\n             */\n        }, {\n            key: 'addWidgets',\n            value: function addWidgets(widgets) {\n                var _this2 = this;\n                if (!Array.isArray(widgets)) {\n                    throw new Error('You need to provide an array of widgets or call `addWidget()`');\n                }\n                // The routing manager widget is always added manually at the last position.\n                // By removing it from the last position and adding it back after, we ensure\n                // it keeps this position.\n                // fixes #3148\n                var lastWidget = this.widgets.pop();\n                widgets.forEach(function (widget) {\n                    // Add the widget to the list of widget\n                    if (widget.render === undefined && widget.init === undefined) {\n                        throw new Error('Widget definition missing render or init method');\n                    }\n                    _this2.widgets.push(widget);\n                });\n                // Second part of the fix for #3148\n                if (lastWidget)\n                    this.widgets.push(lastWidget);\n                // Init the widget directly if instantsearch has been already started\n                if (this.started && Boolean(widgets.length)) {\n                    this.searchParameters = this.widgets.reduce(enhanceConfiguration({}), _extends({}, this.helper.state));\n                    this.helper.setState(this.searchParameters);\n                    widgets.forEach(function (widget) {\n                        if (widget.init) {\n                            widget.init({\n                                state: _this2.helper.state,\n                                helper: _this2.helper,\n                                templatesConfig: _this2.templatesConfig,\n                                createURL: _this2._createAbsoluteURL,\n                                onHistoryChange: _this2._onHistoryChange,\n                                instantSearchInstance: _this2\n                            });\n                        }\n                    });\n                    this.helper.search();\n                }\n            }\n            /**\n             * Removes a widget. This can be done after the InstantSearch has been started. This feature\n             * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n             * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20removeWidget).\n             * @param  {Widget} widget The widget instance to remove from InstantSearch. This widget must implement a `dispose()` method in order to be gracefully removed.\n             * @return {undefined} This method does not return anything\n             */\n        }, {\n            key: 'removeWidget',\n            value: function removeWidget(widget) {\n                this.removeWidgets([widget]);\n            }\n            /**\n             * Removes multiple widgets. This can be done only after the InstantSearch has been started. This feature\n             * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n             * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20addWidgets).\n             * @param  {Widget[]} widgets Array of widgets instances to remove from InstantSearch.\n             * @return {undefined} This method does not return anything\n             */\n        }, {\n            key: 'removeWidgets',\n            value: function removeWidgets(widgets) {\n                var _this3 = this;\n                if (!Array.isArray(widgets)) {\n                    throw new Error('You need to provide an array of widgets or call `removeWidget()`');\n                }\n                widgets.forEach(function (widget) {\n                    if (!_this3.widgets.includes(widget) || typeof widget.dispose !== 'function') {\n                        throw new Error('The widget you tried to remove does not implement the dispose method, therefore it is not possible to remove this widget');\n                    }\n                    _this3.widgets = _this3.widgets.filter(function (w) {\n                        return w !== widget;\n                    });\n                    var nextState = widget.dispose({\n                        helper: _this3.helper,\n                        state: _this3.helper.getState()\n                    });\n                    // re-compute remaining widgets to the state\n                    // in a case two widgets were using the same configuration but we removed one\n                    if (nextState) {\n                        // We don't want to re-add URlSync `getConfiguration` widget\n                        // it can throw errors since it may re-add SearchParameters about something unmounted\n                        _this3.searchParameters = _this3.widgets.filter(function (w) {\n                            return w.constructor.name !== 'URLSync';\n                        }).reduce(enhanceConfiguration({}), _extends({}, nextState));\n                        _this3.helper.setState(_this3.searchParameters);\n                    }\n                });\n                // If there's multiple call to `removeWidget()` let's wait until they are all made\n                // and then check for widgets.length & make a search on next tick\n                //\n                // This solves an issue where you unmount a page and removing widget by widget\n                setTimeout(function () {\n                    // no need to trigger a search if we don't have any widgets left\n                    if (_this3.widgets.length > 0) {\n                        _this3.helper.search();\n                    }\n                }, 0);\n            }\n            /**\n             * Clears the cached answers from Algolia and triggers a new search.\n             *\n             * @return {undefined} Does not return anything\n             */\n        }, {\n            key: 'refresh',\n            value: function refresh() {\n                if (this.helper) {\n                    this.helper.clearCache().search();\n                }\n            }\n            /**\n             * Ends the initialization of InstantSearch.js and triggers the\n             * first search. This method should be called after all widgets have been added\n             * to the instance of InstantSearch.js. InstantSearch.js also supports adding and removing\n             * widgets after the start as an **EXPERIMENTAL** feature.\n             *\n             * @return {undefined} Does not return anything\n             */\n        }, {\n            key: 'start',\n            value: function start() {\n                var _this4 = this;\n                if (!this.widgets)\n                    throw new Error('No widgets were added to instantsearch.js');\n                if (this.started)\n                    throw new Error('start() has been already called once');\n                var searchParametersFromUrl = void 0;\n                if (this.urlSync) {\n                    var syncWidget = urlSyncWidget(this.urlSync);\n                    this._createURL = syncWidget.createURL.bind(syncWidget);\n                    this._createAbsoluteURL = function (relative) {\n                        return _this4._createURL(relative, { absolute: true });\n                    };\n                    this._onHistoryChange = syncWidget.onHistoryChange.bind(syncWidget);\n                    this.widgets.push(syncWidget);\n                    searchParametersFromUrl = syncWidget.searchParametersFromUrl;\n                }\n                else if (this.routing) {\n                    var routingManager = new RoutingManager(_extends({}, this.routing, {\n                        instantSearchInstance: this\n                    }));\n                    this._onHistoryChange = routingManager.onHistoryChange.bind(routingManager);\n                    this._createURL = routingManager.createURL.bind(routingManager);\n                    this._createAbsoluteURL = this._createURL;\n                    this.widgets.push(routingManager);\n                }\n                else {\n                    this._createURL = defaultCreateURL;\n                    this._createAbsoluteURL = defaultCreateURL;\n                    this._onHistoryChange = function () { };\n                }\n                this.searchParameters = this.widgets.reduce(enhanceConfiguration(searchParametersFromUrl), this.searchParameters);\n                var helper = algoliasearchHelper(this.client, this.searchParameters.index || this.indexName, this.searchParameters);\n                if (this._searchFunction) {\n                    this._mainHelperSearch = helper.search.bind(helper);\n                    helper.search = function () {\n                        var helperSearchFunction = algoliasearchHelper({\n                            search: function search() {\n                                return new Promise(function () { });\n                            }\n                        }, helper.state.index, helper.state);\n                        helperSearchFunction.once('search', function (state) {\n                            helper.overrideStateWithoutTriggeringChangeEvent(state);\n                            _this4._mainHelperSearch();\n                        });\n                        _this4._searchFunction(helperSearchFunction);\n                    };\n                }\n                this.helper = helper;\n                this._init(helper.state, this.helper);\n                this.helper.on('result', this._render.bind(this, this.helper));\n                this.helper.on('error', function (e) {\n                    _this4.emit('error', e);\n                });\n                this._searchStalledTimer = null;\n                this._isSearchStalled = true;\n                this.helper.search();\n                this.helper.on('search', function () {\n                    if (!_this4._isSearchStalled && !_this4._searchStalledTimer) {\n                        _this4._searchStalledTimer = setTimeout(function () {\n                            _this4._isSearchStalled = true;\n                            _this4._render(_this4.helper, _this4.helper.lastResults, _this4.helper.lastResults._state);\n                        }, _this4._stalledSearchDelay);\n                    }\n                });\n                // track we started the search if we add more widgets,\n                // to init them directly after add\n                this.started = true;\n            }\n            /**\n             * Removes all widgets without triggering a search afterwards. This is an **EXPERIMENTAL** feature,\n             * if you find an issue with it, please\n             * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20dispose).\n             * @return {undefined} This method does not return anything\n             */\n        }, {\n            key: 'dispose',\n            value: function dispose() {\n                this.removeWidgets(this.widgets);\n            }\n        }, {\n            key: 'createURL',\n            value: function createURL(params) {\n                if (!this._createURL) {\n                    throw new Error('You need to call start() before calling createURL()');\n                }\n                return this._createURL(this.helper.state.setQueryParameters(params));\n            }\n        }, {\n            key: '_render',\n            value: function _render(helper, results, state) {\n                var _this5 = this;\n                if (!this.helper.hasPendingRequests()) {\n                    clearTimeout(this._searchStalledTimer);\n                    this._searchStalledTimer = null;\n                    this._isSearchStalled = false;\n                }\n                forEach(this.widgets, function (widget) {\n                    if (!widget.render) {\n                        return;\n                    }\n                    widget.render({\n                        templatesConfig: _this5.templatesConfig,\n                        results: results,\n                        state: state,\n                        helper: helper,\n                        createURL: _this5._createAbsoluteURL,\n                        instantSearchInstance: _this5,\n                        searchMetadata: {\n                            isSearchStalled: _this5._isSearchStalled\n                        }\n                    });\n                });\n                /**\n                 * Render is triggered when the rendering of the widgets has been completed\n                 * after a search.\n                 * @event InstantSearch#render\n                 */\n                this.emit('render');\n            }\n        }, {\n            key: '_init',\n            value: function _init(state, helper) {\n                var _this6 = this;\n                forEach(this.widgets, function (widget) {\n                    if (widget.init) {\n                        widget.init({\n                            state: state,\n                            helper: helper,\n                            templatesConfig: _this6.templatesConfig,\n                            createURL: _this6._createAbsoluteURL,\n                            onHistoryChange: _this6._onHistoryChange,\n                            instantSearchInstance: _this6\n                        });\n                    }\n                });\n            }\n        }]);\n    return InstantSearch;\n}(EventEmitter);\nexport function enhanceConfiguration(searchParametersFromUrl) {\n    return function (configuration, widgetDefinition) {\n        if (!widgetDefinition.getConfiguration)\n            return configuration;\n        // Get the relevant partial configuration asked by the widget\n        var partialConfiguration = widgetDefinition.getConfiguration(configuration, searchParametersFromUrl);\n        var customizer = function customizer(a, b) {\n            // always create a unified array for facets refinements\n            if (Array.isArray(a)) {\n                return union(a, b);\n            }\n            // avoid mutating objects\n            if (isPlainObject(a)) {\n                return mergeWith({}, a, b, customizer);\n            }\n            return undefined;\n        };\n        return mergeWith({}, configuration, partialConfiguration, customizer);\n    };\n}\nexport default InstantSearch;\n",null]}