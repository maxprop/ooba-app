{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/range/connectRange.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/range/connectRange.js","mtime":1581861144638},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START lodash_find,lodash_isFinite,_.._lib_utils.js PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nvar _slicedToArray = /*@__PURE__*/ function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n            break;\n    }\n}\ncatch (err) {\n    _d = true;\n    _e = err;\n}\nfinally {\n    try {\n        if (!_n && _i[\"return\"])\n            _i[\"return\"]();\n    }\n    finally {\n        if (_d)\n            throw _e;\n    }\n} return _arr; } return function (arr, i) { if (Array.isArray(arr)) {\n    return arr;\n}\nelse if (Symbol.iterator in Object(arr)) {\n    return sliceIterator(arr, i);\n}\nelse {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} }; }();\nfunction _defineProperty(obj, key, value) { if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n}\nelse {\n    obj[key] = value;\n} return obj; }\nimport find from 'lodash/find';\nimport _isFinite from 'lodash/isFinite';\nimport { checkRendering } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customRange = connectRange(function render(params, isFirstRendering) {\\n  // params = {\\n  //   refine,\\n  //   range,\\n  //   start,\\n  //   format,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  // }\\n});\\nsearch.addWidget(\\n  customRange({\\n    attributeName,\\n    [ min ],\\n    [ max ],\\n    [ precision = 2 ],\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectRange.html\\n';\n/**\n * @typedef {Object} CustomRangeWidgetOptions\n * @property {string} attributeName Name of the attribute for faceting.\n * @property {number} [min = undefined] Minimal range value, default to automatically computed from the result set.\n * @property {number} [max = undefined] Maximal range value, default to automatically computed from the result set.\n * @property {number} [precision = 2] Number of digits after decimal point to use.\n */\n/**\n * @typedef {Object} RangeRenderingOptions\n * @property {function(Array<number, number>)} refine Sets a range to filter the results on. Both values\n * are optional, and will default to the higher and lower bounds. You can use `undefined` to remove a\n * previously set bound or to set an infinite bound.\n * @property {{min: number, max: number}} range Results bounds without the current range filter.\n * @property {Array<number, number>} start Current numeric bounds of the search.\n * @property {{from: function, to: function}} formatter Transform for the rendering `from` and/or `to` values.\n * Both functions take a `number` as input and should output a `string`.\n * @property {Object} widgetParams All original `CustomRangeWidgetOptions` forwarded to the `renderFn`.\n */\n/**\n * **Range** connector provides the logic to create custom widget that will let\n * the user refine results using a numeric range.\n *\n * This connectors provides a `refine()` function that accepts bounds. It will also provide\n * information about the min and max bounds for the current result set.\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/range-input/js/\n * @param {function(RangeRenderingOptions, boolean)} renderFn Rendering function for the custom **Range** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomRangeWidgetOptions)} Re-usable widget factory for a custom **Range** widget.\n */\nexport default function connectRange(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attributeName = widgetParams.attributeName, minBound = widgetParams.min, maxBound = widgetParams.max, _widgetParams$precisi = widgetParams.precision, precision = _widgetParams$precisi === undefined ? 2 : _widgetParams$precisi;\n        if (!attributeName) {\n            throw new Error(usage);\n        }\n        var hasMinBound = _isFinite(minBound);\n        var hasMaxBound = _isFinite(maxBound);\n        var formatToNumber = function formatToNumber(v) {\n            return Number(Number(v).toFixed(precision));\n        };\n        var rangeFormatter = {\n            from: function from(v) {\n                return v;\n            },\n            to: function to(v) {\n                return formatToNumber(v).toLocaleString();\n            }\n        };\n        return {\n            _getCurrentRange: function _getCurrentRange(stats) {\n                var pow = Math.pow(10, precision);\n                var min = void 0;\n                if (hasMinBound) {\n                    min = minBound;\n                }\n                else if (_isFinite(stats.min)) {\n                    min = stats.min;\n                }\n                else {\n                    min = 0;\n                }\n                var max = void 0;\n                if (hasMaxBound) {\n                    max = maxBound;\n                }\n                else if (_isFinite(stats.max)) {\n                    max = stats.max;\n                }\n                else {\n                    max = 0;\n                }\n                return {\n                    min: Math.floor(min * pow) / pow,\n                    max: Math.ceil(max * pow) / pow\n                };\n            },\n            _getCurrentRefinement: function _getCurrentRefinement(helper) {\n                var _ref = helper.getNumericRefinement(attributeName, '>=') || [], _ref2 = _slicedToArray(_ref, 1), minValue = _ref2[0];\n                var _ref3 = helper.getNumericRefinement(attributeName, '<=') || [], _ref4 = _slicedToArray(_ref3, 1), maxValue = _ref4[0];\n                var min = _isFinite(minValue) ? minValue : -Infinity;\n                var max = _isFinite(maxValue) ? maxValue : Infinity;\n                return [min, max];\n            },\n            _refine: function _refine(helper, currentRange) {\n                // eslint-disable-next-line complexity\n                return function () {\n                    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], _ref6 = _slicedToArray(_ref5, 2), nextMin = _ref6[0], nextMax = _ref6[1];\n                    var currentRangeMin = currentRange.min, currentRangeMax = currentRange.max;\n                    var _ref7 = helper.getNumericRefinement(attributeName, '>=') || [], _ref8 = _slicedToArray(_ref7, 1), min = _ref8[0];\n                    var _ref9 = helper.getNumericRefinement(attributeName, '<=') || [], _ref10 = _slicedToArray(_ref9, 1), max = _ref10[0];\n                    var isResetMin = nextMin === undefined || nextMin === '';\n                    var isResetMax = nextMax === undefined || nextMax === '';\n                    var nextMinAsNumber = !isResetMin ? parseFloat(nextMin) : undefined;\n                    var nextMaxAsNumber = !isResetMax ? parseFloat(nextMax) : undefined;\n                    var newNextMin = void 0;\n                    if (!hasMinBound && currentRangeMin === nextMinAsNumber) {\n                        newNextMin = undefined;\n                    }\n                    else if (hasMinBound && isResetMin) {\n                        newNextMin = minBound;\n                    }\n                    else {\n                        newNextMin = nextMinAsNumber;\n                    }\n                    var newNextMax = void 0;\n                    if (!hasMaxBound && currentRangeMax === nextMaxAsNumber) {\n                        newNextMax = undefined;\n                    }\n                    else if (hasMaxBound && isResetMax) {\n                        newNextMax = maxBound;\n                    }\n                    else {\n                        newNextMax = nextMaxAsNumber;\n                    }\n                    var isResetNewNextMin = newNextMin === undefined;\n                    var isValidNewNextMin = _isFinite(newNextMin);\n                    var isValidMinCurrentRange = _isFinite(currentRangeMin);\n                    var isGreaterThanCurrentRange = isValidMinCurrentRange && currentRangeMin <= newNextMin;\n                    var isMinValid = isResetNewNextMin || isValidNewNextMin && (!isValidMinCurrentRange || isGreaterThanCurrentRange);\n                    var isResetNewNextMax = newNextMax === undefined;\n                    var isValidNewNextMax = _isFinite(newNextMax);\n                    var isValidMaxCurrentRange = _isFinite(currentRangeMax);\n                    var isLowerThanRange = isValidMaxCurrentRange && currentRangeMax >= newNextMax;\n                    var isMaxValid = isResetNewNextMax || isValidNewNextMax && (!isValidMaxCurrentRange || isLowerThanRange);\n                    var hasMinChange = min !== newNextMin;\n                    var hasMaxChange = max !== newNextMax;\n                    if ((hasMinChange || hasMaxChange) && isMinValid && isMaxValid) {\n                        helper.clearRefinements(attributeName);\n                        if (isValidNewNextMin) {\n                            helper.addNumericRefinement(attributeName, '>=', formatToNumber(newNextMin));\n                        }\n                        if (isValidNewNextMax) {\n                            helper.addNumericRefinement(attributeName, '<=', formatToNumber(newNextMax));\n                        }\n                        helper.search();\n                    }\n                };\n            },\n            getConfiguration: function getConfiguration(currentConfiguration) {\n                var configuration = {\n                    disjunctiveFacets: [attributeName]\n                };\n                var isBoundsDefined = hasMinBound || hasMaxBound;\n                var boundsAlreadyDefined = currentConfiguration && currentConfiguration.numericRefinements && currentConfiguration.numericRefinements[attributeName] !== undefined;\n                var isMinBoundValid = _isFinite(minBound);\n                var isMaxBoundValid = _isFinite(maxBound);\n                var isAbleToRefine = isMinBoundValid && isMaxBoundValid ? minBound < maxBound : isMinBoundValid || isMaxBoundValid;\n                if (isBoundsDefined && !boundsAlreadyDefined && isAbleToRefine) {\n                    configuration.numericRefinements = _defineProperty({}, attributeName, {});\n                    if (hasMinBound) {\n                        configuration.numericRefinements[attributeName]['>='] = [minBound];\n                    }\n                    if (hasMaxBound) {\n                        configuration.numericRefinements[attributeName]['<='] = [maxBound];\n                    }\n                }\n                return configuration;\n            },\n            init: function init(_ref11) {\n                var helper = _ref11.helper, instantSearchInstance = _ref11.instantSearchInstance;\n                var stats = {};\n                var currentRange = this._getCurrentRange(stats);\n                var start = this._getCurrentRefinement(helper);\n                renderFn({\n                    // On first render pass an empty range\n                    // to be able to bypass the validation\n                    // related to it\n                    refine: this._refine(helper, {}),\n                    format: rangeFormatter,\n                    range: currentRange,\n                    widgetParams: _extends({}, widgetParams, {\n                        precision: precision\n                    }),\n                    start: start,\n                    instantSearchInstance: instantSearchInstance\n                }, true);\n            },\n            render: function render(_ref12) {\n                var results = _ref12.results, helper = _ref12.helper, instantSearchInstance = _ref12.instantSearchInstance;\n                var facetsFromResults = results.disjunctiveFacets || [];\n                var facet = find(facetsFromResults, { name: attributeName });\n                var stats = facet && facet.stats || {};\n                var currentRange = this._getCurrentRange(stats);\n                var start = this._getCurrentRefinement(helper);\n                renderFn({\n                    refine: this._refine(helper, currentRange),\n                    format: rangeFormatter,\n                    range: currentRange,\n                    widgetParams: _extends({}, widgetParams, {\n                        precision: precision\n                    }),\n                    start: start,\n                    instantSearchInstance: instantSearchInstance\n                }, false);\n            },\n            dispose: function dispose(_ref13) {\n                var state = _ref13.state;\n                unmountFn();\n                var nextState = state.removeNumericRefinement(attributeName).removeDisjunctiveFacet(attributeName);\n                return nextState;\n            },\n            getWidgetState: function getWidgetState(uiState, _ref14) {\n                var searchParameters = _ref14.searchParameters;\n                var _searchParameters$get = searchParameters.getNumericRefinements(attributeName), _searchParameters$get2 = _searchParameters$get['>='], min = _searchParameters$get2 === undefined ? '' : _searchParameters$get2, _searchParameters$get3 = _searchParameters$get['<='], max = _searchParameters$get3 === undefined ? '' : _searchParameters$get3;\n                if (min === '' && max === '' || uiState && uiState.range && uiState.range[attributeName] === min + ':' + max) {\n                    return uiState;\n                }\n                return _extends({}, uiState, {\n                    range: _extends({}, uiState.range, _defineProperty({}, attributeName, min + ':' + max))\n                });\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref15) {\n                var uiState = _ref15.uiState;\n                var value = uiState && uiState.range && uiState.range[attributeName];\n                if (!value || value.indexOf(':') === -1) {\n                    return searchParameters;\n                }\n                var _searchParameters$get4 = searchParameters.getNumericRefinements(attributeName), _searchParameters$get5 = _searchParameters$get4['>='], previousMin = _searchParameters$get5 === undefined ? [NaN] : _searchParameters$get5, _searchParameters$get6 = _searchParameters$get4['<='], previousMax = _searchParameters$get6 === undefined ? [NaN] : _searchParameters$get6;\n                var clearedParams = searchParameters.clearRefinements(attributeName);\n                var _value$split$map = value.split(':').map(parseFloat), _value$split$map2 = _slicedToArray(_value$split$map, 2), lowerBound = _value$split$map2[0], upperBound = _value$split$map2[1];\n                if (previousMin.includes(lowerBound) && previousMax.includes(upperBound)) {\n                    return searchParameters;\n                }\n                if (_isFinite(lowerBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '>=', lowerBound);\n                }\n                if (_isFinite(upperBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '<=', upperBound);\n                }\n                return clearedParams;\n            }\n        };\n    };\n}\n",null]}