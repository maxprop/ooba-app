{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/numeric-refinement-list/connectNumericRefinementList.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/numeric-refinement-list/connectNumericRefinementList.js","mtime":1581861144634},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START lodash_isFinite,_.._lib_utils.js PURE_IMPORTS_END */\nvar _slicedToArray = /*@__PURE__*/ function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n            break;\n    }\n}\ncatch (err) {\n    _d = true;\n    _e = err;\n}\nfinally {\n    try {\n        if (!_n && _i[\"return\"])\n            _i[\"return\"]();\n    }\n    finally {\n        if (_d)\n            throw _e;\n    }\n} return _arr; } return function (arr, i) { if (Array.isArray(arr)) {\n    return arr;\n}\nelse if (Symbol.iterator in Object(arr)) {\n    return sliceIterator(arr, i);\n}\nelse {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} }; }();\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nfunction _defineProperty(obj, key, value) { if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n}\nelse {\n    obj[key] = value;\n} return obj; }\nimport _isFinite from 'lodash/isFinite';\nimport { checkRendering } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customNumericRefinementList = connectNumericRefinementList(function renderFn(params, isFirstRendering) {\\n  // params = {\\n  //   createURL,\\n  //   items,\\n  //   hasNoResults,\\n  //   refine,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  //  }\\n});\\n\\nsearch.addWidget(\\n  customNumericRefinementList({\\n    attributeName,\\n    options,\\n    [ transformItems ],\\n  })\\n);\\n\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectNumericRefinementList.html\\n';\n/**\n * @typedef {Object} NumericRefinementListOption\n * @property {string} name Name of the option.\n * @property {number} start Lower bound of the option (>=).\n * @property {number} end Higher bound of the option (<=).\n */\n/**\n * @typedef {Object} NumericRefinementListItem\n * @property {string} label Name of the option.\n * @property {string} value URL encoded of the bounds object with the form `{start, end}`. This value can be used verbatim in the webpage and can be read by `refine` directly. If you want to inspect the value, you can do `JSON.parse(window.decodeURI(value))` to get the object.\n * @property {boolean} isRefined True if the value is selected.\n */\n/**\n * @typedef {Object} CustomNumericRefinementListWidgetOptions\n * @property {string} attributeName Name of the attribute for filtering.\n * @property {NumericRefinementListOption[]} options List of all the options.\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n/**\n * @typedef {Object} NumericRefinementListRenderingOptions\n * @property {function(item.value): string} createURL Creates URLs for the next state, the string is the name of the selected option.\n * @property {NumericRefinementListItem[]} items The list of available choices.\n * @property {boolean} hasNoResults `true` if the last search contains no result.\n * @property {function(item.value)} refine Sets the selected value and trigger a new search.\n * @property {Object} widgetParams All original `CustomNumericRefinementListWidgetOptions` forwarded to the `renderFn`.\n */\n/**\n * **NumericRefinementList** connector provides the logic to build a custom widget that will give the user the ability to choose a range on to refine the search results.\n *\n * It provides a `refine(item)` function to refine on the selected range.\n *\n * **Requirement:** the attribute passed as `attributeName` must be present in \"attributes for faceting\" on the Algolia dashboard or configured as attributesForFaceting via a set settings call to the Algolia API.\n * @function connectNumericRefinementList\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/numeric-menu/js/\n * @param {function(NumericRefinementListRenderingOptions, boolean)} renderFn Rendering function for the custom **NumericRefinementList** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomNumericRefinementListWidgetOptions)} Re-usable widget factory for a custom **NumericRefinementList** widget.\n * @example\n * // custom `renderFn` to render the custom NumericRefinementList widget\n * function renderFn(NumericRefinementListRenderingOptions, isFirstRendering) {\n *   if (isFirstRendering) {\n *     NumericRefinementListRenderingOptions.widgetParams.containerNode.html('<ul></ul>');\n *   }\n *\n *   NumericRefinementListRenderingOptions.widgetParams.containerNode\n *     .find('li[data-refine-value]')\n *     .each(function() { $(this).off('click'); });\n *\n *   var list = NumericRefinementListRenderingOptions.items.map(function(item) {\n *     return '<li data-refine-value=\"' + item.value + '\">' +\n *       '<input type=\"radio\"' + (item.isRefined ? ' checked' : '') + '/> ' +\n *       item.label + '</li>';\n *   });\n *\n *   NumericRefinementListRenderingOptions.widgetParams.containerNode.find('ul').html(list);\n *   NumericRefinementListRenderingOptions.widgetParams.containerNode\n *     .find('li[data-refine-value]')\n *     .each(function() {\n *       $(this).on('click', function(event) {\n *         event.preventDefault();\n *         event.stopPropagation();\n *         NumericRefinementListRenderingOptions.refine($(this).data('refine-value'));\n *       });\n *     });\n * }\n *\n * // connect `renderFn` to NumericRefinementList logic\n * var customNumericRefinementList = instantsearch.connectors.connectNumericRefinementList(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customNumericRefinementList({\n *     containerNode: $('#custom-numeric-refinement-container'),\n *     attributeName: 'price',\n *     options: [\n *       {name: 'All'},\n *       {end: 4, name: 'less than 4'},\n *       {start: 4, end: 4, name: '4'},\n *       {start: 5, end: 10, name: 'between 5 and 10'},\n *       {start: 10, name: 'more than 10'},\n *     ],\n *   })\n * );\n */\nexport default function connectNumericRefinementList(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attributeName = widgetParams.attributeName, options = widgetParams.options, _widgetParams$transfo = widgetParams.transformItems, transformItems = _widgetParams$transfo === undefined ? function (items) {\n            return items;\n        } : _widgetParams$transfo;\n        if (!attributeName || !options) {\n            throw new Error(usage);\n        }\n        return {\n            init: function init(_ref) {\n                var helper = _ref.helper, createURL = _ref.createURL, instantSearchInstance = _ref.instantSearchInstance;\n                this._refine = function (facetValue) {\n                    var refinedState = refine(helper.state, attributeName, options, facetValue);\n                    helper.setState(refinedState).search();\n                };\n                this._createURL = function (state) {\n                    return function (facetValue) {\n                        return createURL(refine(state, attributeName, options, facetValue));\n                    };\n                };\n                this._prepareItems = function (state) {\n                    return options.map(function (_ref2) {\n                        var start = _ref2.start, end = _ref2.end, label = _ref2.name;\n                        return {\n                            label: label,\n                            value: window.encodeURI(JSON.stringify({ start: start, end: end })),\n                            isRefined: isRefined(state, attributeName, { start: start, end: end })\n                        };\n                    });\n                };\n                renderFn({\n                    createURL: this._createURL(helper.state),\n                    items: transformItems(this._prepareItems(helper.state)),\n                    hasNoResults: true,\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    widgetParams: widgetParams\n                }, true);\n            },\n            render: function render(_ref3) {\n                var results = _ref3.results, state = _ref3.state, instantSearchInstance = _ref3.instantSearchInstance;\n                renderFn({\n                    createURL: this._createURL(state),\n                    items: transformItems(this._prepareItems(state)),\n                    hasNoResults: results.nbHits === 0,\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    widgetParams: widgetParams\n                }, false);\n            },\n            dispose: function dispose(_ref4) {\n                var state = _ref4.state;\n                unmountFn();\n                return state.clearRefinements(attributeName);\n            },\n            getWidgetState: function getWidgetState(uiState, _ref5) {\n                var searchParameters = _ref5.searchParameters;\n                var currentRefinements = searchParameters.getNumericRefinements(attributeName);\n                var equal = currentRefinements['='] && currentRefinements['='][0];\n                if (equal || equal === 0) {\n                    return _extends({}, uiState, {\n                        numericRefinementList: _extends({}, uiState.numericRefinementList, _defineProperty({}, attributeName, '' + currentRefinements['=']))\n                    });\n                }\n                var lowerBound = currentRefinements['>='] && currentRefinements['>='][0] || '';\n                var upperBound = currentRefinements['<='] && currentRefinements['<='][0] || '';\n                if (lowerBound !== '' || upperBound !== '') {\n                    if (uiState.numericRefinementList && uiState.numericRefinementList[attributeName] === lowerBound + ':' + upperBound)\n                        return uiState;\n                    return _extends({}, uiState, {\n                        numericRefinementList: _extends({}, uiState.numericRefinementList, _defineProperty({}, attributeName, lowerBound + ':' + upperBound))\n                    });\n                }\n                return uiState;\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n                var uiState = _ref6.uiState;\n                var clearedParams = searchParameters.clearRefinements(attributeName);\n                var value = uiState.numericRefinementList && uiState.numericRefinementList[attributeName];\n                if (!value) {\n                    return clearedParams;\n                }\n                var valueAsEqual = value.indexOf(':') === -1 && value;\n                if (valueAsEqual) {\n                    return clearedParams.addNumericRefinement(attributeName, '=', valueAsEqual);\n                }\n                var _value$split$map = value.split(':').map(parseFloat), _value$split$map2 = _slicedToArray(_value$split$map, 2), lowerBound = _value$split$map2[0], upperBound = _value$split$map2[1];\n                if (_isFinite(lowerBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '>=', lowerBound);\n                }\n                if (_isFinite(upperBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '<=', upperBound);\n                }\n                return clearedParams;\n            }\n        };\n    };\n}\nfunction isRefined(state, attributeName, option) {\n    var currentRefinements = state.getNumericRefinements(attributeName);\n    if (option.start !== undefined && option.end !== undefined) {\n        if (option.start === option.end) {\n            return hasNumericRefinement(currentRefinements, '=', option.start);\n        }\n    }\n    if (option.start !== undefined) {\n        return hasNumericRefinement(currentRefinements, '>=', option.start);\n    }\n    if (option.end !== undefined) {\n        return hasNumericRefinement(currentRefinements, '<=', option.end);\n    }\n    if (option.start === undefined && option.end === undefined) {\n        return Object.keys(currentRefinements).length === 0;\n    }\n    return undefined;\n}\nfunction refine(state, attributeName, options, facetValue) {\n    var resolvedState = state;\n    var refinedOption = JSON.parse(window.decodeURI(facetValue));\n    var currentRefinements = resolvedState.getNumericRefinements(attributeName);\n    if (refinedOption.start === undefined && refinedOption.end === undefined) {\n        return resolvedState.clearRefinements(attributeName);\n    }\n    if (!isRefined(resolvedState, attributeName, refinedOption)) {\n        resolvedState = resolvedState.clearRefinements(attributeName);\n    }\n    if (refinedOption.start !== undefined && refinedOption.end !== undefined) {\n        if (refinedOption.start > refinedOption.end) {\n            throw new Error('option.start should be > to option.end');\n        }\n        if (refinedOption.start === refinedOption.end) {\n            if (hasNumericRefinement(currentRefinements, '=', refinedOption.start)) {\n                resolvedState = resolvedState.removeNumericRefinement(attributeName, '=', refinedOption.start);\n            }\n            else {\n                resolvedState = resolvedState.addNumericRefinement(attributeName, '=', refinedOption.start);\n            }\n            return resolvedState;\n        }\n    }\n    if (refinedOption.start !== undefined) {\n        if (hasNumericRefinement(currentRefinements, '>=', refinedOption.start)) {\n            resolvedState = resolvedState.removeNumericRefinement(attributeName, '>=', refinedOption.start);\n        }\n        else {\n            resolvedState = resolvedState.addNumericRefinement(attributeName, '>=', refinedOption.start);\n        }\n    }\n    if (refinedOption.end !== undefined) {\n        if (hasNumericRefinement(currentRefinements, '<=', refinedOption.end)) {\n            resolvedState = resolvedState.removeNumericRefinement(attributeName, '<=', refinedOption.end);\n        }\n        else {\n            resolvedState = resolvedState.addNumericRefinement(attributeName, '<=', refinedOption.end);\n        }\n    }\n    resolvedState.page = 0;\n    return resolvedState;\n}\nfunction hasNumericRefinement(currentRefinements, operator, value) {\n    var hasOperatorRefinements = currentRefinements[operator] !== undefined;\n    return hasOperatorRefinements && currentRefinements[operator].includes(value);\n}\n",null]}