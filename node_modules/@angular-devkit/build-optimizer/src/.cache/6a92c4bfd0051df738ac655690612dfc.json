{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/utils.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/utils.js","mtime":1581861144660},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START lodash_reduce,lodash_forEach,lodash_find,lodash_get,lodash_keys,lodash_uniq,lodash_mapKeys,lodash_mapValues,lodash_curry,hogan.js PURE_IMPORTS_END */\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nelse {\n    return Array.from(arr);\n} }\nimport reduce from 'lodash/reduce';\nimport forEach from 'lodash/forEach';\nimport find from 'lodash/find';\nimport get from 'lodash/get';\nimport keys from 'lodash/keys';\nimport uniq from 'lodash/uniq';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport curry from 'lodash/curry';\nimport hogan from 'hogan.js';\nexport { getContainerNode, bemHelper, prepareTemplateProps, renderTemplate, isSpecialClick, isDomElement, getRefinements, getAttributesToClear, clearRefinements, prefixKeys, escapeRefinement, unescapeRefinement, checkRendering, isReactElement, deprecate, warn, parseAroundLatLngFromString };\n/**\n * Return the container. If it's a string, it is considered a\n * css selector and retrieves the first matching element. Otherwise\n * test if it validates that it's a correct DOMElement.\n * @param {string|HTMLElement} selectorOrHTMLElement a selector or a node\n * @return {HTMLElement} The resolved HTMLElement\n * @throws Error when the type is not correct\n */\nfunction getContainerNode(selectorOrHTMLElement) {\n    var isFromString = typeof selectorOrHTMLElement === 'string';\n    var domElement = void 0;\n    if (isFromString) {\n        domElement = document.querySelector(selectorOrHTMLElement);\n    }\n    else {\n        domElement = selectorOrHTMLElement;\n    }\n    if (!isDomElement(domElement)) {\n        var errorMessage = 'Container must be `string` or `HTMLElement`.';\n        if (isFromString) {\n            errorMessage += ' Unable to find ' + selectorOrHTMLElement;\n        }\n        throw new Error(errorMessage);\n    }\n    return domElement;\n}\n/**\n * Returns true if the parameter is a DOMElement.\n * @param {any} o the value to test\n * @return {boolean} true if o is a DOMElement\n */\nfunction isDomElement(o) {\n    return o instanceof window.HTMLElement || Boolean(o) && o.nodeType > 0;\n}\nfunction isSpecialClick(event) {\n    var isMiddleClick = event.button === 1;\n    return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n}\n/**\n * Creates BEM class name according the vanilla BEM style.\n * @param {string} block the main block\n * @return {function} function that takes up to 2 parameters\n * that determine the element and the modifier of the BEM class.\n */\nfunction bemHelper(block) {\n    return function (element, modifier) {\n        // block--element\n        if (element && !modifier) {\n            return block + '--' + element;\n        }\n        // block--element__modifier\n        if (element && modifier) {\n            return block + '--' + element + '__' + modifier;\n        }\n        // block__modifier\n        if (!element && modifier) {\n            return block + '__' + modifier;\n        }\n        return block;\n    };\n}\n/**\n * Prepares an object to be passed to the Template widget\n * @param {object} unknownBecauseES6 an object with the following attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - templatesConfig\n * @return {object} the configuration with the attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - useCustomCompileOptions\n */\nfunction prepareTemplateProps(_ref) {\n    var transformData = _ref.transformData, defaultTemplates = _ref.defaultTemplates, templates = _ref.templates, templatesConfig = _ref.templatesConfig;\n    var preparedTemplates = prepareTemplates(defaultTemplates, templates);\n    return _extends({\n        transformData: transformData,\n        templatesConfig: templatesConfig\n    }, preparedTemplates);\n}\nfunction prepareTemplates() {\n    var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var allKeys = uniq([].concat(_toConsumableArray(keys(defaultTemplates)), _toConsumableArray(keys(templates))));\n    return reduce(allKeys, function (config, key) {\n        var defaultTemplate = defaultTemplates[key];\n        var customTemplate = templates[key];\n        var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;\n        config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;\n        config.useCustomCompileOptions[key] = isCustomTemplate;\n        return config;\n    }, { templates: {}, useCustomCompileOptions: {} });\n}\nfunction renderTemplate(_ref2) {\n    var templates = _ref2.templates, templateKey = _ref2.templateKey, compileOptions = _ref2.compileOptions, helpers = _ref2.helpers, data = _ref2.data;\n    var template = templates[templateKey];\n    var templateType = typeof template === 'undefined' ? 'undefined' : _typeof(template);\n    var isTemplateString = templateType === 'string';\n    var isTemplateFunction = templateType === 'function';\n    if (!isTemplateString && !isTemplateFunction) {\n        throw new Error('Template must be \\'string\\' or \\'function\\', was \\'' + templateType + '\\' (key: ' + templateKey + ')');\n    }\n    if (isTemplateFunction) {\n        return template(data);\n    }\n    var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n    return hogan.compile(template, compileOptions).render(_extends({}, data, {\n        helpers: transformedHelpers\n    }));\n}\n// We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\nfunction transformHelpersToHogan(helpers, compileOptions, data) {\n    return mapValues(helpers, function (method) {\n        return curry(function (text) {\n            var _this = this;\n            var render = function render(value) {\n                return hogan.compile(value, compileOptions).render(_this);\n            };\n            return method.call(data, text, render);\n        });\n    });\n}\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n    var res = { type: type, attributeName: attributeName, name: name };\n    var facet = find(resultsFacets, { name: attributeName });\n    var count = void 0;\n    if (type === 'hierarchical') {\n        var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n        var split = name.split(facetDeclaration.separator);\n        res.name = split[split.length - 1];\n        for (var i = 0; facet !== undefined && i < split.length; ++i) {\n            facet = find(facet.data, { name: split[i] });\n        }\n        count = get(facet, 'count');\n    }\n    else {\n        count = get(facet, 'data[\"' + res.name + '\"]');\n    }\n    var exhaustive = get(facet, 'exhaustive');\n    if (count !== undefined) {\n        res.count = count;\n    }\n    if (exhaustive !== undefined) {\n        res.exhaustive = exhaustive;\n    }\n    return res;\n}\nfunction getRefinements(results, state, clearsQuery) {\n    var res = clearsQuery && state.query && state.query.trim() ? [{\n            type: 'query',\n            name: state.query,\n            query: state.query,\n            attributeName: 'query'\n        }] : [];\n    forEach(state.facetsRefinements, function (refinements, attributeName) {\n        forEach(refinements, function (name) {\n            res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n        });\n    });\n    forEach(state.facetsExcludes, function (refinements, attributeName) {\n        forEach(refinements, function (name) {\n            res.push({ type: 'exclude', attributeName: attributeName, name: name, exclude: true });\n        });\n    });\n    forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {\n        forEach(refinements, function (name) {\n            res.push(getRefinement(state, 'disjunctive', attributeName, \n            // we unescapeRefinement any disjunctive refined value since they can be escaped\n            // when negative numeric values search `escapeRefinement` usage in code\n            unescapeRefinement(name), results.disjunctiveFacets));\n        });\n    });\n    forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {\n        forEach(refinements, function (name) {\n            res.push(getRefinement(state, 'hierarchical', attributeName, name, results.hierarchicalFacets));\n        });\n    });\n    forEach(state.numericRefinements, function (operators, attributeName) {\n        forEach(operators, function (values, operator) {\n            forEach(values, function (value) {\n                res.push({\n                    type: 'numeric',\n                    attributeName: attributeName,\n                    name: '' + value,\n                    numericValue: value,\n                    operator: operator\n                });\n            });\n        });\n    });\n    forEach(state.tagRefinements, function (name) {\n        res.push({ type: 'tag', attributeName: '_tags', name: name });\n    });\n    return res;\n}\n/**\n * Clears the refinements of a SearchParameters object based on rules provided.\n * The white list is first used then the black list is applied. If no white list\n * is provided, all the current refinements are used.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] list of parameters to clear\n * @param {string[]} [$0.blackList=[]] list of parameters not to remove (will impact the white list)\n * @param {boolean} [$0.clearsQuery=false] clears the query if need be\n * @returns {SearchParameters} search parameters with refinements cleared\n */\nfunction clearRefinements(_ref3) {\n    var helper = _ref3.helper, whiteList = _ref3.whiteList, _ref3$blackList = _ref3.blackList, blackList = _ref3$blackList === undefined ? [] : _ref3$blackList, _ref3$clearsQuery = _ref3.clearsQuery, clearsQuery = _ref3$clearsQuery === undefined ? false : _ref3$clearsQuery;\n    var attributesToClear = getAttributesToClear({\n        helper: helper,\n        whiteList: whiteList,\n        blackList: blackList\n    });\n    var finalState = helper.state;\n    attributesToClear.forEach(function (attribute) {\n        if (attribute === '_tags') {\n            finalState = finalState.clearTags();\n        }\n        else {\n            finalState = finalState.clearRefinements(attribute);\n        }\n    });\n    if (clearsQuery) {\n        finalState = finalState.setQuery('');\n    }\n    return finalState;\n}\n/**\n * Computes the list of attributes (conjunctive, disjunctive, hierarchical facet + numerical attributes)\n * to clear based on a optional white and black lists. The white list is applied first then the black list.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] attributes to clear (defaults to all attributes)\n * @param {string[]} [$0.blackList=[]] attributes to keep, will override the white list\n * @returns {string[]} the list of attributes to clear based on the rules\n */\nfunction getAttributesToClear(_ref4) {\n    var helper = _ref4.helper, whiteList = _ref4.whiteList, blackList = _ref4.blackList;\n    var lastResults = helper.lastResults || {};\n    var attributesToClear = whiteList || getRefinements(lastResults, helper.state).map(function (one) {\n        return one.attributeName;\n    });\n    return attributesToClear.filter(function (attribute) {\n        return blackList.indexOf(attribute) === -1;\n    });\n}\nfunction prefixKeys(prefix, obj) {\n    if (obj) {\n        return mapKeys(obj, function (v, k) {\n            return prefix + k;\n        });\n    }\n    return undefined;\n}\nfunction escapeRefinement(value) {\n    if (typeof value === 'number' && value < 0) {\n        value = String(value).replace(/^-/, '\\\\-');\n    }\n    return value;\n}\nfunction unescapeRefinement(value) {\n    return String(value).replace(/^\\\\-/, '-');\n}\nfunction checkRendering(rendering, usage) {\n    if (rendering === undefined || typeof rendering !== 'function') {\n        throw new Error(usage);\n    }\n}\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && /*@__PURE__*/ _typeof(Symbol.iterator) === 'symbol' && Symbol.for && /*@__PURE__*/ Symbol.for('react.element') || 0xeac7;\nfunction isReactElement(object) {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction logger(message) {\n    // eslint-disable-next-line no-console\n    console.warn('[InstantSearch.js]: ' + message.trim());\n}\nfunction deprecate(fn, message) {\n    var hasAlreadyPrint = false;\n    return function () {\n        if (!hasAlreadyPrint) {\n            hasAlreadyPrint = true;\n            logger(message);\n        }\n        return fn.apply(undefined, arguments);\n    };\n}\nwarn.cache = {};\nfunction warn(message) {\n    var hasAlreadyPrint = warn.cache[message];\n    if (!hasAlreadyPrint) {\n        warn.cache[message] = true;\n        logger(message);\n    }\n}\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nfunction parseAroundLatLngFromString(value) {\n    var pattern = value.match(latLngRegExp);\n    // Since the value provided is the one send with the query, the API should\n    // throw an error due to the wrong format. So throw an error should be safe..\n    if (!pattern) {\n        throw new Error('Invalid value for \"aroundLatLng\" parameter: \"' + value + '\"');\n    }\n    return {\n        lat: parseFloat(pattern[1]),\n        lng: parseFloat(pattern[2])\n    };\n}\n",null]}