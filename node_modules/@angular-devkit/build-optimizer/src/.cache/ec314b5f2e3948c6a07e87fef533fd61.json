{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/Validator.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/Validator.js","mtime":1581861142194},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.number.constructor\");\n\nrequire(\"core-js/modules/es.number.is-nan\");\n\nrequire(\"core-js/modules/es.object.keys\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/es.string.trim\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _utils = require(\"../utils/utils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _calendarUtils = require(\"../utils/calendarUtils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _default = {\n  get: _lodash.default.get,\n  each: _lodash.default.each,\n  has: _lodash.default.has,\n  checkValidator: function checkValidator(component, validator, setting, value, data) {\n    var result = null; // Allow each component to override their own validators by implementing the validator.method\n\n    if (validator.method && typeof component[validator.method] === 'function') {\n      result = component[validator.method](setting, value, data);\n    } else {\n      result = validator.check.call(this, component, setting, value, data);\n    }\n\n    if (typeof result === 'string') {\n      return result;\n    }\n\n    if (!result) {\n      return validator.message.call(this, component, setting);\n    }\n\n    return '';\n  },\n  validate: function validate(component, validator, value, data) {\n    if (validator.key && _lodash.default.has(component.component, validator.key)) {\n      var setting = this.get(component.component, validator.key);\n      return this.checkValidator(component, validator, setting, value, data);\n    }\n\n    return this.checkValidator(component, validator, null, value, data);\n  },\n  check: function check(component, data) {\n    var _this = this;\n\n    var result = '';\n    var value = component.validationValue;\n    data = data || component.data;\n\n    _lodash.default.each(component.validators, function (name) {\n      if (_this.validators.hasOwnProperty(name)) {\n        var validator = _this.validators[name];\n\n        if (component.validateMultiple(value)) {\n          _lodash.default.each(value, function (val) {\n            result = _this.validate(component, validator, val, data);\n\n            if (result) {\n              return false;\n            }\n          });\n        } else {\n          result = _this.validate(component, validator, value, data);\n        }\n\n        if (result) {\n          return false;\n        }\n      }\n    });\n\n    var validateCustom = _lodash.default.get(component, 'component.validate.custom');\n\n    var customErrorMessage = _lodash.default.get(component, 'component.validate.customMessage');\n\n    if (result && (customErrorMessage || validateCustom)) {\n      result = component.t(customErrorMessage || result, {\n        field: component.errorLabel,\n        data: component.data\n      });\n    }\n\n    return result;\n  },\n  validators: {\n    required: {\n      key: 'validate.required',\n      method: 'validateRequired',\n      message: function message(component) {\n        return component.t(component.errorMessage('required'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        if (!(0, _utils.boolValue)(setting)) {\n          return true;\n        }\n\n        var isCalendar = component.validators.some(function (validator) {\n          return validator === 'calendar';\n        });\n\n        if (!value && isCalendar && component.widget.enteredDate) {\n          return !this.validators.calendar.check.call(this, component, setting, value);\n        }\n\n        return !component.isEmpty(value);\n      }\n    },\n    min: {\n      key: 'validate.min',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('min'), {\n          field: component.errorLabel,\n          min: parseFloat(setting),\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var min = parseFloat(setting);\n\n        if (Number.isNaN(min) || !_lodash.default.isNumber(value)) {\n          return true;\n        }\n\n        return parseFloat(value) >= min;\n      }\n    },\n    max: {\n      key: 'validate.max',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('max'), {\n          field: component.errorLabel,\n          max: parseFloat(setting),\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var max = parseFloat(setting);\n\n        if (Number.isNaN(max) || !_lodash.default.isNumber(value)) {\n          return true;\n        }\n\n        return parseFloat(value) <= max;\n      }\n    },\n    minSelectedCount: {\n      key: 'validate.minSelectedCount',\n      message: function message(component, setting) {\n        return component.component.minSelectedCountMessage ? component.component.minSelectedCountMessage : component.t(component.errorMessage('minSelectedCount'), {\n          minCount: parseFloat(setting),\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var min = parseFloat(setting);\n\n        if (!min) {\n          return true;\n        }\n\n        var count = Object.keys(value).reduce(function (total, key) {\n          if (value[key]) {\n            total++;\n          }\n\n          return total;\n        }, 0);\n        return count >= min;\n      }\n    },\n    maxSelectedCount: {\n      key: 'validate.maxSelectedCount',\n      message: function message(component, setting) {\n        return component.component.maxSelectedCountMessage ? component.component.maxSelectedCountMessage : component.t(component.errorMessage('maxSelectedCount'), {\n          minCount: parseFloat(setting),\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var max = parseFloat(setting);\n\n        if (!max) {\n          return true;\n        }\n\n        var count = Object.keys(value).reduce(function (total, key) {\n          if (value[key]) {\n            total++;\n          }\n\n          return total;\n        }, 0);\n        return count <= max;\n      }\n    },\n    minLength: {\n      key: 'validate.minLength',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('minLength'), {\n          field: component.errorLabel,\n          length: setting - 1,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var minLength = parseInt(setting, 10);\n\n        if (!minLength || typeof value !== 'string') {\n          return true;\n        }\n\n        return value.length >= minLength;\n      }\n    },\n    maxLength: {\n      key: 'validate.maxLength',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('maxLength'), {\n          field: component.errorLabel,\n          length: setting + 1,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var maxLength = parseInt(setting, 10);\n\n        if (!maxLength || typeof value !== 'string') {\n          return true;\n        }\n\n        return value.length <= maxLength;\n      }\n    },\n    maxWords: {\n      key: 'validate.maxWords',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('maxWords'), {\n          field: component.errorLabel,\n          length: setting + 1,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var maxWords = parseInt(setting, 10);\n\n        if (!maxWords || typeof value !== 'string') {\n          return true;\n        }\n\n        return value.trim().split(/\\s+/).length <= maxWords;\n      }\n    },\n    minWords: {\n      key: 'validate.minWords',\n      message: function message(component, setting) {\n        return component.t(component.errorMessage('minWords'), {\n          field: component.errorLabel,\n          length: setting - 1,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var minWords = parseInt(setting, 10);\n\n        if (!minWords || typeof value !== 'string') {\n          return true;\n        }\n\n        return value.trim().split(/\\s+/).length >= minWords;\n      }\n    },\n    email: {\n      message: function message(component) {\n        return component.t(component.errorMessage('invalid_email'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        /* eslint-disable max-len */\n        // From http://stackoverflow.com/questions/46155/validate-email-address-in-javascript\n        var re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n        /* eslint-enable max-len */\n        // Allow emails to be valid if the component is pristine and no value is provided.\n\n        return !value || re.test(value);\n      }\n    },\n    url: {\n      message: function message(component) {\n        return component.t(component.errorMessage('invalid_url'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        /* eslint-disable max-len */\n        // From https://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url\n        var re = /[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/;\n        /* eslint-enable max-len */\n        // Allow urls to be valid if the component is pristine and no value is provided.\n\n        return !value || re.test(value);\n      }\n    },\n    date: {\n      message: function message(component) {\n        return component.t(component.errorMessage('invalid_date'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        return value !== 'Invalid date';\n      }\n    },\n    day: {\n      message: function message(component) {\n        return component.t(component.errorMessage('invalid_day'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        if (!value) {\n          return true;\n        }\n\n        var _ref = component.dayFirst ? [0, 1, 2] : [1, 0, 2],\n            _ref2 = _slicedToArray(_ref, 3),\n            DAY = _ref2[0],\n            MONTH = _ref2[1],\n            YEAR = _ref2[2];\n\n        var values = value.split('/').map(function (x) {\n          return parseInt(x, 10);\n        }),\n            day = values[DAY],\n            month = values[MONTH],\n            year = values[YEAR],\n            maxDay = getDaysInMonthCount(month, year);\n\n        if (day < 0 || day > maxDay) {\n          return false;\n        }\n\n        if (month < 0 || month > 12) {\n          return false;\n        }\n\n        if (year < 0 || year > 9999) {\n          return false;\n        }\n\n        return true;\n\n        function isLeapYear(year) {\n          // Year is leap if it is evenly divisible by 400 or evenly divisible by 4 and not evenly divisible by 100.\n          return !(year % 400) || !!(year % 100) && !(year % 4);\n        }\n\n        function getDaysInMonthCount(month, year) {\n          switch (month) {\n            case 1: // January\n\n            case 3: // March\n\n            case 5: // May\n\n            case 7: // July\n\n            case 8: // August\n\n            case 10: // October\n\n            case 12:\n              // December\n              return 31;\n\n            case 4: // April\n\n            case 6: // June\n\n            case 9: // September\n\n            case 11:\n              // November\n              return 30;\n\n            case 2:\n              // February\n              return isLeapYear(year) ? 29 : 28;\n\n            default:\n              return 31;\n          }\n        }\n      }\n    },\n    pattern: {\n      key: 'validate.pattern',\n      message: function message(component, setting) {\n        return component.t(_lodash.default.get(component, 'component.validate.patternMessage', component.errorMessage('pattern'), {\n          field: component.errorLabel,\n          pattern: setting,\n          data: component.data\n        }));\n      },\n      check: function check(component, setting, value) {\n        var pattern = setting;\n\n        if (!pattern) {\n          return true;\n        }\n\n        var regex = new RegExp(\"^\".concat(pattern, \"$\"));\n        return regex.test(value);\n      }\n    },\n    json: {\n      key: 'validate.json',\n      check: function check(component, setting, value, data) {\n        if (!setting) {\n          return true;\n        }\n\n        var valid = component.evaluate(setting, {\n          data: data,\n          input: value\n        });\n\n        if (valid === null) {\n          return true;\n        }\n\n        return valid;\n      }\n    },\n    mask: {\n      message: function message(component) {\n        return component.t(component.errorMessage('mask'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value) {\n        var inputMask;\n\n        if (component.isMultipleMasksField) {\n          var maskName = value ? value.maskName : undefined;\n          var formioInputMask = component.getMaskByName(maskName);\n\n          if (formioInputMask) {\n            inputMask = (0, _utils.getInputMask)(formioInputMask);\n          }\n\n          value = value ? value.value : value;\n        } else {\n          inputMask = component._inputMask;\n        }\n\n        if (value && inputMask) {\n          return (0, _utils.matchInputMask)(value, inputMask);\n        }\n\n        return true;\n      }\n    },\n    custom: {\n      key: 'validate.custom',\n      message: function message(component) {\n        return component.t(component.errorMessage('custom'), {\n          field: component.errorLabel,\n          data: component.data\n        });\n      },\n      check: function check(component, setting, value, data) {\n        if (!setting) {\n          return true;\n        }\n\n        var valid = component.evaluate(setting, {\n          valid: true,\n          data: data,\n          input: value\n        }, 'valid', true);\n\n        if (valid === null) {\n          return true;\n        }\n\n        return valid;\n      }\n    },\n    maxDate: {\n      key: 'maxDate',\n      message: function message(component, setting) {\n        var date = (0, _utils.getDateSetting)(setting);\n        return component.t(component.errorMessage('maxDate'), {\n          field: component.errorLabel,\n          maxDate: (0, _moment.default)(date).format(component.format)\n        });\n      },\n      check: function check(component, setting, value) {\n        //if any parts of day are missing, skip maxDate validation\n        if (component.isPartialDay && component.isPartialDay(value)) {\n          return true;\n        }\n\n        var date = (0, _moment.default)(value);\n        var maxDate = (0, _utils.getDateSetting)(setting);\n\n        if (_lodash.default.isNull(maxDate)) {\n          return true;\n        } else {\n          maxDate.setHours(0, 0, 0, 0);\n        }\n\n        return date.isBefore(maxDate) || date.isSame(maxDate);\n      }\n    },\n    minDate: {\n      key: 'minDate',\n      message: function message(component, setting) {\n        var date = (0, _utils.getDateSetting)(setting);\n        return component.t(component.errorMessage('minDate'), {\n          field: component.errorLabel,\n          minDate: (0, _moment.default)(date).format(component.format)\n        });\n      },\n      check: function check(component, setting, value) {\n        //if any parts of day are missing, skip minDate validation\n        if (component.isPartialDay && component.isPartialDay(value)) {\n          return true;\n        }\n\n        var date = (0, _moment.default)(value);\n        var minDate = (0, _utils.getDateSetting)(setting);\n\n        if (_lodash.default.isNull(minDate)) {\n          return true;\n        } else {\n          minDate.setHours(0, 0, 0, 0);\n        }\n\n        return date.isAfter(minDate) || date.isSame(minDate);\n      }\n    },\n    calendar: {\n      key: 'validate.calendar',\n      messageText: '',\n      message: function message(component) {\n        return component.t(component.errorMessage(this.validators.calendar.messageText), {\n          field: component.errorLabel,\n          maxDate: (0, _moment.default)(component.dataValue).format(component.format)\n        });\n      },\n      check: function check(component, setting, value) {\n        this.validators.calendar.messageText = '';\n        var _component$_widget = component._widget,\n            settings = _component$_widget.settings,\n            enteredDate = _component$_widget.enteredDate;\n        var minDate = settings.minDate,\n            maxDate = settings.maxDate,\n            format = settings.format;\n        var momentFormat = [(0, _utils.convertFormatToMoment)(format)];\n\n        if (momentFormat[0].match(/M{3,}/g)) {\n          momentFormat.push(momentFormat[0].replace(/M{3,}/g, 'MM'));\n        }\n\n        if (!value && enteredDate) {\n          var _checkInvalidDate = (0, _calendarUtils.checkInvalidDate)(enteredDate, momentFormat, minDate, maxDate),\n              message = _checkInvalidDate.message,\n              result = _checkInvalidDate.result;\n\n          if (!result) {\n            this.validators.calendar.messageText = message;\n            return result;\n          }\n        }\n\n        if (value && enteredDate) {\n          if ((0, _moment.default)(value).format() !== (0, _moment.default)(enteredDate, momentFormat, true).format() && enteredDate.match(/_/gi)) {\n            this.validators.calendar.messageText = _calendarUtils.CALENDAR_ERROR_MESSAGES.INCOMPLETE;\n            return false;\n          } else {\n            component._widget.enteredDate = '';\n            return true;\n          }\n        }\n      }\n    }\n  }\n};\nexports.default = _default;",null]}