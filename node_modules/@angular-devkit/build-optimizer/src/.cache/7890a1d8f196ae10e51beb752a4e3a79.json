{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/choices.js/public/assets/scripts/choices.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/choices.js/public/assets/scripts/choices.js","mtime":1584368630939},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["(function webpackUniversalModuleDefinition(root, factory) {\n\t//CommonJS2\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\t//AMD\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\t//CommonJS\n\telse if(typeof exports === 'object')\n\t\texports[\"Choices\"] = factory();\n\t//Window\n\telse\n\t\troot[\"Choices\"] = factory();\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/public/assets/scripts/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diff = exports.cloneObject = exports.existsInArray = exports.isIE11 = exports.fetchFromObject = exports.getWindowHeight = exports.dispatchEvent = exports.sortByScore = exports.sortByAlpha = exports.calcWidthOfInput = exports.strToEl = exports.sanitise = exports.isScrolledIntoView = exports.getAdjacentEl = exports.findAncestorByAttrName = exports.wrap = exports.isElement = exports.isType = exports.getType = exports.generateId = exports.generateChars = exports.getRandomNumber = void 0;\n\nvar _this = void 0;\n\nvar getRandomNumber = function getRandomNumber(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexports.getRandomNumber = getRandomNumber;\n\nvar generateChars = function generateChars(length) {\n  var chars = '';\n\n  for (var i = 0; i < length; i++) {\n    var randomChar = getRandomNumber(0, 36);\n    chars += randomChar.toString(36);\n  }\n\n  return chars;\n};\n\nexports.generateChars = generateChars;\n\nvar generateId = function generateId(element, prefix) {\n  var id = element.id || element.name && \"\".concat(element.name, \"-\").concat(generateChars(2)) || generateChars(4);\n  id = id.replace(/(:|\\.|\\[|\\]|,)/g, '');\n  id = \"\".concat(prefix, \"-\").concat(id);\n  return id;\n};\n\nexports.generateId = generateId;\n\nvar getType = function getType(obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1);\n};\n\nexports.getType = getType;\n\nvar isType = function isType(type, obj) {\n  return obj !== undefined && obj !== null && getType(obj) === type;\n};\n\nexports.isType = isType;\n\nvar isElement = function isElement(element) {\n  return element instanceof Element;\n};\n\nexports.isElement = isElement;\n\nvar wrap = function wrap(element) {\n  var wrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.createElement('div');\n\n  if (element.nextSibling) {\n    element.parentNode.insertBefore(wrapper, element.nextSibling);\n  } else {\n    element.parentNode.appendChild(wrapper);\n  }\n\n  return wrapper.appendChild(element);\n};\n\nexports.wrap = wrap;\n\nvar findAncestorByAttrName = function findAncestorByAttrName(el, attr) {\n  var target = el;\n\n  while (target) {\n    if (target.hasAttribute(attr)) {\n      return target;\n    }\n\n    target = target.parentElement;\n  }\n\n  return null;\n};\n\nexports.findAncestorByAttrName = findAncestorByAttrName;\n\nvar getAdjacentEl = function getAdjacentEl(startEl, className) {\n  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (!startEl || !className) {\n    return;\n  }\n\n  var parent = startEl.parentNode.parentNode;\n  var children = Array.from(parent.querySelectorAll(className));\n  var startPos = children.indexOf(startEl);\n  var operatorDirection = direction > 0 ? 1 : -1;\n  return children[startPos + operatorDirection];\n};\n\nexports.getAdjacentEl = getAdjacentEl;\n\nvar isScrolledIntoView = function isScrolledIntoView(el, parent) {\n  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (!el) {\n    return;\n  }\n\n  var isVisible;\n\n  if (direction > 0) {\n    // In view from bottom\n    isVisible = parent.scrollTop + parent.offsetHeight >= el.offsetTop + el.offsetHeight;\n  } else {\n    // In view from top\n    isVisible = el.offsetTop >= parent.scrollTop;\n  }\n\n  return isVisible;\n};\n\nexports.isScrolledIntoView = isScrolledIntoView;\n\nvar sanitise = function sanitise(value) {\n  if (!isType('String', value)) {\n    return value;\n  }\n\n  return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/\"/g, '&quot;');\n};\n\nexports.sanitise = sanitise;\n\nvar strToEl = function () {\n  var tmpEl = document.createElement('div');\n  return function (str) {\n    var cleanedInput = str.trim();\n    tmpEl.innerHTML = cleanedInput;\n    var firldChild = tmpEl.children[0];\n\n    while (tmpEl.firstChild) {\n      tmpEl.removeChild(tmpEl.firstChild);\n    }\n\n    return firldChild;\n  };\n}();\n/**\n * Determines the width of a passed input based on its value and passes\n * it to the supplied callback function.\n */\n\n\nexports.strToEl = strToEl;\n\nvar calcWidthOfInput = function calcWidthOfInput(input, callback) {\n  var value = input.value || input.placeholder;\n  var width = input.offsetWidth;\n\n  if (value) {\n    var testEl = strToEl(\"<span>\".concat(sanitise(value), \"</span>\"));\n    testEl.style.position = 'absolute';\n    testEl.style.padding = '0';\n    testEl.style.top = '-9999px';\n    testEl.style.left = '-9999px';\n    testEl.style.width = 'auto';\n    testEl.style.whiteSpace = 'pre';\n\n    if (document.body.contains(input) && window.getComputedStyle) {\n      var inputStyle = window.getComputedStyle(input);\n\n      if (inputStyle) {\n        testEl.style.fontSize = inputStyle.fontSize;\n        testEl.style.fontFamily = inputStyle.fontFamily;\n        testEl.style.fontWeight = inputStyle.fontWeight;\n        testEl.style.fontStyle = inputStyle.fontStyle;\n        testEl.style.letterSpacing = inputStyle.letterSpacing;\n        testEl.style.textTransform = inputStyle.textTransform;\n        testEl.style.paddingLeft = inputStyle.paddingLeft;\n        testEl.style.paddingRight = inputStyle.paddingRight;\n      }\n    }\n\n    document.body.appendChild(testEl);\n    requestAnimationFrame(function () {\n      if (value && testEl.offsetWidth !== input.offsetWidth) {\n        width = testEl.offsetWidth + 4;\n      }\n\n      document.body.removeChild(testEl);\n      callback.call(_this, \"\".concat(width, \"px\"));\n    });\n  } else {\n    callback.call(_this, \"\".concat(width, \"px\"));\n  }\n};\n\nexports.calcWidthOfInput = calcWidthOfInput;\n\nvar sortByAlpha = function sortByAlpha(a, b) {\n  var labelA = \"\".concat(a.label || a.value).toLowerCase();\n  var labelB = \"\".concat(b.label || b.value).toLowerCase();\n\n  if (labelA < labelB) {\n    return -1;\n  }\n\n  if (labelA > labelB) {\n    return 1;\n  }\n\n  return 0;\n};\n\nexports.sortByAlpha = sortByAlpha;\n\nvar sortByScore = function sortByScore(a, b) {\n  return a.score - b.score;\n};\n\nexports.sortByScore = sortByScore;\n\nvar dispatchEvent = function dispatchEvent(element, type) {\n  var customArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var event = new CustomEvent(type, {\n    detail: customArgs,\n    bubbles: true,\n    cancelable: true\n  });\n  return element.dispatchEvent(event);\n};\n\nexports.dispatchEvent = dispatchEvent;\n\nvar getWindowHeight = function getWindowHeight() {\n  var _document = document,\n      body = _document.body;\n  var html = document.documentElement;\n  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n};\n\nexports.getWindowHeight = getWindowHeight;\n\nvar fetchFromObject = function fetchFromObject(object, path) {\n  var index = path.indexOf('.');\n\n  if (index > -1) {\n    return fetchFromObject(object[path.substring(0, index)], path.substr(index + 1));\n  }\n\n  return object[path];\n};\n\nexports.fetchFromObject = fetchFromObject;\n\nvar isIE11 = function isIE11() {\n  return !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));\n};\n\nexports.isIE11 = isIE11;\n\nvar existsInArray = function existsInArray(array, value) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';\n  return array.some(function (item) {\n    if (isType('String', value)) {\n      return item[key] === value.trim();\n    }\n\n    return item[key] === value;\n  });\n};\n\nexports.existsInArray = existsInArray;\n\nvar cloneObject = function cloneObject(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nexports.cloneObject = cloneObject;\n\nvar diff = function diff(a, b) {\n  var aKeys = Object.keys(a).sort();\n  var bKeys = Object.keys(b).sort();\n  return aKeys.filter(function (i) {\n    return bKeys.indexOf(i) < 0;\n  });\n};\n\nexports.diff = diff;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SCROLLING_SPEED = exports.KEY_CODES = exports.ACTION_TYPES = exports.EVENTS = exports.DEFAULT_CONFIG = exports.DEFAULT_CLASSNAMES = void 0;\n\nvar _utils = __webpack_require__(0);\n\nvar DEFAULT_CLASSNAMES = {\n  containerOuter: 'choices',\n  containerInner: 'choices__inner',\n  input: 'choices__input',\n  inputCloned: 'choices__input--cloned',\n  list: 'choices__list',\n  listItems: 'choices__list--multiple',\n  listSingle: 'choices__list--single',\n  listDropdown: 'choices__list--dropdown',\n  item: 'choices__item',\n  itemSelectable: 'choices__item--selectable',\n  itemDisabled: 'choices__item--disabled',\n  itemChoice: 'choices__item--choice',\n  placeholder: 'choices__placeholder',\n  group: 'choices__group',\n  groupHeading: 'choices__heading',\n  button: 'choices__button',\n  activeState: 'is-active',\n  focusState: 'is-focused',\n  openState: 'is-open',\n  disabledState: 'is-disabled',\n  highlightedState: 'is-highlighted',\n  hiddenState: 'is-hidden',\n  flippedState: 'is-flipped',\n  loadingState: 'is-loading',\n  noResults: 'has-no-results',\n  noChoices: 'has-no-choices'\n};\nexports.DEFAULT_CLASSNAMES = DEFAULT_CLASSNAMES;\nvar DEFAULT_CONFIG = {\n  items: [],\n  choices: [],\n  silent: false,\n  renderChoiceLimit: -1,\n  maxItemCount: -1,\n  addItems: true,\n  addItemFilterFn: null,\n  removeItems: true,\n  removeItemButton: false,\n  editItems: false,\n  duplicateItemsAllowed: true,\n  delimiter: ',',\n  paste: true,\n  searchEnabled: true,\n  searchChoices: true,\n  searchFloor: 1,\n  searchResultLimit: 4,\n  searchFields: ['label', 'value'],\n  position: 'auto',\n  resetScrollPosition: true,\n  shouldSort: true,\n  shouldSortItems: false,\n  sortFn: _utils.sortByAlpha,\n  placeholder: true,\n  placeholderValue: null,\n  searchPlaceholderValue: null,\n  prependValue: null,\n  appendValue: null,\n  renderSelectedChoices: 'auto',\n  loadingText: 'Loading...',\n  noResultsText: 'No results found',\n  noChoicesText: 'No choices to choose from',\n  itemSelectText: 'Press to select',\n  uniqueItemText: 'Only unique values can be added',\n  customAddItemText: 'Only values matching specific conditions can be added',\n  addItemText: function addItemText(value) {\n    return \"Press Enter to add <b>\\\"\".concat((0, _utils.sanitise)(value), \"\\\"</b>\");\n  },\n  maxItemText: function maxItemText(maxItemCount) {\n    return \"Only \".concat(maxItemCount, \" values can be added\");\n  },\n  itemComparer: function itemComparer(choice, item) {\n    return choice === item;\n  },\n  fuseOptions: {\n    includeScore: true\n  },\n  callbackOnInit: null,\n  callbackOnCreateTemplates: null,\n  classNames: DEFAULT_CLASSNAMES\n};\nexports.DEFAULT_CONFIG = DEFAULT_CONFIG;\nvar EVENTS = {\n  showDropdown: 'showDropdown',\n  hideDropdown: 'hideDropdown',\n  change: 'change',\n  choice: 'choice',\n  search: 'search',\n  addItem: 'addItem',\n  removeItem: 'removeItem',\n  highlightItem: 'highlightItem',\n  highlightChoice: 'highlightChoice'\n};\nexports.EVENTS = EVENTS;\nvar ACTION_TYPES = {\n  ADD_CHOICE: 'ADD_CHOICE',\n  FILTER_CHOICES: 'FILTER_CHOICES',\n  ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',\n  CLEAR_CHOICES: 'CLEAR_CHOICES',\n  ADD_GROUP: 'ADD_GROUP',\n  ADD_ITEM: 'ADD_ITEM',\n  REMOVE_ITEM: 'REMOVE_ITEM',\n  HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',\n  CLEAR_ALL: 'CLEAR_ALL'\n};\nexports.ACTION_TYPES = ACTION_TYPES;\nvar KEY_CODES = {\n  BACK_KEY: 46,\n  DELETE_KEY: 8,\n  ENTER_KEY: 13,\n  A_KEY: 65,\n  ESC_KEY: 27,\n  UP_KEY: 38,\n  DOWN_KEY: 40,\n  PAGE_UP_KEY: 33,\n  PAGE_DOWN_KEY: 34\n};\nexports.KEY_CODES = KEY_CODES;\nvar SCROLLING_SPEED = 4;\nexports.SCROLLING_SPEED = SCROLLING_SPEED;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(root);\n/* harmony default export */ __webpack_exports__[\"a\"] = (result);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(14)(module)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WrappedElement =\n/*#__PURE__*/\nfunction () {\n  function WrappedElement(_ref) {\n    var element = _ref.element,\n        classNames = _ref.classNames;\n\n    _classCallCheck(this, WrappedElement);\n\n    Object.assign(this, {\n      element: element,\n      classNames: classNames\n    });\n\n    if (!(0, _utils.isElement)(element)) {\n      throw new TypeError('Invalid element passed');\n    }\n\n    this.isDisabled = false;\n  }\n\n  _createClass(WrappedElement, [{\n    key: \"conceal\",\n    value: function conceal() {\n      // Hide passed input\n      this.element.classList.add(this.classNames.input);\n      this.element.classList.add(this.classNames.hiddenState); // Remove element from tab index\n\n      this.element.tabIndex = '-1'; // Backup original styles if any\n\n      var origStyle = this.element.getAttribute('style');\n\n      if (origStyle) {\n        this.element.setAttribute('data-choice-orig-style', origStyle);\n      }\n\n      this.element.setAttribute('aria-hidden', 'true');\n      this.element.setAttribute('data-choice', 'active');\n    }\n  }, {\n    key: \"reveal\",\n    value: function reveal() {\n      // Reinstate passed element\n      this.element.classList.remove(this.classNames.input);\n      this.element.classList.remove(this.classNames.hiddenState);\n      this.element.removeAttribute('tabindex'); // Recover original styles if any\n\n      var origStyle = this.element.getAttribute('data-choice-orig-style');\n\n      if (origStyle) {\n        this.element.removeAttribute('data-choice-orig-style');\n        this.element.setAttribute('style', origStyle);\n      } else {\n        this.element.removeAttribute('style');\n      }\n\n      this.element.removeAttribute('aria-hidden');\n      this.element.removeAttribute('data-choice'); // Re-assign values - this is weird, I know\n\n      this.element.value = this.element.value;\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.element.removeAttribute('disabled');\n      this.element.disabled = false;\n      this.isDisabled = false;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.element.setAttribute('disabled', '');\n      this.element.disabled = true;\n      this.isDisabled = true;\n    }\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(eventType, data) {\n      (0, _utils.dispatchEvent)(this.element, eventType, data);\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.element.value;\n    }\n  }]);\n\n  return WrappedElement;\n}();\n\nexports.default = WrappedElement;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_freeGlobal.js\nvar _freeGlobal = __webpack_require__(7);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_root.js\n\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal[\"a\" /* default */] || freeSelf || Function('return this')();\n\n/* harmony default export */ var _root = (root);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_Symbol.js\n\n\n/** Built-in value references. */\nvar Symbol = _root.Symbol;\n\n/* harmony default export */ var _Symbol = (Symbol);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ var _getRawTag = (getRawTag);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js\n/** Used for built-in method references. */\nvar _objectToString_objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar _objectToString_nativeObjectToString = _objectToString_objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return _objectToString_nativeObjectToString.call(value);\n}\n\n/* harmony default export */ var _objectToString = (objectToString);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js\n\n\n\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\n/* harmony default export */ var _baseGetTag = (baseGetTag);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_overArg.js\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* harmony default export */ var _overArg = (overArg);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js\n\n\n/** Built-in value references. */\nvar getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n/* harmony default export */ var _getPrototype = (getPrototype);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/isObjectLike.js\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);\n\n// CONCATENATED MODULE: ./node_modules/lodash-es/isPlainObject.js\n\n\n\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    isPlainObject_objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);\n\n// EXTERNAL MODULE: ./node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/redux/es/createStore.js\n\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};function createStore_createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore_createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!lodash_es_isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[es[\"a\" /* default */]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[es[\"a\" /* default */]] = observable, _ref2;\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/utils/warning.js\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/combineReducers.js\n\n\n\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!lodash_es_isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (false) {}\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/bindActionCreators.js\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/compose.js\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/applyMiddleware.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n// CONCATENATED MODULE: ./node_modules/redux/es/index.js\n/* concated harmony reexport createStore */__webpack_require__.d(__webpack_exports__, \"createStore\", function() { return createStore_createStore; });\n/* concated harmony reexport combineReducers */__webpack_require__.d(__webpack_exports__, \"combineReducers\", function() { return combineReducers; });\n/* concated harmony reexport bindActionCreators */__webpack_require__.d(__webpack_exports__, \"bindActionCreators\", function() { return bindActionCreators; });\n/* concated harmony reexport applyMiddleware */__webpack_require__.d(__webpack_exports__, \"applyMiddleware\", function() { return applyMiddleware; });\n/* concated harmony reexport compose */__webpack_require__.d(__webpack_exports__, \"compose\", function() { return compose; });\n\n\n\n\n\n\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (false) {}\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (freeGlobal);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(9);\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _fuse = _interopRequireDefault(__webpack_require__(10));\n\nvar _deepmerge = _interopRequireDefault(__webpack_require__(11));\n\n__webpack_require__(12);\n\nvar _store = _interopRequireDefault(__webpack_require__(13));\n\nvar _components = __webpack_require__(20);\n\nvar _constants = __webpack_require__(1);\n\nvar _templates = __webpack_require__(27);\n\nvar _choices = __webpack_require__(29);\n\nvar _items = __webpack_require__(30);\n\nvar _groups = __webpack_require__(31);\n\nvar _misc = __webpack_require__(32);\n\nvar _general = __webpack_require__(33);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Choices\n * @author Josh Johnson<josh@joshuajohnson.co.uk>\n */\nvar Choices =\n/*#__PURE__*/\nfunction () {\n  function Choices() {\n    var _this = this;\n\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-choice]';\n    var userConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Choices);\n\n    if ((0, _utils.isType)('String', element)) {\n      var elements = Array.from(document.querySelectorAll(element)); // If there are multiple elements, create a new instance\n      // for each element besides the first one (as that already has an instance)\n\n      if (elements.length > 1) {\n        return this._generateInstances(elements, userConfig);\n      }\n    }\n\n    this.config = _deepmerge.default.all([_constants.DEFAULT_CONFIG, Choices.userDefaults, userConfig], // When merging array configs, replace with a copy of the userConfig array,\n    // instead of concatenating with the default array\n    {\n      arrayMerge: function arrayMerge(destinationArray, sourceArray) {\n        return [].concat(sourceArray);\n      }\n    });\n    var invalidConfigOptions = (0, _utils.diff)(this.config, _constants.DEFAULT_CONFIG);\n\n    if (invalidConfigOptions.length) {\n      console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));\n    }\n\n    if (!['auto', 'always'].includes(this.config.renderSelectedChoices)) {\n      this.config.renderSelectedChoices = 'auto';\n    } // Retrieve triggering element (i.e. element with 'data-choice' trigger)\n\n\n    var passedElement = (0, _utils.isType)('String', element) ? document.querySelector(element) : element;\n\n    if (!passedElement) {\n      if (!this.config.silent) {\n        console.error('Could not find passed element or passed element was of an invalid type');\n      }\n\n      return;\n    }\n\n    this._isTextElement = passedElement.type === 'text';\n    this._isSelectOneElement = passedElement.type === 'select-one';\n    this._isSelectMultipleElement = passedElement.type === 'select-multiple';\n    this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;\n\n    if (this._isTextElement) {\n      this.passedElement = new _components.WrappedInput({\n        element: passedElement,\n        classNames: this.config.classNames,\n        delimiter: this.config.delimiter\n      });\n    } else if (this._isSelectElement) {\n      this.passedElement = new _components.WrappedSelect({\n        element: passedElement,\n        classNames: this.config.classNames,\n        template: function template(data) {\n          return _this.config.templates.option(data);\n        }\n      });\n    }\n\n    if (!this.passedElement) {\n      return console.error('Passed element was of an invalid type');\n    }\n\n    this.initialised = false;\n    this._store = new _store.default(this.render);\n    this._initialState = {};\n    this._currentState = {};\n    this._prevState = {};\n    this._currentValue = '';\n    this._canSearch = this.config.searchEnabled;\n    this._isScrollingOnIe = false;\n    this._highlightPosition = 0;\n    this._wasTap = true;\n    this._placeholderValue = this._generatePlaceholderValue();\n    this._baseId = (0, _utils.generateId)(this.passedElement.element, 'choices-');\n    this._direction = this.passedElement.element.getAttribute('dir') || 'ltr';\n    this._idNames = {\n      itemChoice: 'item-choice'\n    }; // Assign preset choices from passed object\n\n    this._presetChoices = this.config.choices; // Assign preset items from passed object first\n\n    this._presetItems = this.config.items; // Then add any values passed from attribute\n\n    if (this.passedElement.value) {\n      this._presetItems = this._presetItems.concat(this.passedElement.value.split(this.config.delimiter));\n    }\n\n    this._render = this._render.bind(this);\n    this._onFocus = this._onFocus.bind(this);\n    this._onBlur = this._onBlur.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onClick = this._onClick.bind(this);\n    this._onTouchMove = this._onTouchMove.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n    this._onMouseDown = this._onMouseDown.bind(this);\n    this._onMouseOver = this._onMouseOver.bind(this);\n    this._onFormReset = this._onFormReset.bind(this);\n    this._onAKey = this._onAKey.bind(this);\n    this._onEnterKey = this._onEnterKey.bind(this);\n    this._onEscapeKey = this._onEscapeKey.bind(this);\n    this._onDirectionKey = this._onDirectionKey.bind(this);\n    this._onDeleteKey = this._onDeleteKey.bind(this);\n\n    if (!this.config.silent) {\n      if (this.config.shouldSortItems === true && this._isSelectOneElement) {\n        console.warn(\"shouldSortElements: Type of passed element is 'select-one', falling back to false.\");\n      } // If element has already been initialised with Choices, fail silently\n\n\n      if (this.passedElement.element.getAttribute('data-choice') === 'active') {\n        console.warn('Trying to initialise Choices on element already initialised');\n      }\n    } // Let's go\n\n\n    this.init();\n  }\n  /* ========================================\n  =            Public functions            =\n  ======================================== */\n\n\n  _createClass(Choices, [{\n    key: \"init\",\n    value: function init() {\n      if (this.initialised) {\n        return;\n      }\n\n      this._createTemplates();\n\n      this._createElements();\n\n      this._createStructure(); // Set initial state (We need to clone the state because some reducers\n      // modify the inner objects properties in the state) 🤢\n\n\n      this._initialState = (0, _utils.cloneObject)(this._store.state);\n\n      this._store.subscribe(this._render);\n\n      this._render();\n\n      this._addEventListeners();\n\n      var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');\n\n      if (shouldDisable) {\n        this.disable();\n      }\n\n      this.initialised = true;\n      var callbackOnInit = this.config.callbackOnInit; // Run callback if it is a function\n\n      if (callbackOnInit && (0, _utils.isType)('Function', callbackOnInit)) {\n        callbackOnInit.call(this);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (!this.initialised) {\n        return;\n      }\n\n      this._removeEventListeners();\n\n      this.passedElement.reveal();\n      this.containerOuter.unwrap(this.passedElement.element);\n\n      if (this._isSelectElement) {\n        this.passedElement.options = this._presetChoices;\n      }\n\n      this.clearStore();\n      this.config.templates = null;\n      this.initialised = false;\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      if (this.passedElement.isDisabled) {\n        this.passedElement.enable();\n      }\n\n      if (this.containerOuter.isDisabled) {\n        this._addEventListeners();\n\n        this.input.enable();\n        this.containerOuter.enable();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      if (!this.passedElement.isDisabled) {\n        this.passedElement.disable();\n      }\n\n      if (!this.containerOuter.isDisabled) {\n        this._removeEventListeners();\n\n        this.input.disable();\n        this.containerOuter.disable();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"highlightItem\",\n    value: function highlightItem(item) {\n      var runEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!item) {\n        return this;\n      }\n\n      var id = item.id,\n          _item$groupId = item.groupId,\n          groupId = _item$groupId === void 0 ? -1 : _item$groupId,\n          _item$value = item.value,\n          value = _item$value === void 0 ? '' : _item$value,\n          _item$label = item.label,\n          label = _item$label === void 0 ? '' : _item$label;\n      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n\n      this._store.dispatch((0, _items.highlightItem)(id, true));\n\n      if (runEvent) {\n        this.passedElement.triggerEvent(_constants.EVENTS.highlightItem, {\n          id: id,\n          value: value,\n          label: label,\n          groupValue: group && group.value ? group.value : null\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unhighlightItem\",\n    value: function unhighlightItem(item) {\n      if (!item) {\n        return this;\n      }\n\n      var id = item.id,\n          _item$groupId2 = item.groupId,\n          groupId = _item$groupId2 === void 0 ? -1 : _item$groupId2,\n          _item$value2 = item.value,\n          value = _item$value2 === void 0 ? '' : _item$value2,\n          _item$label2 = item.label,\n          label = _item$label2 === void 0 ? '' : _item$label2;\n      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n\n      this._store.dispatch((0, _items.highlightItem)(id, false));\n\n      this.passedElement.triggerEvent(_constants.EVENTS.highlightItem, {\n        id: id,\n        value: value,\n        label: label,\n        groupValue: group && group.value ? group.value : null\n      });\n      return this;\n    }\n  }, {\n    key: \"highlightAll\",\n    value: function highlightAll() {\n      var _this2 = this;\n\n      this._store.items.forEach(function (item) {\n        return _this2.highlightItem(item);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"unhighlightAll\",\n    value: function unhighlightAll() {\n      var _this3 = this;\n\n      this._store.items.forEach(function (item) {\n        return _this3.unhighlightItem(item);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"removeActiveItemsByValue\",\n    value: function removeActiveItemsByValue(value) {\n      var _this4 = this;\n\n      this._store.activeItems.filter(function (item) {\n        return item.value === value;\n      }).forEach(function (item) {\n        return _this4._removeItem(item);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"removeActiveItems\",\n    value: function removeActiveItems(excludedId) {\n      var _this5 = this;\n\n      this._store.activeItems.filter(function (_ref) {\n        var id = _ref.id;\n        return id !== excludedId;\n      }).forEach(function (item) {\n        return _this5._removeItem(item);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"removeHighlightedItems\",\n    value: function removeHighlightedItems() {\n      var _this6 = this;\n\n      var runEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._store.highlightedActiveItems.forEach(function (item) {\n        _this6._removeItem(item); // If this action was performed by the user\n        // trigger the event\n\n\n        if (runEvent) {\n          _this6._triggerChange(item.value);\n        }\n      });\n\n      return this;\n    }\n  }, {\n    key: \"showDropdown\",\n    value: function showDropdown(preventInputFocus) {\n      var _this7 = this;\n\n      if (this.dropdown.isActive) {\n        return this;\n      }\n\n      requestAnimationFrame(function () {\n        _this7.dropdown.show();\n\n        _this7.containerOuter.open(_this7.dropdown.distanceFromTopWindow());\n\n        if (!preventInputFocus && _this7._canSearch) {\n          _this7.input.focus();\n        }\n\n        _this7.passedElement.triggerEvent(_constants.EVENTS.showDropdown, {});\n      });\n      return this;\n    }\n  }, {\n    key: \"hideDropdown\",\n    value: function hideDropdown(preventInputBlur) {\n      var _this8 = this;\n\n      if (!this.dropdown.isActive) {\n        return this;\n      }\n\n      requestAnimationFrame(function () {\n        _this8.dropdown.hide();\n\n        _this8.containerOuter.close();\n\n        if (!preventInputBlur && _this8._canSearch) {\n          _this8.input.removeActiveDescendant();\n\n          _this8.input.blur();\n        }\n\n        _this8.passedElement.triggerEvent(_constants.EVENTS.hideDropdown, {});\n      });\n      return this;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      var valueOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var values = this._store.activeItems.reduce(function (selectedItems, item) {\n        var itemValue = valueOnly ? item.value : item;\n        selectedItems.push(itemValue);\n        return selectedItems;\n      }, []);\n\n      return this._isSelectOneElement ? values[0] : values;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(args) {\n      var _this9 = this;\n\n      if (!this.initialised) {\n        return this;\n      }\n\n      [].concat(args).forEach(function (value) {\n        return _this9._setChoiceOrItem(value);\n      });\n      return this;\n    }\n  }, {\n    key: \"setChoiceByValue\",\n    value: function setChoiceByValue(value) {\n      var _this10 = this;\n\n      if (!this.initialised || this._isTextElement) {\n        return this;\n      } // If only one value has been passed, convert to array\n\n\n      var choiceValue = (0, _utils.isType)('Array', value) ? value : [value]; // Loop through each value and\n\n      choiceValue.forEach(function (val) {\n        return _this10._findAndSelectChoiceByValue(val);\n      });\n      return this;\n    }\n  }, {\n    key: \"setChoices\",\n    value: function setChoices() {\n      var _this11 = this;\n\n      var choices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var replaceChoices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!this._isSelectElement || !value) {\n        return this;\n      } // Clear choices if needed\n\n\n      if (replaceChoices) {\n        this.clearChoices();\n      }\n\n      this.containerOuter.removeLoadingState();\n\n      var addGroupsAndChoices = function addGroupsAndChoices(groupOrChoice) {\n        if (groupOrChoice.choices) {\n          _this11._addGroup({\n            group: groupOrChoice,\n            id: groupOrChoice.id || null,\n            valueKey: value,\n            labelKey: label\n          });\n        } else {\n          _this11._addChoice({\n            value: groupOrChoice[value],\n            label: groupOrChoice[label],\n            isSelected: groupOrChoice.selected,\n            isDisabled: groupOrChoice.disabled,\n            customProperties: groupOrChoice.customProperties,\n            placeholder: groupOrChoice.placeholder\n          });\n        }\n      };\n\n      this._setLoading(true);\n\n      choices.forEach(addGroupsAndChoices);\n\n      this._setLoading(false);\n\n      return this;\n    }\n  }, {\n    key: \"clearChoices\",\n    value: function clearChoices() {\n      this._store.dispatch((0, _choices.clearChoices)());\n    }\n  }, {\n    key: \"clearStore\",\n    value: function clearStore() {\n      this._store.dispatch((0, _misc.clearAll)());\n\n      return this;\n    }\n  }, {\n    key: \"clearInput\",\n    value: function clearInput() {\n      var shouldSetInputWidth = !this._isSelectOneElement;\n      this.input.clear(shouldSetInputWidth);\n\n      if (!this._isTextElement && this._canSearch) {\n        this._isSearching = false;\n\n        this._store.dispatch((0, _choices.activateChoices)(true));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"ajax\",\n    value: function ajax(fn) {\n      var _this12 = this;\n\n      if (!this.initialised || !this._isSelectElement || !fn) {\n        return this;\n      }\n\n      requestAnimationFrame(function () {\n        return _this12._handleLoadingState(true);\n      });\n      fn(this._ajaxCallback());\n      return this;\n    }\n    /* =====  End of Public functions  ====== */\n\n    /* =============================================\n    =                Private functions            =\n    ============================================= */\n\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      if (this._store.isLoading()) {\n        return;\n      }\n\n      this._currentState = this._store.state;\n      var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;\n      var shouldRenderChoices = this._isSelectElement;\n      var shouldRenderItems = this._currentState.items !== this._prevState.items;\n\n      if (!stateChanged) {\n        return;\n      }\n\n      if (shouldRenderChoices) {\n        this._renderChoices();\n      }\n\n      if (shouldRenderItems) {\n        this._renderItems();\n      }\n\n      this._prevState = this._currentState;\n    }\n  }, {\n    key: \"_renderChoices\",\n    value: function _renderChoices() {\n      var _this13 = this;\n\n      var _this$_store = this._store,\n          activeGroups = _this$_store.activeGroups,\n          activeChoices = _this$_store.activeChoices;\n      var choiceListFragment = document.createDocumentFragment();\n      this.choiceList.clear();\n\n      if (this.config.resetScrollPosition) {\n        requestAnimationFrame(function () {\n          return _this13.choiceList.scrollToTop();\n        });\n      } // If we have grouped options\n\n\n      if (activeGroups.length >= 1 && !this._isSearching) {\n        // If we have a placeholder choice along with groups\n        var activePlaceholders = activeChoices.filter(function (activeChoice) {\n          return activeChoice.placeholder === true && activeChoice.groupId === -1;\n        });\n\n        if (activePlaceholders.length >= 1) {\n          choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);\n        }\n\n        choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);\n      } else if (activeChoices.length >= 1) {\n        choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);\n      } // If we have choices to show\n\n\n      if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {\n        var activeItems = this._store.activeItems;\n\n        var canAddItem = this._canAddItem(activeItems, this.input.value); // ...and we can select them\n\n\n        if (canAddItem.response) {\n          // ...append them and highlight the first choice\n          this.choiceList.append(choiceListFragment);\n\n          this._highlightChoice();\n        } else {\n          // ...otherwise show a notice\n          this.choiceList.append(this._getTemplate('notice', canAddItem.notice));\n        }\n      } else {\n        // Otherwise show a notice\n        var dropdownItem;\n        var notice;\n\n        if (this._isSearching) {\n          notice = (0, _utils.isType)('Function', this.config.noResultsText) ? this.config.noResultsText() : this.config.noResultsText;\n          dropdownItem = this._getTemplate('notice', notice, 'no-results');\n        } else {\n          notice = (0, _utils.isType)('Function', this.config.noChoicesText) ? this.config.noChoicesText() : this.config.noChoicesText;\n          dropdownItem = this._getTemplate('notice', notice, 'no-choices');\n        }\n\n        this.choiceList.append(dropdownItem);\n      }\n    }\n  }, {\n    key: \"_renderItems\",\n    value: function _renderItems() {\n      var activeItems = this._store.activeItems || [];\n      this.itemList.clear(); // Create a fragment to store our list items\n      // (so we don't have to update the DOM for each item)\n\n      var itemListFragment = this._createItemsFragment(activeItems); // If we have items to add, append them\n\n\n      if (itemListFragment.childNodes) {\n        this.itemList.append(itemListFragment);\n      }\n    }\n  }, {\n    key: \"_createGroupsFragment\",\n    value: function _createGroupsFragment(groups, choices, fragment) {\n      var _this14 = this;\n\n      var groupFragment = fragment || document.createDocumentFragment();\n\n      var getGroupChoices = function getGroupChoices(group) {\n        return choices.filter(function (choice) {\n          if (_this14._isSelectOneElement) {\n            return choice.groupId === group.id;\n          }\n\n          return choice.groupId === group.id && (_this14.config.renderSelectedChoices === 'always' || !choice.selected);\n        });\n      }; // If sorting is enabled, filter groups\n\n\n      if (this.config.shouldSort) {\n        groups.sort(this.config.sortFn);\n      }\n\n      groups.forEach(function (group) {\n        var groupChoices = getGroupChoices(group);\n\n        if (groupChoices.length >= 1) {\n          var dropdownGroup = _this14._getTemplate('choiceGroup', group);\n\n          groupFragment.appendChild(dropdownGroup);\n\n          _this14._createChoicesFragment(groupChoices, groupFragment, true);\n        }\n      });\n      return groupFragment;\n    }\n  }, {\n    key: \"_createChoicesFragment\",\n    value: function _createChoicesFragment(choices, fragment) {\n      var _this15 = this;\n\n      var withinGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // Create a fragment to store our list items (so we don't have to update the DOM for each item)\n      var choicesFragment = fragment || document.createDocumentFragment();\n      var _this$config = this.config,\n          renderSelectedChoices = _this$config.renderSelectedChoices,\n          searchResultLimit = _this$config.searchResultLimit,\n          renderChoiceLimit = _this$config.renderChoiceLimit;\n      var filter = this._isSearching ? _utils.sortByScore : this.config.sortFn;\n\n      var appendChoice = function appendChoice(choice) {\n        var shouldRender = renderSelectedChoices === 'auto' ? _this15._isSelectOneElement || !choice.selected : true;\n\n        if (shouldRender) {\n          var dropdownItem = _this15._getTemplate('choice', choice, _this15.config.itemSelectText);\n\n          choicesFragment.appendChild(dropdownItem);\n        }\n      };\n\n      var rendererableChoices = choices;\n\n      if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {\n        rendererableChoices = choices.filter(function (choice) {\n          return !choice.selected;\n        });\n      } // Split array into placeholders and \"normal\" choices\n\n\n      var _rendererableChoices$ = rendererableChoices.reduce(function (acc, choice) {\n        if (choice.placeholder) {\n          acc.placeholderChoices.push(choice);\n        } else {\n          acc.normalChoices.push(choice);\n        }\n\n        return acc;\n      }, {\n        placeholderChoices: [],\n        normalChoices: []\n      }),\n          placeholderChoices = _rendererableChoices$.placeholderChoices,\n          normalChoices = _rendererableChoices$.normalChoices; // If sorting is enabled or the user is searching, filter choices\n\n\n      if (this.config.shouldSort || this._isSearching) {\n        normalChoices.sort(filter);\n      }\n\n      var choiceLimit = rendererableChoices.length; // Prepend placeholeder\n\n      var sortedChoices = [].concat(placeholderChoices, normalChoices);\n\n      if (this._isSearching) {\n        choiceLimit = searchResultLimit;\n      } else if (renderChoiceLimit > 0 && !withinGroup) {\n        choiceLimit = renderChoiceLimit;\n      } // Add each choice to dropdown within range\n\n\n      for (var i = 0; i < choiceLimit; i += 1) {\n        if (sortedChoices[i]) {\n          appendChoice(sortedChoices[i]);\n        }\n      }\n\n      return choicesFragment;\n    }\n  }, {\n    key: \"_createItemsFragment\",\n    value: function _createItemsFragment(items) {\n      var _this16 = this;\n\n      var fragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      // Create fragment to add elements to\n      var _this$config2 = this.config,\n          shouldSortItems = _this$config2.shouldSortItems,\n          sortFn = _this$config2.sortFn,\n          removeItemButton = _this$config2.removeItemButton;\n      var itemListFragment = fragment || document.createDocumentFragment(); // If sorting is enabled, filter items\n\n      if (shouldSortItems && !this._isSelectOneElement) {\n        items.sort(sortFn);\n      }\n\n      if (this._isTextElement) {\n        // Update the value of the hidden input\n        this.passedElement.value = items;\n      } else {\n        // Update the options of the hidden input\n        this.passedElement.options = items;\n      }\n\n      var addItemToFragment = function addItemToFragment(item) {\n        // Create new list element\n        var listItem = _this16._getTemplate('item', item, removeItemButton); // Append it to list\n\n\n        itemListFragment.appendChild(listItem);\n      }; // Add each list item to list\n\n\n      items.forEach(function (item) {\n        return addItemToFragment(item);\n      });\n      return itemListFragment;\n    }\n  }, {\n    key: \"_triggerChange\",\n    value: function _triggerChange(value) {\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      this.passedElement.triggerEvent(_constants.EVENTS.change, {\n        value: value\n      });\n    }\n  }, {\n    key: \"_selectPlaceholderChoice\",\n    value: function _selectPlaceholderChoice() {\n      var placeholderChoice = this._store.placeholderChoice;\n\n      if (placeholderChoice) {\n        this._addItem({\n          value: placeholderChoice.value,\n          label: placeholderChoice.label,\n          choiceId: placeholderChoice.id,\n          groupId: placeholderChoice.groupId,\n          placeholder: placeholderChoice.placeholder\n        });\n\n        this._triggerChange(placeholderChoice.value);\n      }\n    }\n  }, {\n    key: \"_handleButtonAction\",\n    value: function _handleButtonAction(activeItems, element) {\n      if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {\n        return;\n      }\n\n      var itemId = element.parentNode.getAttribute('data-id');\n      var itemToRemove = activeItems.find(function (item) {\n        return item.id === parseInt(itemId, 10);\n      }); // Remove item associated with button\n\n      this._removeItem(itemToRemove);\n\n      this._triggerChange(itemToRemove.value);\n\n      if (this._isSelectOneElement) {\n        this._selectPlaceholderChoice();\n      }\n    }\n  }, {\n    key: \"_handleItemAction\",\n    value: function _handleItemAction(activeItems, element) {\n      var _this17 = this;\n\n      var hasShiftKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {\n        return;\n      }\n\n      var passedId = element.getAttribute('data-id'); // We only want to select one item with a click\n      // so we deselect any items that aren't the target\n      // unless shift is being pressed\n\n      activeItems.forEach(function (item) {\n        if (item.id === parseInt(passedId, 10) && !item.highlighted) {\n          _this17.highlightItem(item);\n        } else if (!hasShiftKey && item.highlighted) {\n          _this17.unhighlightItem(item);\n        }\n      }); // Focus input as without focus, a user cannot do anything with a\n      // highlighted item\n\n      this.input.focus();\n    }\n  }, {\n    key: \"_handleChoiceAction\",\n    value: function _handleChoiceAction(activeItems, element) {\n      if (!activeItems || !element) {\n        return;\n      } // If we are clicking on an option\n\n\n      var id = element.getAttribute('data-id');\n\n      var choice = this._store.getChoiceById(id);\n\n      var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;\n      var hasActiveDropdown = this.dropdown.isActive; // Update choice keyCode\n\n      choice.keyCode = passedKeyCode;\n      this.passedElement.triggerEvent(_constants.EVENTS.choice, {\n        choice: choice\n      });\n\n      if (choice && !choice.selected && !choice.disabled) {\n        var canAddItem = this._canAddItem(activeItems, choice.value);\n\n        if (canAddItem.response) {\n          this._addItem({\n            value: choice.value,\n            label: choice.label,\n            choiceId: choice.id,\n            groupId: choice.groupId,\n            customProperties: choice.customProperties,\n            placeholder: choice.placeholder,\n            keyCode: choice.keyCode\n          });\n\n          this._triggerChange(choice.value);\n        }\n      }\n\n      this.clearInput(); // We wont to close the dropdown if we are dealing with a single select box\n\n      if (hasActiveDropdown && this._isSelectOneElement) {\n        this.hideDropdown(true);\n        this.containerOuter.focus();\n      }\n    }\n  }, {\n    key: \"_handleBackspace\",\n    value: function _handleBackspace(activeItems) {\n      if (!this.config.removeItems || !activeItems) {\n        return;\n      }\n\n      var lastItem = activeItems[activeItems.length - 1];\n      var hasHighlightedItems = activeItems.some(function (item) {\n        return item.highlighted;\n      }); // If editing the last item is allowed and there are not other selected items,\n      // we can edit the item value. Otherwise if we can remove items, remove all selected items\n\n      if (this.config.editItems && !hasHighlightedItems && lastItem) {\n        this.input.value = lastItem.value;\n        this.input.setWidth();\n\n        this._removeItem(lastItem);\n\n        this._triggerChange(lastItem.value);\n      } else {\n        if (!hasHighlightedItems) {\n          // Highlight last item if none already highlighted\n          this.highlightItem(lastItem, false);\n        }\n\n        this.removeHighlightedItems(true);\n      }\n    }\n  }, {\n    key: \"_setLoading\",\n    value: function _setLoading(isLoading) {\n      this._store.dispatch((0, _general.setIsLoading)(isLoading));\n    }\n  }, {\n    key: \"_handleLoadingState\",\n    value: function _handleLoadingState() {\n      var setLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var placeholderItem = this.itemList.getChild(\".\".concat(this.config.classNames.placeholder));\n\n      if (setLoading) {\n        this.disable();\n        this.containerOuter.addLoadingState();\n\n        if (this._isSelectOneElement) {\n          if (!placeholderItem) {\n            placeholderItem = this._getTemplate('placeholder', this.config.loadingText);\n            this.itemList.append(placeholderItem);\n          } else {\n            placeholderItem.innerHTML = this.config.loadingText;\n          }\n        } else {\n          this.input.placeholder = this.config.loadingText;\n        }\n      } else {\n        this.enable();\n        this.containerOuter.removeLoadingState();\n\n        if (this._isSelectOneElement) {\n          placeholderItem.innerHTML = this._placeholderValue || '';\n        } else {\n          this.input.placeholder = this._placeholderValue || '';\n        }\n      }\n    }\n  }, {\n    key: \"_handleSearch\",\n    value: function _handleSearch(value) {\n      if (!value || !this.input.isFocussed) {\n        return;\n      }\n\n      var choices = this._store.choices;\n      var _this$config3 = this.config,\n          searchFloor = _this$config3.searchFloor,\n          searchChoices = _this$config3.searchChoices;\n      var hasUnactiveChoices = choices.some(function (option) {\n        return !option.active;\n      }); // Check that we have a value to search and the input was an alphanumeric character\n\n      if (value && value.length >= searchFloor) {\n        var resultCount = searchChoices ? this._searchChoices(value) : 0; // Trigger search event\n\n        this.passedElement.triggerEvent(_constants.EVENTS.search, {\n          value: value,\n          resultCount: resultCount\n        });\n      } else if (hasUnactiveChoices) {\n        // Otherwise reset choices to active\n        this._isSearching = false;\n\n        this._store.dispatch((0, _choices.activateChoices)(true));\n      }\n    }\n  }, {\n    key: \"_canAddItem\",\n    value: function _canAddItem(activeItems, value) {\n      var canAddItem = true;\n      var notice = (0, _utils.isType)('Function', this.config.addItemText) ? this.config.addItemText(value) : this.config.addItemText;\n\n      if (!this._isSelectOneElement) {\n        var isDuplicateValue = (0, _utils.existsInArray)(activeItems, value);\n\n        if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {\n          // If there is a max entry limit and we have reached that limit\n          // don't update\n          canAddItem = false;\n          notice = (0, _utils.isType)('Function', this.config.maxItemText) ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;\n        }\n\n        if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {\n          canAddItem = false;\n          notice = (0, _utils.isType)('Function', this.config.uniqueItemText) ? this.config.uniqueItemText(value) : this.config.uniqueItemText;\n        }\n\n        if (this._isTextElement && this.config.addItems && canAddItem && (0, _utils.isType)('Function', this.config.addItemFilterFn) && !this.config.addItemFilterFn(value)) {\n          canAddItem = false;\n          notice = (0, _utils.isType)('Function', this.config.customAddItemText) ? this.config.customAddItemText(value) : this.config.customAddItemText;\n        }\n      }\n\n      return {\n        response: canAddItem,\n        notice: notice\n      };\n    }\n  }, {\n    key: \"_ajaxCallback\",\n    value: function _ajaxCallback() {\n      var _this18 = this;\n\n      return function (results, value, label) {\n        if (!results || !value) {\n          return;\n        }\n\n        var parsedResults = (0, _utils.isType)('Object', results) ? [results] : results;\n\n        if (parsedResults && (0, _utils.isType)('Array', parsedResults) && parsedResults.length) {\n          // Remove loading states/text\n          _this18._handleLoadingState(false);\n\n          _this18._setLoading(true); // Add each result as a choice\n\n\n          parsedResults.forEach(function (result) {\n            if (result.choices) {\n              _this18._addGroup({\n                group: result,\n                id: result.id || null,\n                valueKey: value,\n                labelKey: label\n              });\n            } else {\n              _this18._addChoice({\n                value: (0, _utils.fetchFromObject)(result, value),\n                label: (0, _utils.fetchFromObject)(result, label),\n                isSelected: result.selected,\n                isDisabled: result.disabled,\n                customProperties: result.customProperties,\n                placeholder: result.placeholder\n              });\n            }\n          });\n\n          _this18._setLoading(false);\n\n          if (_this18._isSelectOneElement) {\n            _this18._selectPlaceholderChoice();\n          }\n        } else {\n          // No results, remove loading state\n          _this18._handleLoadingState(false);\n        }\n      };\n    }\n  }, {\n    key: \"_searchChoices\",\n    value: function _searchChoices(value) {\n      var newValue = (0, _utils.isType)('String', value) ? value.trim() : value;\n      var currentValue = (0, _utils.isType)('String', this._currentValue) ? this._currentValue.trim() : this._currentValue;\n\n      if (newValue.length < 1 && newValue === \"\".concat(currentValue, \" \")) {\n        return 0;\n      } // If new value matches the desired length and is not the same as the current value with a space\n\n\n      var haystack = this._store.searchableChoices;\n      var needle = newValue;\n      var keys = [].concat(this.config.searchFields);\n      var options = Object.assign(this.config.fuseOptions, {\n        keys: keys\n      });\n      var fuse = new _fuse.default(haystack, options);\n      var results = fuse.search(needle);\n      this._currentValue = newValue;\n      this._highlightPosition = 0;\n      this._isSearching = true;\n\n      this._store.dispatch((0, _choices.filterChoices)(results));\n\n      return results.length;\n    }\n  }, {\n    key: \"_addEventListeners\",\n    value: function _addEventListeners() {\n      window.delegateEvent.add('keyup', this._onKeyUp);\n      window.delegateEvent.add('keydown', this._onKeyDown);\n      window.delegateEvent.add('click', this._onClick);\n      window.delegateEvent.add('touchmove', this._onTouchMove);\n      window.delegateEvent.add('touchend', this._onTouchEnd);\n      window.delegateEvent.add('mousedown', this._onMouseDown);\n      window.delegateEvent.add('mouseover', this._onMouseOver);\n\n      if (this._isSelectOneElement) {\n        this.containerOuter.element.addEventListener('focus', this._onFocus);\n        this.containerOuter.element.addEventListener('blur', this._onBlur);\n      }\n\n      this.input.element.addEventListener('focus', this._onFocus);\n      this.input.element.addEventListener('blur', this._onBlur);\n\n      if (this.input.element.form) {\n        this.input.element.form.addEventListener('reset', this._onFormReset);\n      }\n\n      this.input.addEventListeners();\n    }\n  }, {\n    key: \"_removeEventListeners\",\n    value: function _removeEventListeners() {\n      window.delegateEvent.remove('keyup', this._onKeyUp);\n      window.delegateEvent.remove('keydown', this._onKeyDown);\n      window.delegateEvent.remove('click', this._onClick);\n      window.delegateEvent.remove('touchmove', this._onTouchMove);\n      window.delegateEvent.remove('touchend', this._onTouchEnd);\n      window.delegateEvent.remove('mousedown', this._onMouseDown);\n      window.delegateEvent.remove('mouseover', this._onMouseOver);\n\n      if (this._isSelectOneElement) {\n        this.containerOuter.element.removeEventListener('focus', this._onFocus);\n        this.containerOuter.element.removeEventListener('blur', this._onBlur);\n      }\n\n      this.input.element.removeEventListener('focus', this._onFocus);\n      this.input.element.removeEventListener('blur', this._onBlur);\n\n      if (this.input.element.form) {\n        this.input.element.form.removeEventListener('reset', this._onFormReset);\n      }\n\n      this.input.removeEventListeners();\n    }\n  }, {\n    key: \"_onKeyDown\",\n    value: function _onKeyDown(event) {\n      var _keyDownActions;\n\n      var target = event.target,\n          keyCode = event.keyCode,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey;\n\n      if (target !== this.input.element && !this.containerOuter.element.contains(target)) {\n        return;\n      }\n\n      var activeItems = this._store.activeItems;\n      var hasFocusedInput = this.input.isFocussed;\n      var hasActiveDropdown = this.dropdown.isActive;\n      var hasItems = this.itemList.hasChildren;\n      var keyString = String.fromCharCode(keyCode);\n      var BACK_KEY = _constants.KEY_CODES.BACK_KEY,\n          DELETE_KEY = _constants.KEY_CODES.DELETE_KEY,\n          ENTER_KEY = _constants.KEY_CODES.ENTER_KEY,\n          A_KEY = _constants.KEY_CODES.A_KEY,\n          ESC_KEY = _constants.KEY_CODES.ESC_KEY,\n          UP_KEY = _constants.KEY_CODES.UP_KEY,\n          DOWN_KEY = _constants.KEY_CODES.DOWN_KEY,\n          PAGE_UP_KEY = _constants.KEY_CODES.PAGE_UP_KEY,\n          PAGE_DOWN_KEY = _constants.KEY_CODES.PAGE_DOWN_KEY;\n      var hasCtrlDownKeyPressed = ctrlKey || metaKey; // If a user is typing and the dropdown is not active\n\n      if (!this._isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString)) {\n        this.showDropdown();\n      } // Map keys to key actions\n\n\n      var keyDownActions = (_keyDownActions = {}, _defineProperty(_keyDownActions, A_KEY, this._onAKey), _defineProperty(_keyDownActions, ENTER_KEY, this._onEnterKey), _defineProperty(_keyDownActions, ESC_KEY, this._onEscapeKey), _defineProperty(_keyDownActions, UP_KEY, this._onDirectionKey), _defineProperty(_keyDownActions, PAGE_UP_KEY, this._onDirectionKey), _defineProperty(_keyDownActions, DOWN_KEY, this._onDirectionKey), _defineProperty(_keyDownActions, PAGE_DOWN_KEY, this._onDirectionKey), _defineProperty(_keyDownActions, DELETE_KEY, this._onDeleteKey), _defineProperty(_keyDownActions, BACK_KEY, this._onDeleteKey), _keyDownActions); // If keycode has a function, run it\n\n      if (keyDownActions[keyCode]) {\n        keyDownActions[keyCode]({\n          event: event,\n          target: target,\n          keyCode: keyCode,\n          metaKey: metaKey,\n          activeItems: activeItems,\n          hasFocusedInput: hasFocusedInput,\n          hasActiveDropdown: hasActiveDropdown,\n          hasItems: hasItems,\n          hasCtrlDownKeyPressed: hasCtrlDownKeyPressed\n        });\n      }\n    }\n  }, {\n    key: \"_onKeyUp\",\n    value: function _onKeyUp(_ref2) {\n      var target = _ref2.target,\n          keyCode = _ref2.keyCode;\n\n      if (target !== this.input.element) {\n        return;\n      }\n\n      var value = this.input.value;\n      var activeItems = this._store.activeItems;\n\n      var canAddItem = this._canAddItem(activeItems, value);\n\n      var backKey = _constants.KEY_CODES.BACK_KEY,\n          deleteKey = _constants.KEY_CODES.DELETE_KEY; // We are typing into a text input and have a value, we want to show a dropdown\n      // notice. Otherwise hide the dropdown\n\n      if (this._isTextElement) {\n        var canShowDropdownNotice = canAddItem.notice && value;\n\n        if (canShowDropdownNotice) {\n          var dropdownItem = this._getTemplate('notice', canAddItem.notice);\n\n          this.dropdown.element.innerHTML = dropdownItem.outerHTML;\n          this.showDropdown(true);\n        } else {\n          this.hideDropdown(true);\n        }\n      } else {\n        var userHasRemovedValue = (keyCode === backKey || keyCode === deleteKey) && !target.value;\n        var canReactivateChoices = !this._isTextElement && this._isSearching;\n        var canSearch = this._canSearch && canAddItem.response;\n\n        if (userHasRemovedValue && canReactivateChoices) {\n          this._isSearching = false;\n\n          this._store.dispatch((0, _choices.activateChoices)(true));\n        } else if (canSearch) {\n          this._handleSearch(this.input.value);\n        }\n      }\n\n      this._canSearch = this.config.searchEnabled;\n    }\n  }, {\n    key: \"_onAKey\",\n    value: function _onAKey(_ref3) {\n      var hasItems = _ref3.hasItems,\n          hasCtrlDownKeyPressed = _ref3.hasCtrlDownKeyPressed;\n\n      // If CTRL + A or CMD + A have been pressed and there are items to select\n      if (hasCtrlDownKeyPressed && hasItems) {\n        this._canSearch = false;\n        var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;\n\n        if (shouldHightlightAll) {\n          this.highlightAll();\n        }\n      }\n    }\n  }, {\n    key: \"_onEnterKey\",\n    value: function _onEnterKey(_ref4) {\n      var event = _ref4.event,\n          target = _ref4.target,\n          activeItems = _ref4.activeItems,\n          hasActiveDropdown = _ref4.hasActiveDropdown;\n      var enterKey = _constants.KEY_CODES.ENTER_KEY;\n      var targetWasButton = target.hasAttribute('data-button');\n\n      if (this._isTextElement && target.value) {\n        var value = this.input.value;\n\n        var canAddItem = this._canAddItem(activeItems, value);\n\n        if (canAddItem.response) {\n          this.hideDropdown(true);\n\n          this._addItem({\n            value: value\n          });\n\n          this._triggerChange(value);\n\n          this.clearInput();\n        }\n      }\n\n      if (targetWasButton) {\n        this._handleButtonAction(activeItems, target);\n\n        event.preventDefault();\n      }\n\n      if (hasActiveDropdown) {\n        var highlightedChoice = this.dropdown.getChild(\".\".concat(this.config.classNames.highlightedState));\n\n        if (highlightedChoice) {\n          // add enter keyCode value\n          if (activeItems[0]) {\n            activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign\n          }\n\n          this._handleChoiceAction(activeItems, highlightedChoice);\n        }\n\n        event.preventDefault();\n      } else if (this._isSelectOneElement) {\n        this.showDropdown();\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"_onEscapeKey\",\n    value: function _onEscapeKey(_ref5) {\n      var hasActiveDropdown = _ref5.hasActiveDropdown;\n\n      if (hasActiveDropdown) {\n        this.hideDropdown(true);\n        this.containerOuter.focus();\n      }\n    }\n  }, {\n    key: \"_onDirectionKey\",\n    value: function _onDirectionKey(_ref6) {\n      var event = _ref6.event,\n          hasActiveDropdown = _ref6.hasActiveDropdown,\n          keyCode = _ref6.keyCode,\n          metaKey = _ref6.metaKey;\n      var downKey = _constants.KEY_CODES.DOWN_KEY,\n          pageUpKey = _constants.KEY_CODES.PAGE_UP_KEY,\n          pageDownKey = _constants.KEY_CODES.PAGE_DOWN_KEY; // If up or down key is pressed, traverse through options\n\n      if (hasActiveDropdown || this._isSelectOneElement) {\n        this.showDropdown();\n        this._canSearch = false;\n        var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;\n        var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;\n        var selectableChoiceIdentifier = '[data-choice-selectable]';\n        var nextEl;\n\n        if (skipKey) {\n          if (directionInt > 0) {\n            nextEl = Array.from(this.dropdown.element.querySelectorAll(selectableChoiceIdentifier)).pop();\n          } else {\n            nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n          }\n        } else {\n          var currentEl = this.dropdown.element.querySelector(\".\".concat(this.config.classNames.highlightedState));\n\n          if (currentEl) {\n            nextEl = (0, _utils.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);\n          } else {\n            nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n          }\n        }\n\n        if (nextEl) {\n          // We prevent default to stop the cursor moving\n          // when pressing the arrow\n          if (!(0, _utils.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {\n            this.choiceList.scrollToChoice(nextEl, directionInt);\n          }\n\n          this._highlightChoice(nextEl);\n        } // Prevent default to maintain cursor position whilst\n        // traversing dropdown options\n\n\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"_onDeleteKey\",\n    value: function _onDeleteKey(_ref7) {\n      var event = _ref7.event,\n          target = _ref7.target,\n          hasFocusedInput = _ref7.hasFocusedInput,\n          activeItems = _ref7.activeItems;\n\n      // If backspace or delete key is pressed and the input has no value\n      if (hasFocusedInput && !target.value && !this._isSelectOneElement) {\n        this._handleBackspace(activeItems);\n\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"_onTouchMove\",\n    value: function _onTouchMove() {\n      if (this._wasTap) {\n        this._wasTap = false;\n      }\n    }\n  }, {\n    key: \"_onTouchEnd\",\n    value: function _onTouchEnd(event) {\n      var _ref8 = event || event.touches[0],\n          target = _ref8.target;\n\n      var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);\n\n      if (touchWasWithinContainer) {\n        var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;\n\n        if (containerWasExactTarget) {\n          if (this._isTextElement) {\n            this.input.focus();\n          } else if (this._isSelectMultipleElement) {\n            this.showDropdown();\n          }\n        } // Prevents focus event firing\n\n\n        event.stopPropagation();\n      }\n\n      this._wasTap = true;\n    }\n  }, {\n    key: \"_onMouseDown\",\n    value: function _onMouseDown(event) {\n      var target = event.target,\n          shiftKey = event.shiftKey; // If we have our mouse down on the scrollbar and are on IE11...\n\n      if (this.choiceList.element.contains(target) && (0, _utils.isIE11)()) {\n        this._isScrollingOnIe = true;\n      }\n\n      if (!this.containerOuter.element.contains(target) || target === this.input.element) {\n        return;\n      }\n\n      var activeItems = this._store.activeItems;\n      var hasShiftKey = shiftKey;\n      var buttonTarget = (0, _utils.findAncestorByAttrName)(target, 'data-button');\n      var itemTarget = (0, _utils.findAncestorByAttrName)(target, 'data-item');\n      var choiceTarget = (0, _utils.findAncestorByAttrName)(target, 'data-choice');\n\n      if (buttonTarget) {\n        this._handleButtonAction(activeItems, buttonTarget);\n      } else if (itemTarget) {\n        this._handleItemAction(activeItems, itemTarget, hasShiftKey);\n      } else if (choiceTarget) {\n        this._handleChoiceAction(activeItems, choiceTarget);\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    key: \"_onMouseOver\",\n    value: function _onMouseOver(_ref9) {\n      var target = _ref9.target;\n      var targetWithinDropdown = target === this.dropdown || this.dropdown.element.contains(target);\n      var shouldHighlightChoice = targetWithinDropdown && target.hasAttribute('data-choice');\n\n      if (shouldHighlightChoice) {\n        this._highlightChoice(target);\n      }\n    }\n  }, {\n    key: \"_onClick\",\n    value: function _onClick(_ref10) {\n      var target = _ref10.target;\n      var clickWasWithinContainer = this.containerOuter.element.contains(target);\n\n      if (clickWasWithinContainer) {\n        if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {\n          if (this._isTextElement) {\n            if (document.activeElement !== this.input.element) {\n              this.input.focus();\n            }\n          } else {\n            this.showDropdown();\n            this.containerOuter.focus();\n          }\n        } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {\n          this.hideDropdown();\n        }\n      } else {\n        var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;\n\n        if (hasHighlightedItems) {\n          this.unhighlightAll();\n        }\n\n        this.containerOuter.removeFocusState();\n        this.hideDropdown(true);\n      }\n    }\n  }, {\n    key: \"_onFocus\",\n    value: function _onFocus(_ref11) {\n      var _this19 = this;\n\n      var target = _ref11.target;\n      var focusWasWithinContainer = this.containerOuter.element.contains(target);\n\n      if (!focusWasWithinContainer) {\n        return;\n      }\n\n      var focusActions = {\n        text: function text() {\n          if (target === _this19.input.element) {\n            _this19.containerOuter.addFocusState();\n          }\n        },\n        'select-one': function selectOne() {\n          _this19.containerOuter.addFocusState();\n\n          if (target === _this19.input.element) {\n            _this19.showDropdown(true);\n          }\n        },\n        'select-multiple': function selectMultiple() {\n          if (target === _this19.input.element) {\n            _this19.showDropdown(true); // If element is a select box, the focused element is the container and the dropdown\n            // isn't already open, focus and show dropdown\n\n\n            _this19.containerOuter.addFocusState();\n          }\n        }\n      };\n      focusActions[this.passedElement.element.type]();\n    }\n  }, {\n    key: \"_onBlur\",\n    value: function _onBlur(_ref12) {\n      var _this20 = this;\n\n      var target = _ref12.target;\n      var blurWasWithinContainer = this.containerOuter.element.contains(target);\n\n      if (blurWasWithinContainer && !this._isScrollingOnIe) {\n        var activeItems = this._store.activeItems;\n        var hasHighlightedItems = activeItems.some(function (item) {\n          return item.highlighted;\n        });\n        var blurActions = {\n          text: function text() {\n            if (target === _this20.input.element) {\n              _this20.containerOuter.removeFocusState();\n\n              if (hasHighlightedItems) {\n                _this20.unhighlightAll();\n              }\n\n              _this20.hideDropdown(true);\n            }\n          },\n          'select-one': function selectOne() {\n            _this20.containerOuter.removeFocusState();\n\n            if (target === _this20.input.element || target === _this20.containerOuter.element && !_this20._canSearch) {\n              _this20.hideDropdown(true);\n            }\n          },\n          'select-multiple': function selectMultiple() {\n            if (target === _this20.input.element) {\n              _this20.containerOuter.removeFocusState();\n\n              _this20.hideDropdown(true);\n\n              if (hasHighlightedItems) {\n                _this20.unhighlightAll();\n              }\n            }\n          }\n        };\n        blurActions[this.passedElement.element.type]();\n      } else {\n        // On IE11, clicking the scollbar blurs our input and thus\n        // closes the dropdown. To stop this, we refocus our input\n        // if we know we are on IE *and* are scrolling.\n        this._isScrollingOnIe = false;\n        this.input.element.focus();\n      }\n    }\n  }, {\n    key: \"_onFormReset\",\n    value: function _onFormReset() {\n      this._store.dispatch((0, _misc.resetTo)(this._initialState));\n    }\n  }, {\n    key: \"_highlightChoice\",\n    value: function _highlightChoice() {\n      var _this21 = this;\n\n      var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));\n\n      if (!choices.length) {\n        return;\n      }\n\n      var passedEl = el;\n      var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(\".\".concat(this.config.classNames.highlightedState))); // Remove any highlighted choices\n\n      highlightedChoices.forEach(function (choice) {\n        choice.classList.remove(_this21.config.classNames.highlightedState);\n        choice.setAttribute('aria-selected', 'false');\n      });\n\n      if (passedEl) {\n        this._highlightPosition = choices.indexOf(passedEl);\n      } else {\n        // Highlight choice based on last known highlight location\n        if (choices.length > this._highlightPosition) {\n          // If we have an option to highlight\n          passedEl = choices[this._highlightPosition];\n        } else {\n          // Otherwise highlight the option before\n          passedEl = choices[choices.length - 1];\n        }\n\n        if (!passedEl) {\n          passedEl = choices[0];\n        }\n      }\n\n      passedEl.classList.add(this.config.classNames.highlightedState);\n      passedEl.setAttribute('aria-selected', 'true');\n      this.passedElement.triggerEvent(_constants.EVENTS.highlightChoice, {\n        el: passedEl\n      });\n\n      if (this.dropdown.isActive) {\n        // IE11 ignores aria-label and blocks virtual keyboard\n        // if aria-activedescendant is set without a dropdown\n        this.input.setActiveDescendant(passedEl.id);\n        this.containerOuter.setActiveDescendant(passedEl.id);\n      }\n    }\n  }, {\n    key: \"_addItem\",\n    value: function _addItem(_ref13) {\n      var value = _ref13.value,\n          _ref13$label = _ref13.label,\n          label = _ref13$label === void 0 ? null : _ref13$label,\n          _ref13$choiceId = _ref13.choiceId,\n          choiceId = _ref13$choiceId === void 0 ? -1 : _ref13$choiceId,\n          _ref13$groupId = _ref13.groupId,\n          groupId = _ref13$groupId === void 0 ? -1 : _ref13$groupId,\n          _ref13$customProperti = _ref13.customProperties,\n          customProperties = _ref13$customProperti === void 0 ? null : _ref13$customProperti,\n          _ref13$placeholder = _ref13.placeholder,\n          placeholder = _ref13$placeholder === void 0 ? false : _ref13$placeholder,\n          _ref13$keyCode = _ref13.keyCode,\n          keyCode = _ref13$keyCode === void 0 ? null : _ref13$keyCode;\n      var passedValue = (0, _utils.isType)('String', value) ? value.trim() : value;\n      var passedKeyCode = keyCode;\n      var passedCustomProperties = customProperties;\n      var items = this._store.items;\n      var passedLabel = label || passedValue;\n      var passedOptionId = parseInt(choiceId, 10) || -1;\n      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n      var id = items ? items.length + 1 : 1; // If a prepended value has been passed, prepend it\n\n      if (this.config.prependValue) {\n        passedValue = this.config.prependValue + passedValue.toString();\n      } // If an appended value has been passed, append it\n\n\n      if (this.config.appendValue) {\n        passedValue += this.config.appendValue.toString();\n      }\n\n      this._store.dispatch((0, _items.addItem)({\n        value: passedValue,\n        label: passedLabel,\n        id: id,\n        choiceId: passedOptionId,\n        groupId: groupId,\n        customProperties: customProperties,\n        placeholder: placeholder,\n        keyCode: passedKeyCode\n      }));\n\n      if (this._isSelectOneElement) {\n        this.removeActiveItems(id);\n      } // Trigger change event\n\n\n      this.passedElement.triggerEvent(_constants.EVENTS.addItem, {\n        id: id,\n        value: passedValue,\n        label: passedLabel,\n        customProperties: passedCustomProperties,\n        groupValue: group && group.value ? group.value : undefined,\n        keyCode: passedKeyCode\n      });\n      return this;\n    }\n  }, {\n    key: \"_removeItem\",\n    value: function _removeItem(item) {\n      if (!item || !(0, _utils.isType)('Object', item)) {\n        return this;\n      }\n\n      var id = item.id,\n          value = item.value,\n          label = item.label,\n          choiceId = item.choiceId,\n          groupId = item.groupId;\n      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n\n      this._store.dispatch((0, _items.removeItem)(id, choiceId));\n\n      if (group && group.value) {\n        this.passedElement.triggerEvent(_constants.EVENTS.removeItem, {\n          id: id,\n          value: value,\n          label: label,\n          groupValue: group.value\n        });\n      } else {\n        this.passedElement.triggerEvent(_constants.EVENTS.removeItem, {\n          id: id,\n          value: value,\n          label: label\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_addChoice\",\n    value: function _addChoice(_ref14) {\n      var value = _ref14.value,\n          _ref14$label = _ref14.label,\n          label = _ref14$label === void 0 ? null : _ref14$label,\n          _ref14$isSelected = _ref14.isSelected,\n          isSelected = _ref14$isSelected === void 0 ? false : _ref14$isSelected,\n          _ref14$isDisabled = _ref14.isDisabled,\n          isDisabled = _ref14$isDisabled === void 0 ? false : _ref14$isDisabled,\n          _ref14$groupId = _ref14.groupId,\n          groupId = _ref14$groupId === void 0 ? -1 : _ref14$groupId,\n          _ref14$customProperti = _ref14.customProperties,\n          customProperties = _ref14$customProperti === void 0 ? null : _ref14$customProperti,\n          _ref14$placeholder = _ref14.placeholder,\n          placeholder = _ref14$placeholder === void 0 ? false : _ref14$placeholder,\n          _ref14$keyCode = _ref14.keyCode,\n          keyCode = _ref14$keyCode === void 0 ? null : _ref14$keyCode;\n\n      if (typeof value === 'undefined' || value === null) {\n        return;\n      } // Generate unique id\n\n\n      var choices = this._store.choices;\n      var choiceLabel = label || value;\n      var choiceId = choices ? choices.length + 1 : 1;\n      var choiceElementId = \"\".concat(this._baseId, \"-\").concat(this._idNames.itemChoice, \"-\").concat(choiceId);\n\n      this._store.dispatch((0, _choices.addChoice)({\n        value: value,\n        label: choiceLabel,\n        id: choiceId,\n        groupId: groupId,\n        disabled: isDisabled,\n        elementId: choiceElementId,\n        customProperties: customProperties,\n        placeholder: placeholder,\n        keyCode: keyCode\n      }));\n\n      if (isSelected) {\n        this._addItem({\n          value: value,\n          label: choiceLabel,\n          choiceId: choiceId,\n          customProperties: customProperties,\n          placeholder: placeholder,\n          keyCode: keyCode\n        });\n      }\n    }\n  }, {\n    key: \"_addGroup\",\n    value: function _addGroup(_ref15) {\n      var _this22 = this;\n\n      var group = _ref15.group,\n          id = _ref15.id,\n          _ref15$valueKey = _ref15.valueKey,\n          valueKey = _ref15$valueKey === void 0 ? 'value' : _ref15$valueKey,\n          _ref15$labelKey = _ref15.labelKey,\n          labelKey = _ref15$labelKey === void 0 ? 'label' : _ref15$labelKey;\n      var groupChoices = (0, _utils.isType)('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));\n      var groupId = id || Math.floor(new Date().valueOf() * Math.random());\n      var isDisabled = group.disabled ? group.disabled : false;\n\n      if (groupChoices) {\n        this._store.dispatch((0, _groups.addGroup)(group.label, groupId, true, isDisabled));\n\n        var addGroupChoices = function addGroupChoices(choice) {\n          var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;\n\n          _this22._addChoice({\n            value: choice[valueKey],\n            label: (0, _utils.isType)('Object', choice) ? choice[labelKey] : choice.innerHTML,\n            isSelected: choice.selected,\n            isDisabled: isOptDisabled,\n            groupId: groupId,\n            customProperties: choice.customProperties,\n            placeholder: choice.placeholder\n          });\n        };\n\n        groupChoices.forEach(addGroupChoices);\n      } else {\n        this._store.dispatch((0, _groups.addGroup)(group.label, group.id, false, group.disabled));\n      }\n    }\n  }, {\n    key: \"_getTemplate\",\n    value: function _getTemplate(template) {\n      var _templates$template;\n\n      if (!template) {\n        return null;\n      }\n\n      var _this$config4 = this.config,\n          templates = _this$config4.templates,\n          classNames = _this$config4.classNames;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return (_templates$template = templates[template]).call.apply(_templates$template, [this, classNames].concat(args));\n    }\n  }, {\n    key: \"_createTemplates\",\n    value: function _createTemplates() {\n      var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;\n      var userTemplates = {};\n\n      if (callbackOnCreateTemplates && (0, _utils.isType)('Function', callbackOnCreateTemplates)) {\n        userTemplates = callbackOnCreateTemplates.call(this, _utils.strToEl);\n      }\n\n      this.config.templates = (0, _deepmerge.default)(_templates.TEMPLATES, userTemplates);\n    }\n  }, {\n    key: \"_createElements\",\n    value: function _createElements() {\n      this.containerOuter = new _components.Container({\n        element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type),\n        classNames: this.config.classNames,\n        type: this.passedElement.element.type,\n        position: this.config.position\n      });\n      this.containerInner = new _components.Container({\n        element: this._getTemplate('containerInner'),\n        classNames: this.config.classNames,\n        type: this.passedElement.element.type,\n        position: this.config.position\n      });\n      this.input = new _components.Input({\n        element: this._getTemplate('input', this._placeholderValue),\n        classNames: this.config.classNames,\n        type: this.passedElement.element.type\n      });\n      this.choiceList = new _components.List({\n        element: this._getTemplate('choiceList', this._isSelectOneElement)\n      });\n      this.itemList = new _components.List({\n        element: this._getTemplate('itemList', this._isSelectOneElement)\n      });\n      this.dropdown = new _components.Dropdown({\n        element: this._getTemplate('dropdown'),\n        classNames: this.config.classNames,\n        type: this.passedElement.element.type\n      });\n    }\n  }, {\n    key: \"_createStructure\",\n    value: function _createStructure() {\n      // Hide original element\n      this.passedElement.conceal(); // Wrap input in container preserving DOM ordering\n\n      this.containerInner.wrap(this.passedElement.element); // Wrapper inner container with outer container\n\n      this.containerOuter.wrap(this.containerInner.element);\n\n      if (this._isSelectOneElement) {\n        this.input.placeholder = this.config.searchPlaceholderValue || '';\n      } else if (this._placeholderValue) {\n        this.input.placeholder = this._placeholderValue;\n        this.input.setWidth(true);\n      }\n\n      this.containerOuter.element.appendChild(this.containerInner.element);\n      this.containerOuter.element.appendChild(this.dropdown.element);\n      this.containerInner.element.appendChild(this.itemList.element);\n\n      if (!this._isTextElement) {\n        this.dropdown.element.appendChild(this.choiceList.element);\n      }\n\n      if (!this._isSelectOneElement) {\n        this.containerInner.element.appendChild(this.input.element);\n      } else if (this.config.searchEnabled) {\n        this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);\n      }\n\n      if (this._isSelectElement) {\n        this._addPredefinedChoices();\n      } else if (this._isTextElement) {\n        this._addPredefinedItems();\n      }\n    }\n  }, {\n    key: \"_addPredefinedChoices\",\n    value: function _addPredefinedChoices() {\n      var _this23 = this;\n\n      var passedGroups = this.passedElement.optionGroups;\n      this._highlightPosition = 0;\n      this._isSearching = false;\n\n      this._setLoading(true);\n\n      if (passedGroups && passedGroups.length) {\n        // If we have a placeholder option\n        var placeholderChoice = this.passedElement.placeholderOption;\n\n        if (placeholderChoice && placeholderChoice.parentNode.tagName === 'SELECT') {\n          this._addChoice({\n            value: placeholderChoice.value,\n            label: placeholderChoice.innerHTML,\n            isSelected: placeholderChoice.selected,\n            isDisabled: placeholderChoice.disabled,\n            placeholder: true\n          });\n        }\n\n        passedGroups.forEach(function (group) {\n          return _this23._addGroup({\n            group: group,\n            id: group.id || null\n          });\n        });\n      } else {\n        var passedOptions = this.passedElement.options;\n        var filter = this.config.sortFn;\n        var allChoices = this._presetChoices; // Create array of options from option elements\n\n        passedOptions.forEach(function (o) {\n          allChoices.push({\n            value: o.value,\n            label: o.innerHTML,\n            selected: o.selected,\n            disabled: o.disabled || o.parentNode.disabled,\n            placeholder: o.hasAttribute('placeholder'),\n            customProperties: o.getAttribute('data-custom-properties')\n          });\n        }); // If sorting is enabled or the user is searching, filter choices\n\n        if (this.config.shouldSort) allChoices.sort(filter); // Determine whether there is a selected choice\n\n        var hasSelectedChoice = allChoices.some(function (choice) {\n          return choice.selected;\n        });\n\n        var handleChoice = function handleChoice(choice, index) {\n          var value = choice.value,\n              label = choice.label,\n              customProperties = choice.customProperties,\n              placeholder = choice.placeholder;\n\n          if (_this23._isSelectElement) {\n            // If the choice is actually a group\n            if (choice.choices) {\n              _this23._addGroup({\n                group: choice,\n                id: choice.id || null\n              });\n            } else {\n              // If there is a selected choice already or the choice is not\n              // the first in the array, add each choice normally\n              // Otherwise pre-select the first choice in the array if it's a single select\n              var shouldPreselect = _this23._isSelectOneElement && !hasSelectedChoice && index === 0;\n              var isSelected = shouldPreselect ? true : choice.selected;\n              var isDisabled = shouldPreselect ? false : choice.disabled;\n\n              _this23._addChoice({\n                value: value,\n                label: label,\n                isSelected: isSelected,\n                isDisabled: isDisabled,\n                customProperties: customProperties,\n                placeholder: placeholder\n              });\n            }\n          } else {\n            _this23._addChoice({\n              value: value,\n              label: label,\n              isSelected: choice.selected,\n              isDisabled: choice.disabled,\n              customProperties: customProperties,\n              placeholder: placeholder\n            });\n          }\n        }; // Add each choice\n\n\n        allChoices.forEach(function (choice, index) {\n          return handleChoice(choice, index);\n        });\n      }\n\n      this._setLoading(false);\n    }\n  }, {\n    key: \"_addPredefinedItems\",\n    value: function _addPredefinedItems() {\n      var _this24 = this;\n\n      var handlePresetItem = function handlePresetItem(item) {\n        var itemType = (0, _utils.getType)(item);\n\n        if (itemType === 'Object' && item.value) {\n          _this24._addItem({\n            value: item.value,\n            label: item.label,\n            choiceId: item.id,\n            customProperties: item.customProperties,\n            placeholder: item.placeholder\n          });\n        } else if (itemType === 'String') {\n          _this24._addItem({\n            value: item\n          });\n        }\n      };\n\n      this._presetItems.forEach(function (item) {\n        return handlePresetItem(item);\n      });\n    }\n  }, {\n    key: \"_setChoiceOrItem\",\n    value: function _setChoiceOrItem(item) {\n      var _this25 = this;\n\n      var itemType = (0, _utils.getType)(item).toLowerCase();\n      var handleType = {\n        object: function object() {\n          if (!item.value) {\n            return;\n          } // If we are dealing with a select input, we need to create an option first\n          // that is then selected. For text inputs we can just add items normally.\n\n\n          if (!_this25._isTextElement) {\n            _this25._addChoice({\n              value: item.value,\n              label: item.label,\n              isSelected: true,\n              isDisabled: false,\n              customProperties: item.customProperties,\n              placeholder: item.placeholder\n            });\n          } else {\n            _this25._addItem({\n              value: item.value,\n              label: item.label,\n              choiceId: item.id,\n              customProperties: item.customProperties,\n              placeholder: item.placeholder\n            });\n          }\n        },\n        string: function string() {\n          if (!_this25._isTextElement) {\n            _this25._addChoice({\n              value: item,\n              label: item,\n              isSelected: true,\n              isDisabled: false\n            });\n          } else {\n            _this25._addItem({\n              value: item\n            });\n          }\n        }\n      };\n      handleType[itemType]();\n    }\n  }, {\n    key: \"_findAndSelectChoiceByValue\",\n    value: function _findAndSelectChoiceByValue(val) {\n      var _this26 = this;\n\n      var choices = this._store.choices; // Check 'value' property exists and the choice isn't already selected\n\n      var foundChoice = choices.find(function (choice) {\n        return _this26.config.itemComparer(choice.value, val);\n      });\n\n      if (foundChoice && !foundChoice.selected) {\n        this._addItem({\n          value: foundChoice.value,\n          label: foundChoice.label,\n          choiceId: foundChoice.id,\n          groupId: foundChoice.groupId,\n          customProperties: foundChoice.customProperties,\n          placeholder: foundChoice.placeholder,\n          keyCode: foundChoice.keyCode\n        });\n      }\n    }\n  }, {\n    key: \"_generateInstances\",\n    value: function _generateInstances(elements, config) {\n      return elements.reduce(function (instances, element) {\n        instances.push(new Choices(element, config));\n        return instances;\n      }, [this]);\n    }\n  }, {\n    key: \"_generatePlaceholderValue\",\n    value: function _generatePlaceholderValue() {\n      if (this._isSelectOneElement) {\n        return false;\n      }\n\n      return this.config.placeholder ? this.config.placeholderValue || this.passedElement.element.getAttribute('placeholder') : false;\n    }\n    /* =====  End of Private functions  ====== */\n\n  }]);\n\n  return Choices;\n}();\n\nChoices.userDefaults = {}; // We cannot export default here due to Webpack: https://github.com/webpack/webpack/issues/3929\n\nmodule.exports = Choices;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * Fuse.js v3.4.2 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/bitap/bitap_matched_indices.js\":\n/*!********************************************!*\\\n  !*** ./src/bitap/bitap_matched_indices.js ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n\n      start = -1;\n    }\n  } // (i-1 - start) + 1 => i - start\n\n\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n\n/***/ \"./src/bitap/bitap_pattern_alphabet.js\":\n/*!*********************************************!*\\\n  !*** ./src/bitap/bitap_pattern_alphabet.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n\n/***/ \"./src/bitap/bitap_regex_search.js\":\n/*!*****************************************!*\\\n  !*** ./src/bitap/bitap_regex_search.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/bitap/bitap_score.js\":\n/*!**********************************!*\\\n  !*** ./src/bitap/bitap_score.js ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === void 0 ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? 100 : _ref$distance;\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n\n/***/ \"./src/bitap/bitap_search.js\":\n/*!***********************************!*\\\n  !*** ./src/bitap/bitap_search.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar bitapScore = __webpack_require__(/*! ./bitap_score */ \"./src/bitap/bitap_score.js\");\n\nvar matchedIndices = __webpack_require__(/*! ./bitap_matched_indices */ \"./src/bitap/bitap_matched_indices.js\");\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === void 0 ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === void 0 ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;\n  var expectedLocation = location; // Set starting location at beginning text and initialize the alphabet.\n\n  var textLen = text.length; // Highest score beyond which we give up.\n\n  var currentThreshold = threshold; // Is there a nearby exact match? (speedup)\n\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n  var patternLen = pattern.length; // a mask of the matches\n\n  var matchMask = [];\n\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold); // What about in the other direction? (speed up)\n\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  } // Reset the best location\n\n\n  bestLocation = -1;\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    } // Use the result from this iteration as the maximum for the next.\n\n\n    binMax = binMid;\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array\n\n    var bitArr = Array(finish + 2);\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      } // First pass: exact match\n\n\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match\n\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        }); // This match will almost certainly be better than any existing match.\n        // But check anyway.\n\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.\n\n          if (bestLocation <= expectedLocation) {\n            break;\n          } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n\n\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    } // No hope for a (better) match at greater error levels.\n\n\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    }); // console.log('score', score, finalScore)\n\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  } // console.log('FINAL SCORE', finalScore)\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n\n\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/bitap/index.js\":\n/*!****************************!*\\\n  !*** ./src/bitap/index.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar bitapRegexSearch = __webpack_require__(/*! ./bitap_regex_search */ \"./src/bitap/bitap_regex_search.js\");\n\nvar bitapSearch = __webpack_require__(/*! ./bitap_search */ \"./src/bitap/bitap_search.js\");\n\nvar patternAlphabet = __webpack_require__(/*! ./bitap_pattern_alphabet */ \"./src/bitap/bitap_pattern_alphabet.js\");\n\nvar Bitap =\n/*#__PURE__*/\nfunction () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === void 0 ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === void 0 ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === void 0 ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: \"search\",\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      } // Exact match\n\n\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      } // When pattern length is greater than the machine word length, just do a a regex comparison\n\n\n      var _this$options = this.options,\n          maxPatternLength = _this$options.maxPatternLength,\n          tokenSeparator = _this$options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      } // Otherwise, use Bitap algorithm\n\n\n      var _this$options2 = this.options,\n          location = _this$options2.location,\n          distance = _this$options2.distance,\n          threshold = _this$options2.threshold,\n          findAllMatches = _this$options2.findAllMatches,\n          minMatchCharLength = _this$options2.minMatchCharLength;\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}(); // let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\n\nmodule.exports = Bitap;\n\n/***/ }),\n\n/***/ \"./src/helpers/deep_value.js\":\n/*!***********************************!*\\\n  !*** ./src/helpers/deep_value.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(/*! ./is_array */ \"./src/helpers/is_array.js\");\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n\n/***/ \"./src/helpers/is_array.js\":\n/*!*********************************!*\\\n  !*** ./src/helpers/is_array.js ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (obj) {\n  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);\n};\n\n/***/ }),\n\n/***/ \"./src/index.js\":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Bitap = __webpack_require__(/*! ./bitap */ \"./src/bitap/index.js\");\n\nvar deepValue = __webpack_require__(/*! ./helpers/deep_value */ \"./src/helpers/deep_value.js\");\n\nvar isArray = __webpack_require__(/*! ./helpers/is_array */ \"./src/helpers/is_array.js\");\n\nvar Fuse =\n/*#__PURE__*/\nfunction () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === void 0 ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === void 0 ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === void 0 ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === void 0 ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === void 0 ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === void 0 ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === void 0 ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === void 0 ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === void 0 ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === void 0 ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === void 0 ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === void 0 ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: \"setCollection\",\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: \"search\",\n    value: function search(pattern) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        limit: false\n      };\n\n      this._log(\"---------\\nSearch pattern: \\\"\".concat(pattern, \"\\\"\"));\n\n      var _this$_prepareSearche = this._prepareSearchers(pattern),\n          tokenSearchers = _this$_prepareSearche.tokenSearchers,\n          fullSearcher = _this$_prepareSearche.fullSearcher;\n\n      var _this$_search = this._search(tokenSearchers, fullSearcher),\n          weights = _this$_search.weights,\n          results = _this$_search.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      if (opts.limit && typeof opts.limit === 'number') {\n        results = results.slice(0, opts.limit);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: \"_prepareSearchers\",\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n      return {\n        tokenSearchers: tokenSearchers,\n        fullSearcher: fullSearcher\n      };\n    }\n  }, {\n    key: \"_search\",\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments.length > 1 ? arguments[1] : undefined;\n      var list = this.list;\n      var resultMap = {};\n      var results = []; // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return {\n          weights: null,\n          results: results\n        };\n      } // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n\n\n      var weights = {};\n\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i]; // Iterate over every key\n\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return {\n        weights: weights,\n        results: results\n      };\n    }\n  }, {\n    key: \"_analyze\",\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === void 0 ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === void 0 ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === void 0 ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === void 0 ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === void 0 ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log(\"\\nKey: \".concat(key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n\n        this._log(\"Full text: \\\"\".concat(value, \"\\\", score: \").concat(mainSearchResult.score));\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log(\"\\nPattern: \\\"\".concat(tokenSearcher.pattern, \"\\\"\")); // let tokenScores = []\n\n\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n\n              this._log(\"Token: \\\"\".concat(word, \"\\\", score: \").concat(obj[word])); // tokenScores.push(obj)\n\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log(\"\\nCheck Matches: \".concat(checkTextMatches)); // If a match is found, add the item to <rawResults>, including its score\n\n\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_computeScore\",\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n        var currScore = 1;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            currScore *= nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? currScore : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: \"_format\",\n    value: function _format(results) {\n      var finalOutput = [];\n\n      if (this.options.verbose) {\n        var cache = [];\n\n        this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results, function (key, value) {\n          if (_typeof(value) === 'object' && value !== null) {\n            if (cache.indexOf(value) !== -1) {\n              // Circular reference found, discard key\n              return;\n            } // Store value in our collection\n\n\n            cache.push(value);\n          }\n\n          return value;\n        }));\n\n        cache = null;\n      }\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n\n            if (item.key) {\n              obj.key = item.key;\n            }\n\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: \"_log\",\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n\n/******/ });\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (deepmerge_1);\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nwindow.delegateEvent = function delegateEvent() {\n  var events;\n  var addedListenerTypes;\n\n  if (typeof events === 'undefined') {\n    events = new Map();\n  }\n\n  if (typeof addedListenerTypes === 'undefined') {\n    addedListenerTypes = [];\n  }\n\n  function _callback(event) {\n    var type = events.get(event.type);\n    if (!type) return;\n    type.forEach(function (fn) {\n      return fn(event);\n    });\n  }\n\n  return {\n    add: function add(type, fn) {\n      // Cache list of events.\n      if (events.has(type)) {\n        events.get(type).push(fn);\n      } else {\n        events.set(type, [fn]);\n      } // Setup events.\n\n\n      if (addedListenerTypes.indexOf(type) === -1) {\n        document.documentElement.addEventListener(type, _callback, true);\n        addedListenerTypes.push(type);\n      }\n    },\n    remove: function remove(type, fn) {\n      if (!events.get(type)) return;\n      events.set(type, events.get(type).filter(function (item) {\n        return item !== fn;\n      }));\n\n      if (!events.get(type).length) {\n        addedListenerTypes.splice(addedListenerTypes.indexOf(type), 1);\n      }\n    }\n  };\n}();\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _redux = __webpack_require__(5);\n\nvar _index = _interopRequireDefault(__webpack_require__(15));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Store =\n/*#__PURE__*/\nfunction () {\n  function Store() {\n    _classCallCheck(this, Store);\n\n    this._store = (0, _redux.createStore)(_index.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n  }\n  /**\n   * Subscribe store to function call (wrapped Redux method)\n   * @param  {Function} onChange Function to trigger when state changes\n   * @return\n   */\n\n\n  _createClass(Store, [{\n    key: \"subscribe\",\n    value: function subscribe(onChange) {\n      this._store.subscribe(onChange);\n    }\n    /**\n     * Dispatch event to store (wrapped Redux method)\n     * @param  {Function} action Action function to trigger\n     * @return\n     */\n\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      this._store.dispatch(action);\n    }\n    /**\n     * Get store object (wrapping Redux method)\n     * @return {Object} State\n     */\n\n  }, {\n    key: \"isLoading\",\n\n    /**\n     * Get loading state from store\n     * @return {Boolean} Loading State\n     */\n    value: function isLoading() {\n      return this.state.general.loading;\n    }\n    /**\n     * Get single choice by it's ID\n     * @return {Object} Found choice\n     */\n\n  }, {\n    key: \"getChoiceById\",\n    value: function getChoiceById(id) {\n      if (id) {\n        return this.activeChoices.find(function (choice) {\n          return choice.id === parseInt(id, 10);\n        });\n      }\n\n      return false;\n    }\n    /**\n     * Get group by group id\n     * @param  {Number} id Group ID\n     * @return {Object}    Group data\n     */\n\n  }, {\n    key: \"getGroupById\",\n    value: function getGroupById(id) {\n      return this.groups.find(function (group) {\n        return group.id === parseInt(id, 10);\n      });\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._store.getState();\n    }\n    /**\n     * Get items from store\n     * @return {Array} Item objects\n     */\n\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this.state.items;\n    }\n    /**\n     * Get active items from store\n     * @return {Array} Item objects\n     */\n\n  }, {\n    key: \"activeItems\",\n    get: function get() {\n      return this.items.filter(function (item) {\n        return item.active === true;\n      });\n    }\n    /**\n     * Get highlighted items from store\n     * @return {Array} Item objects\n     */\n\n  }, {\n    key: \"highlightedActiveItems\",\n    get: function get() {\n      return this.items.filter(function (item) {\n        return item.active && item.highlighted;\n      });\n    }\n    /**\n     * Get choices from store\n     * @return {Array} Option objects\n     */\n\n  }, {\n    key: \"choices\",\n    get: function get() {\n      return this.state.choices;\n    }\n    /**\n     * Get active choices from store\n     * @return {Array} Option objects\n     */\n\n  }, {\n    key: \"activeChoices\",\n    get: function get() {\n      var choices = this.choices;\n      var values = choices.filter(function (choice) {\n        return choice.active === true;\n      });\n      return values;\n    }\n    /**\n     * Get selectable choices from store\n     * @return {Array} Option objects\n     */\n\n  }, {\n    key: \"selectableChoices\",\n    get: function get() {\n      return this.choices.filter(function (choice) {\n        return choice.disabled !== true;\n      });\n    }\n    /**\n     * Get choices that can be searched (excluding placeholders)\n     * @return {Array} Option objects\n     */\n\n  }, {\n    key: \"searchableChoices\",\n    get: function get() {\n      return this.selectableChoices.filter(function (choice) {\n        return choice.placeholder !== true;\n      });\n    }\n    /**\n     * Get placeholder choice from store\n     * @return {Object} Found placeholder\n     */\n\n  }, {\n    key: \"placeholderChoice\",\n    get: function get() {\n      return [].concat(this.choices).reverse().find(function (choice) {\n        return choice.placeholder === true;\n      });\n    }\n    /**\n     * Get groups from store\n     * @return {Array} Group objects\n     */\n\n  }, {\n    key: \"groups\",\n    get: function get() {\n      return this.state.groups;\n    }\n    /**\n     * Get active groups from store\n     * @return {Array} Group objects\n     */\n\n  }, {\n    key: \"activeGroups\",\n    get: function get() {\n      var groups = this.groups,\n          choices = this.choices;\n      return groups.filter(function (group) {\n        var isActive = group.active === true && group.disabled === false;\n        var hasActiveOptions = choices.some(function (choice) {\n          return choice.active === true && choice.disabled === false;\n        });\n        return isActive && hasActiveOptions;\n      }, []);\n    }\n  }]);\n\n  return Store;\n}();\n\nexports.default = Store;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _redux = __webpack_require__(5);\n\nvar _items = _interopRequireDefault(__webpack_require__(16));\n\nvar _groups = _interopRequireDefault(__webpack_require__(17));\n\nvar _choices = _interopRequireDefault(__webpack_require__(18));\n\nvar _general = _interopRequireDefault(__webpack_require__(19));\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar appReducer = (0, _redux.combineReducers)({\n  items: _items.default,\n  groups: _groups.default,\n  choices: _choices.default,\n  general: _general.default\n});\n\nvar rootReducer = function rootReducer(passedState, action) {\n  var state = passedState; // If we are clearing all items, groups and options we reassign\n  // state and then pass that state to our proper reducer. This isn't\n  // mutating our actual state\n  // See: http://stackoverflow.com/a/35641992\n\n  if (action.type === 'CLEAR_ALL') {\n    state = undefined;\n  } else if (action.type === 'RESET_TO') {\n    return (0, _utils.cloneObject)(action.state);\n  }\n\n  return appReducer(state, action);\n};\n\nvar _default = rootReducer;\nexports.default = _default;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = items;\nexports.defaultState = void 0;\nvar defaultState = [];\nexports.defaultState = defaultState;\n\nfunction items() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'ADD_ITEM':\n      {\n        // Add object to items array\n        var newState = [].concat(state, [{\n          id: action.id,\n          choiceId: action.choiceId,\n          groupId: action.groupId,\n          value: action.value,\n          label: action.label,\n          active: true,\n          highlighted: false,\n          customProperties: action.customProperties,\n          placeholder: action.placeholder || false,\n          keyCode: null\n        }]);\n        return newState.map(function (obj) {\n          var item = obj;\n          item.highlighted = false;\n          return item;\n        });\n      }\n\n    case 'REMOVE_ITEM':\n      {\n        // Set item to inactive\n        return state.map(function (obj) {\n          var item = obj;\n\n          if (item.id === action.id) {\n            item.active = false;\n          }\n\n          return item;\n        });\n      }\n\n    case 'HIGHLIGHT_ITEM':\n      {\n        return state.map(function (obj) {\n          var item = obj;\n\n          if (item.id === action.id) {\n            item.highlighted = action.highlighted;\n          }\n\n          return item;\n        });\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n}\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = groups;\nexports.defaultState = void 0;\nvar defaultState = [];\nexports.defaultState = defaultState;\n\nfunction groups() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'ADD_GROUP':\n      {\n        return [].concat(state, [{\n          id: action.id,\n          value: action.value,\n          active: action.active,\n          disabled: action.disabled\n        }]);\n      }\n\n    case 'CLEAR_CHOICES':\n      {\n        return [];\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = choices;\nexports.defaultState = void 0;\nvar defaultState = [];\nexports.defaultState = defaultState;\n\nfunction choices() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'ADD_CHOICE':\n      {\n        /*\n            A disabled choice appears in the choice dropdown but cannot be selected\n            A selected choice has been added to the passed input's value (added as an item)\n            An active choice appears within the choice dropdown\n         */\n        return [].concat(state, [{\n          id: action.id,\n          elementId: action.elementId,\n          groupId: action.groupId,\n          value: action.value,\n          label: action.label || action.value,\n          disabled: action.disabled || false,\n          selected: false,\n          active: true,\n          score: 9999,\n          customProperties: action.customProperties,\n          placeholder: action.placeholder || false,\n          keyCode: null\n        }]);\n      }\n\n    case 'ADD_ITEM':\n      {\n        // If all choices need to be activated\n        if (action.activateOptions) {\n          return state.map(function (obj) {\n            var choice = obj;\n            choice.active = action.active;\n            return choice;\n          });\n        } // When an item is added and it has an associated choice,\n        // we want to disable it so it can't be chosen again\n\n\n        if (action.choiceId > -1) {\n          return state.map(function (obj) {\n            var choice = obj;\n\n            if (choice.id === parseInt(action.choiceId, 10)) {\n              choice.selected = true;\n            }\n\n            return choice;\n          });\n        }\n\n        return state;\n      }\n\n    case 'REMOVE_ITEM':\n      {\n        // When an item is removed and it has an associated choice,\n        // we want to re-enable it so it can be chosen again\n        if (action.choiceId > -1) {\n          return state.map(function (obj) {\n            var choice = obj;\n\n            if (choice.id === parseInt(action.choiceId, 10)) {\n              choice.selected = false;\n            }\n\n            return choice;\n          });\n        }\n\n        return state;\n      }\n\n    case 'FILTER_CHOICES':\n      {\n        return state.map(function (obj) {\n          var choice = obj; // Set active state based on whether choice is\n          // within filtered results\n\n          choice.active = action.results.some(function (_ref) {\n            var item = _ref.item,\n                score = _ref.score;\n\n            if (item.id === choice.id) {\n              choice.score = score;\n              return true;\n            }\n\n            return false;\n          });\n          return choice;\n        });\n      }\n\n    case 'ACTIVATE_CHOICES':\n      {\n        return state.map(function (obj) {\n          var choice = obj;\n          choice.active = action.active;\n          return choice;\n        });\n      }\n\n    case 'CLEAR_CHOICES':\n      {\n        return defaultState;\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.defaultState = void 0;\nvar defaultState = {\n  loading: false\n};\nexports.defaultState = defaultState;\n\nvar general = function general() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'SET_IS_LOADING':\n      {\n        return {\n          loading: action.isLoading\n        };\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\n\nvar _default = general;\nexports.default = _default;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Dropdown\", {\n  enumerable: true,\n  get: function get() {\n    return _dropdown.default;\n  }\n});\nObject.defineProperty(exports, \"Container\", {\n  enumerable: true,\n  get: function get() {\n    return _container.default;\n  }\n});\nObject.defineProperty(exports, \"Input\", {\n  enumerable: true,\n  get: function get() {\n    return _input.default;\n  }\n});\nObject.defineProperty(exports, \"List\", {\n  enumerable: true,\n  get: function get() {\n    return _list.default;\n  }\n});\nObject.defineProperty(exports, \"WrappedInput\", {\n  enumerable: true,\n  get: function get() {\n    return _wrappedInput.default;\n  }\n});\nObject.defineProperty(exports, \"WrappedSelect\", {\n  enumerable: true,\n  get: function get() {\n    return _wrappedSelect.default;\n  }\n});\n\nvar _dropdown = _interopRequireDefault(__webpack_require__(21));\n\nvar _container = _interopRequireDefault(__webpack_require__(22));\n\nvar _input = _interopRequireDefault(__webpack_require__(23));\n\nvar _list = _interopRequireDefault(__webpack_require__(24));\n\nvar _wrappedInput = _interopRequireDefault(__webpack_require__(25));\n\nvar _wrappedSelect = _interopRequireDefault(__webpack_require__(26));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Dropdown =\n/*#__PURE__*/\nfunction () {\n  function Dropdown(_ref) {\n    var element = _ref.element,\n        type = _ref.type,\n        classNames = _ref.classNames;\n\n    _classCallCheck(this, Dropdown);\n\n    Object.assign(this, {\n      element: element,\n      type: type,\n      classNames: classNames\n    });\n    this.isActive = false;\n  }\n  /**\n   * Determine how far the top of our element is from\n   * the top of the window\n   * @return {Number} Vertical position\n   */\n\n\n  _createClass(Dropdown, [{\n    key: \"distanceFromTopWindow\",\n    value: function distanceFromTopWindow() {\n      this.dimensions = this.element.getBoundingClientRect();\n      this.position = Math.ceil(this.dimensions.top + window.pageYOffset + this.element.offsetHeight);\n      return this.position;\n    }\n    /**\n     * Find element that matches passed selector\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(selector) {\n      return this.element.querySelector(selector);\n    }\n    /**\n     * Show dropdown to user by adding active state class\n     * @return {Object} Class instance\n     * @public\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.element.classList.add(this.classNames.activeState);\n      this.element.setAttribute('aria-expanded', 'true');\n      this.isActive = true;\n      return this;\n    }\n    /**\n     * Hide dropdown from user\n     * @return {Object} Class instance\n     * @public\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.element.classList.remove(this.classNames.activeState);\n      this.element.setAttribute('aria-expanded', 'false');\n      this.isActive = false;\n      return this;\n    }\n  }]);\n\n  return Dropdown;\n}();\n\nexports.default = Dropdown;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Container =\n/*#__PURE__*/\nfunction () {\n  function Container(_ref) {\n    var element = _ref.element,\n        type = _ref.type,\n        classNames = _ref.classNames,\n        position = _ref.position;\n\n    _classCallCheck(this, Container);\n\n    Object.assign(this, {\n      element: element,\n      classNames: classNames,\n      type: type,\n      position: position\n    });\n    this.isOpen = false;\n    this.isFlipped = false;\n    this.isFocussed = false;\n    this.isDisabled = false;\n    this.isLoading = false;\n    this._onFocus = this._onFocus.bind(this);\n    this._onBlur = this._onBlur.bind(this);\n  }\n  /**\n   * Add event listeners\n   */\n\n\n  _createClass(Container, [{\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      this.element.addEventListener('focus', this._onFocus);\n      this.element.addEventListener('blur', this._onBlur);\n    }\n    /**\n     * Remove event listeners\n     */\n\n    /** */\n\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      this.element.removeEventListener('focus', this._onFocus);\n      this.element.removeEventListener('blur', this._onBlur);\n    }\n    /**\n     * Determine whether container should be flipped\n     * based on passed dropdown position\n     * @param {Number} dropdownPos\n     * @returns\n     */\n\n  }, {\n    key: \"shouldFlip\",\n    value: function shouldFlip(dropdownPos) {\n      var windowHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _utils.getWindowHeight)();\n\n      if (dropdownPos === undefined) {\n        return false;\n      } // If flip is enabled and the dropdown bottom position is\n      // greater than the window height flip the dropdown.\n\n\n      var shouldFlip = false;\n\n      if (this.position === 'auto') {\n        shouldFlip = dropdownPos >= windowHeight;\n      } else if (this.position === 'top') {\n        shouldFlip = true;\n      }\n\n      return shouldFlip;\n    }\n    /**\n     * Set active descendant attribute\n     * @param {Number} activeDescendant ID of active descendant\n     */\n\n  }, {\n    key: \"setActiveDescendant\",\n    value: function setActiveDescendant(activeDescendantID) {\n      this.element.setAttribute('aria-activedescendant', activeDescendantID);\n    }\n    /**\n     * Remove active descendant attribute\n     */\n\n  }, {\n    key: \"removeActiveDescendant\",\n    value: function removeActiveDescendant() {\n      this.element.removeAttribute('aria-activedescendant');\n    }\n  }, {\n    key: \"open\",\n    value: function open(dropdownPos) {\n      this.element.classList.add(this.classNames.openState);\n      this.element.setAttribute('aria-expanded', 'true');\n      this.isOpen = true;\n\n      if (this.shouldFlip(dropdownPos)) {\n        this.element.classList.add(this.classNames.flippedState);\n        this.isFlipped = true;\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.element.classList.remove(this.classNames.openState);\n      this.element.setAttribute('aria-expanded', 'false');\n      this.removeActiveDescendant();\n      this.isOpen = false; // A dropdown flips if it does not have space within the page\n\n      if (this.isFlipped) {\n        this.element.classList.remove(this.classNames.flippedState);\n        this.isFlipped = false;\n      }\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (!this.isFocussed) {\n        this.element.focus();\n      }\n    }\n  }, {\n    key: \"addFocusState\",\n    value: function addFocusState() {\n      this.element.classList.add(this.classNames.focusState);\n    }\n  }, {\n    key: \"removeFocusState\",\n    value: function removeFocusState() {\n      this.element.classList.remove(this.classNames.focusState);\n    }\n    /**\n     * Remove disabled state\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.element.classList.remove(this.classNames.disabledState);\n      this.element.removeAttribute('aria-disabled');\n\n      if (this.type === 'select-one') {\n        this.element.setAttribute('tabindex', '0');\n      }\n\n      this.isDisabled = false;\n    }\n    /**\n     * Set disabled state\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.element.classList.add(this.classNames.disabledState);\n      this.element.setAttribute('aria-disabled', 'true');\n\n      if (this.type === 'select-one') {\n        this.element.setAttribute('tabindex', '-1');\n      }\n\n      this.isDisabled = true;\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(element) {\n      (0, _utils.wrap)(element, this.element);\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap(element) {\n      // Move passed element outside this element\n      this.element.parentNode.insertBefore(element, this.element); // Remove this element\n\n      this.element.parentNode.removeChild(this.element);\n    }\n    /**\n     * Add loading state to element\n     */\n\n  }, {\n    key: \"addLoadingState\",\n    value: function addLoadingState() {\n      this.element.classList.add(this.classNames.loadingState);\n      this.element.setAttribute('aria-busy', 'true');\n      this.isLoading = true;\n    }\n    /**\n     * Remove loading state from element\n     */\n\n  }, {\n    key: \"removeLoadingState\",\n    value: function removeLoadingState() {\n      this.element.classList.remove(this.classNames.loadingState);\n      this.element.removeAttribute('aria-busy');\n      this.isLoading = false;\n    }\n    /**\n     * Set focussed state\n     */\n\n  }, {\n    key: \"_onFocus\",\n    value: function _onFocus() {\n      this.isFocussed = true;\n    }\n    /**\n     * Remove blurred state\n     */\n\n  }, {\n    key: \"_onBlur\",\n    value: function _onBlur() {\n      this.isFocussed = false;\n    }\n  }]);\n\n  return Container;\n}();\n\nexports.default = Container;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(_ref) {\n    var element = _ref.element,\n        type = _ref.type,\n        classNames = _ref.classNames,\n        placeholderValue = _ref.placeholderValue;\n\n    _classCallCheck(this, Input);\n\n    Object.assign(this, {\n      element: element,\n      type: type,\n      classNames: classNames,\n      placeholderValue: placeholderValue\n    });\n    this.element = element;\n    this.classNames = classNames;\n    this.isFocussed = this.element === document.activeElement;\n    this.isDisabled = false;\n    this._onPaste = this._onPaste.bind(this);\n    this._onInput = this._onInput.bind(this);\n    this._onFocus = this._onFocus.bind(this);\n    this._onBlur = this._onBlur.bind(this);\n  }\n\n  _createClass(Input, [{\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      this.element.addEventListener('input', this._onInput);\n      this.element.addEventListener('paste', this._onPaste);\n      this.element.addEventListener('focus', this._onFocus);\n      this.element.addEventListener('blur', this._onBlur);\n\n      if (this.element.form) {\n        this.element.form.addEventListener('reset', this._onFormReset);\n      }\n    }\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      this.element.removeEventListener('input', this._onInput);\n      this.element.removeEventListener('paste', this._onPaste);\n      this.element.removeEventListener('focus', this._onFocus);\n      this.element.removeEventListener('blur', this._onBlur);\n\n      if (this.element.form) {\n        this.element.form.removeEventListener('reset', this._onFormReset);\n      }\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.element.removeAttribute('disabled');\n      this.isDisabled = false;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.element.setAttribute('disabled', '');\n      this.isDisabled = true;\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (!this.isFocussed) {\n        this.element.focus();\n      }\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      if (this.isFocussed) {\n        this.element.blur();\n      }\n    }\n    /**\n     * Set value of input to blank\n     * @return {Object} Class instance\n     * @public\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var setWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.element.value) {\n        this.element.value = '';\n      }\n\n      if (setWidth) {\n        this.setWidth();\n      }\n\n      return this;\n    }\n    /**\n     * Set the correct input width based on placeholder\n     * value or input value\n     * @return\n     */\n\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(enforceWidth) {\n      var _this = this;\n\n      var callback = function callback(width) {\n        _this.element.style.width = width;\n      };\n\n      if (this._placeholderValue) {\n        // If there is a placeholder, we only want to set the width of the input when it is a greater\n        // length than 75% of the placeholder. This stops the input jumping around.\n        var valueHasDesiredLength = this.element.value.length >= this._placeholderValue.length / 1.25;\n\n        if (this.element.value && valueHasDesiredLength || enforceWidth) {\n          this.calcWidth(callback);\n        }\n      } else {\n        // If there is no placeholder, resize input to contents\n        this.calcWidth(callback);\n      }\n    }\n  }, {\n    key: \"calcWidth\",\n    value: function calcWidth(callback) {\n      return (0, _utils.calcWidthOfInput)(this.element, callback);\n    }\n  }, {\n    key: \"setActiveDescendant\",\n    value: function setActiveDescendant(activeDescendantID) {\n      this.element.setAttribute('aria-activedescendant', activeDescendantID);\n    }\n  }, {\n    key: \"removeActiveDescendant\",\n    value: function removeActiveDescendant() {\n      this.element.removeAttribute('aria-activedescendant');\n    }\n  }, {\n    key: \"_onInput\",\n    value: function _onInput() {\n      if (this.type !== 'select-one') {\n        this.setWidth();\n      }\n    }\n  }, {\n    key: \"_onPaste\",\n    value: function _onPaste(event) {\n      var target = event.target;\n\n      if (target === this.element && this.preventPaste) {\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"_onFocus\",\n    value: function _onFocus() {\n      this.isFocussed = true;\n    }\n  }, {\n    key: \"_onBlur\",\n    value: function _onBlur() {\n      this.isFocussed = false;\n    }\n  }, {\n    key: \"placeholder\",\n    set: function set(placeholder) {\n      this.element.placeholder = placeholder;\n    }\n  }, {\n    key: \"value\",\n    set: function set(value) {\n      this.element.value = value;\n    },\n    get: function get() {\n      return (0, _utils.sanitise)(this.element.value);\n    }\n  }]);\n\n  return Input;\n}();\n\nexports.default = Input;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = __webpack_require__(1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar List =\n/*#__PURE__*/\nfunction () {\n  function List(_ref) {\n    var element = _ref.element;\n\n    _classCallCheck(this, List);\n\n    Object.assign(this, {\n      element: element\n    });\n    this.scrollPos = this.element.scrollTop;\n    this.height = this.element.offsetHeight;\n    this.hasChildren = !!this.element.children;\n  }\n\n  _createClass(List, [{\n    key: \"clear\",\n    value: function clear() {\n      this.element.innerHTML = '';\n    }\n  }, {\n    key: \"append\",\n    value: function append(node) {\n      this.element.appendChild(node);\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(selector) {\n      return this.element.querySelector(selector);\n    }\n  }, {\n    key: \"scrollToTop\",\n    value: function scrollToTop() {\n      this.element.scrollTop = 0;\n    }\n  }, {\n    key: \"scrollToChoice\",\n    value: function scrollToChoice(choice, direction) {\n      var _this = this;\n\n      if (!choice) {\n        return;\n      }\n\n      var dropdownHeight = this.element.offsetHeight;\n      var choiceHeight = choice.offsetHeight; // Distance from bottom of element to top of parent\n\n      var choicePos = choice.offsetTop + choiceHeight; // Scroll position of dropdown\n\n      var containerScrollPos = this.element.scrollTop + dropdownHeight; // Difference between the choice and scroll position\n\n      var endpoint = direction > 0 ? this.element.scrollTop + choicePos - containerScrollPos : choice.offsetTop;\n      requestAnimationFrame(function (time) {\n        _this._animateScroll(time, endpoint, direction);\n      });\n    }\n  }, {\n    key: \"_scrollDown\",\n    value: function _scrollDown(scrollPos, strength, endpoint) {\n      var easing = (endpoint - scrollPos) / strength;\n      var distance = easing > 1 ? easing : 1;\n      this.element.scrollTop = scrollPos + distance;\n    }\n  }, {\n    key: \"_scrollUp\",\n    value: function _scrollUp(scrollPos, strength, endpoint) {\n      var easing = (scrollPos - endpoint) / strength;\n      var distance = easing > 1 ? easing : 1;\n      this.element.scrollTop = scrollPos - distance;\n    }\n  }, {\n    key: \"_animateScroll\",\n    value: function _animateScroll(time, endpoint, direction) {\n      var _this2 = this;\n\n      var strength = _constants.SCROLLING_SPEED;\n      var choiceListScrollTop = this.element.scrollTop;\n      var continueAnimation = false;\n\n      if (direction > 0) {\n        this._scrollDown(choiceListScrollTop, strength, endpoint);\n\n        if (choiceListScrollTop < endpoint) {\n          continueAnimation = true;\n        }\n      } else {\n        this._scrollUp(choiceListScrollTop, strength, endpoint);\n\n        if (choiceListScrollTop > endpoint) {\n          continueAnimation = true;\n        }\n      }\n\n      if (continueAnimation) {\n        requestAnimationFrame(function () {\n          _this2._animateScroll(time, endpoint, direction);\n        });\n      }\n    }\n  }]);\n\n  return List;\n}();\n\nexports.default = List;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _wrappedElement = _interopRequireDefault(__webpack_require__(4));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar WrappedInput =\n/*#__PURE__*/\nfunction (_WrappedElement) {\n  _inherits(WrappedInput, _WrappedElement);\n\n  function WrappedInput(_ref) {\n    var _this;\n\n    var element = _ref.element,\n        classNames = _ref.classNames,\n        delimiter = _ref.delimiter;\n\n    _classCallCheck(this, WrappedInput);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WrappedInput).call(this, {\n      element: element,\n      classNames: classNames\n    }));\n    _this.delimiter = delimiter;\n    return _this;\n  }\n\n  _createClass(WrappedInput, [{\n    key: \"value\",\n    set: function set(items) {\n      var itemValues = items.map(function (_ref2) {\n        var value = _ref2.value;\n        return value;\n      });\n      var joinedValues = itemValues.join(this.delimiter);\n      this.element.setAttribute('value', joinedValues);\n      this.element.value = joinedValues;\n    } // @todo figure out why we need this? Perhaps a babel issue\n    ,\n    get: function get() {\n      return _get(_getPrototypeOf(WrappedInput.prototype), \"value\", this);\n    }\n  }]);\n\n  return WrappedInput;\n}(_wrappedElement.default);\n\nexports.default = WrappedInput;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _wrappedElement = _interopRequireDefault(__webpack_require__(4));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar WrappedSelect =\n/*#__PURE__*/\nfunction (_WrappedElement) {\n  _inherits(WrappedSelect, _WrappedElement);\n\n  function WrappedSelect(_ref) {\n    var _this;\n\n    var element = _ref.element,\n        classNames = _ref.classNames,\n        template = _ref.template;\n\n    _classCallCheck(this, WrappedSelect);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WrappedSelect).call(this, {\n      element: element,\n      classNames: classNames\n    }));\n    _this.template = template;\n    return _this;\n  }\n\n  _createClass(WrappedSelect, [{\n    key: \"appendDocFragment\",\n    value: function appendDocFragment(fragment) {\n      this.element.innerHTML = '';\n      this.element.appendChild(fragment);\n    }\n  }, {\n    key: \"placeholderOption\",\n    get: function get() {\n      return this.element.querySelector('option[value=\"\"]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.\n      this.element.querySelector('option[placeholder]');\n    }\n  }, {\n    key: \"optionGroups\",\n    get: function get() {\n      return Array.from(this.element.getElementsByTagName('OPTGROUP'));\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return Array.from(this.element.options);\n    },\n    set: function set(options) {\n      var _this2 = this;\n\n      var fragment = document.createDocumentFragment();\n\n      var addOptionToFragment = function addOptionToFragment(data) {\n        // Create a standard select option\n        var option = _this2.template(data); // Append it to fragment\n\n\n        fragment.appendChild(option);\n      }; // Add each list item to list\n\n\n      options.forEach(function (optionData) {\n        return addOptionToFragment(optionData);\n      });\n      this.appendDocFragment(fragment);\n    }\n  }]);\n\n  return WrappedSelect;\n}(_wrappedElement.default);\n\nexports.default = WrappedSelect;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.TEMPLATES = void 0;\n\nvar _classnames = _interopRequireDefault(__webpack_require__(28));\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TEMPLATES = {\n  containerOuter: function containerOuter(globalClasses, direction, isSelectElement, isSelectOneElement, searchEnabled, passedElementType) {\n    var tabIndex = isSelectOneElement ? 'tabindex=\"0\"' : '';\n    var role = isSelectElement ? 'role=\"listbox\"' : '';\n    var ariaAutoComplete = '';\n\n    if (isSelectElement && searchEnabled) {\n      role = 'role=\"combobox\"';\n      ariaAutoComplete = 'aria-autocomplete=\"list\"';\n    }\n\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(globalClasses.containerOuter, \"\\\"\\n        data-type=\\\"\").concat(passedElementType, \"\\\"\\n        \").concat(role, \"\\n        \").concat(tabIndex, \"\\n        \").concat(ariaAutoComplete, \"\\n        aria-haspopup=\\\"true\\\"\\n        aria-expanded=\\\"false\\\"\\n        dir=\\\"\").concat(direction, \"\\\"\\n        >\\n      </div>\\n    \"));\n  },\n  containerInner: function containerInner(globalClasses) {\n    return (0, _utils.strToEl)(\"\\n      <div class=\\\"\".concat(globalClasses.containerInner, \"\\\"></div>\\n    \"));\n  },\n  itemList: function itemList(globalClasses, isSelectOneElement) {\n    var _classNames;\n\n    var localClasses = (0, _classnames.default)(globalClasses.list, (_classNames = {}, _defineProperty(_classNames, globalClasses.listSingle, isSelectOneElement), _defineProperty(_classNames, globalClasses.listItems, !isSelectOneElement), _classNames));\n    return (0, _utils.strToEl)(\"\\n      <div class=\\\"\".concat(localClasses, \"\\\"></div>\\n    \"));\n  },\n  placeholder: function placeholder(globalClasses, value) {\n    return (0, _utils.strToEl)(\"\\n      <div class=\\\"\".concat(globalClasses.placeholder, \"\\\">\\n        \").concat(value, \"\\n      </div>\\n    \"));\n  },\n  item: function item(globalClasses, data, removeItemButton) {\n    var _classNames2;\n\n    var ariaSelected = data.active ? 'aria-selected=\"true\"' : '';\n    var ariaDisabled = data.disabled ? 'aria-disabled=\"true\"' : '';\n    var localClasses = (0, _classnames.default)(globalClasses.item, (_classNames2 = {}, _defineProperty(_classNames2, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames2, globalClasses.itemSelectable, !data.highlighted), _defineProperty(_classNames2, globalClasses.placeholder, data.placeholder), _classNames2));\n\n    if (removeItemButton) {\n      var _classNames3;\n\n      localClasses = (0, _classnames.default)(globalClasses.item, (_classNames3 = {}, _defineProperty(_classNames3, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames3, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames3, globalClasses.placeholder, data.placeholder), _classNames3));\n      return (0, _utils.strToEl)(\"\\n        <div\\n          class=\\\"\".concat(localClasses, \"\\\"\\n          data-item\\n          data-id=\\\"\").concat(data.id, \"\\\"\\n          data-value=\\\"\").concat(data.value, \"\\\"\\n          data-custom-properties='\").concat(data.customProperties, \"'\\n          data-deletable\\n          \").concat(ariaSelected, \"\\n          \").concat(ariaDisabled, \"\\n          >\\n          \").concat(data.label, \"<!--\\n       --><button\\n            type=\\\"button\\\"\\n            class=\\\"\").concat(globalClasses.button, \"\\\"\\n            data-button\\n            aria-label=\\\"Remove item: '\").concat(data.value, \"'\\\"\\n            >\\n            Remove item\\n          </button>\\n        </div>\\n      \"));\n    }\n\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(localClasses, \"\\\"\\n        data-item\\n        data-id=\\\"\").concat(data.id, \"\\\"\\n        data-value=\\\"\").concat(data.value, \"\\\"\\n        \").concat(ariaSelected, \"\\n        \").concat(ariaDisabled, \"\\n        >\\n        \").concat(data.label, \"\\n      </div>\\n    \"));\n  },\n  choiceList: function choiceList(globalClasses, isSelectOneElement) {\n    var ariaMultiSelectable = !isSelectOneElement ? 'aria-multiselectable=\"true\"' : '';\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(globalClasses.list, \"\\\"\\n        dir=\\\"ltr\\\"\\n        role=\\\"listbox\\\"\\n        \").concat(ariaMultiSelectable, \"\\n        >\\n      </div>\\n    \"));\n  },\n  choiceGroup: function choiceGroup(globalClasses, data) {\n    var ariaDisabled = data.disabled ? 'aria-disabled=\"true\"' : '';\n    var localClasses = (0, _classnames.default)(globalClasses.group, _defineProperty({}, globalClasses.itemDisabled, data.disabled));\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(localClasses, \"\\\"\\n        data-group\\n        data-id=\\\"\").concat(data.id, \"\\\"\\n        data-value=\\\"\").concat(data.value, \"\\\"\\n        role=\\\"group\\\"\\n        \").concat(ariaDisabled, \"\\n        >\\n        <div class=\\\"\").concat(globalClasses.groupHeading, \"\\\">\").concat(data.value, \"</div>\\n      </div>\\n    \"));\n  },\n  choice: function choice(globalClasses, data, itemSelectText) {\n    var _classNames5;\n\n    var role = data.groupId > 0 ? 'role=\"treeitem\"' : 'role=\"option\"';\n    var localClasses = (0, _classnames.default)(globalClasses.item, globalClasses.itemChoice, (_classNames5 = {}, _defineProperty(_classNames5, globalClasses.itemDisabled, data.disabled), _defineProperty(_classNames5, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames5, globalClasses.placeholder, data.placeholder), _classNames5));\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(localClasses, \"\\\"\\n        data-select-text=\\\"\").concat(itemSelectText, \"\\\"\\n        data-choice\\n        data-id=\\\"\").concat(data.id, \"\\\"\\n        data-value=\\\"\").concat(data.value, \"\\\"\\n        \").concat(data.disabled ? 'data-choice-disabled aria-disabled=\"true\"' : 'data-choice-selectable', \"\\n        id=\\\"\").concat(data.elementId, \"\\\"\\n        \").concat(role, \"\\n        >\\n        \").concat(data.label, \"\\n      </div>\\n    \"));\n  },\n  input: function input(globalClasses, placeholderValue) {\n    var localClasses = (0, _classnames.default)(globalClasses.input, globalClasses.inputCloned);\n    return (0, _utils.strToEl)(\"\\n      <input\\n        type=\\\"text\\\"\\n        class=\\\"\".concat(localClasses, \"\\\"\\n        autocomplete=\\\"off\\\"\\n        autocapitalize=\\\"off\\\"\\n        spellcheck=\\\"false\\\"\\n        role=\\\"textbox\\\"\\n        aria-autocomplete=\\\"list\\\"\\n        aria-label=\\\"\").concat(placeholderValue, \"\\\"\\n        >\\n    \"));\n  },\n  dropdown: function dropdown(globalClasses) {\n    var localClasses = (0, _classnames.default)(globalClasses.list, globalClasses.listDropdown);\n    return (0, _utils.strToEl)(\"\\n      <div\\n        class=\\\"\".concat(localClasses, \"\\\"\\n        aria-expanded=\\\"false\\\"\\n        >\\n      </div>\\n    \"));\n  },\n  notice: function notice(globalClasses, label) {\n    var _classNames6;\n\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var localClasses = (0, _classnames.default)(globalClasses.item, globalClasses.itemChoice, (_classNames6 = {}, _defineProperty(_classNames6, globalClasses.noResults, type === 'no-results'), _defineProperty(_classNames6, globalClasses.noChoices, type === 'no-choices'), _classNames6));\n    return (0, _utils.strToEl)(\"\\n      <div class=\\\"\".concat(localClasses, \"\\\">\\n        \").concat(label, \"\\n      </div>\\n    \"));\n  },\n  option: function option(data) {\n    return (0, _utils.strToEl)(\"\\n      <option value=\\\"\".concat(data.value, \"\\\" \").concat(data.active ? 'selected' : '', \" \").concat(data.disabled ? 'disabled' : '', \" \").concat(data.customProperties ? \"data-custom-properties=\".concat(data.customProperties) : '', \">\").concat(data.label, \"</option>\\n    \"));\n  }\n};\nexports.TEMPLATES = TEMPLATES;\nvar _default = TEMPLATES;\nexports.default = _default;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearChoices = exports.activateChoices = exports.filterChoices = exports.addChoice = void 0;\n\nvar _constants = __webpack_require__(1);\n\nvar addChoice = function addChoice(_ref) {\n  var value = _ref.value,\n      label = _ref.label,\n      id = _ref.id,\n      groupId = _ref.groupId,\n      disabled = _ref.disabled,\n      elementId = _ref.elementId,\n      customProperties = _ref.customProperties,\n      placeholder = _ref.placeholder,\n      keyCode = _ref.keyCode;\n  return {\n    type: _constants.ACTION_TYPES.ADD_CHOICE,\n    value: value,\n    label: label,\n    id: id,\n    groupId: groupId,\n    disabled: disabled,\n    elementId: elementId,\n    customProperties: customProperties,\n    placeholder: placeholder,\n    keyCode: keyCode\n  };\n};\n\nexports.addChoice = addChoice;\n\nvar filterChoices = function filterChoices(results) {\n  return {\n    type: _constants.ACTION_TYPES.FILTER_CHOICES,\n    results: results\n  };\n};\n\nexports.filterChoices = filterChoices;\n\nvar activateChoices = function activateChoices() {\n  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  return {\n    type: _constants.ACTION_TYPES.ACTIVATE_CHOICES,\n    active: active\n  };\n};\n\nexports.activateChoices = activateChoices;\n\nvar clearChoices = function clearChoices() {\n  return {\n    type: _constants.ACTION_TYPES.CLEAR_CHOICES\n  };\n};\n\nexports.clearChoices = clearChoices;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.highlightItem = exports.removeItem = exports.addItem = void 0;\n\nvar _constants = __webpack_require__(1);\n\nvar addItem = function addItem(_ref) {\n  var value = _ref.value,\n      label = _ref.label,\n      id = _ref.id,\n      choiceId = _ref.choiceId,\n      groupId = _ref.groupId,\n      customProperties = _ref.customProperties,\n      placeholder = _ref.placeholder,\n      keyCode = _ref.keyCode;\n  return {\n    type: _constants.ACTION_TYPES.ADD_ITEM,\n    value: value,\n    label: label,\n    id: id,\n    choiceId: choiceId,\n    groupId: groupId,\n    customProperties: customProperties,\n    placeholder: placeholder,\n    keyCode: keyCode\n  };\n};\n\nexports.addItem = addItem;\n\nvar removeItem = function removeItem(id, choiceId) {\n  return {\n    type: _constants.ACTION_TYPES.REMOVE_ITEM,\n    id: id,\n    choiceId: choiceId\n  };\n};\n\nexports.removeItem = removeItem;\n\nvar highlightItem = function highlightItem(id, highlighted) {\n  return {\n    type: _constants.ACTION_TYPES.HIGHLIGHT_ITEM,\n    id: id,\n    highlighted: highlighted\n  };\n};\n\nexports.highlightItem = highlightItem;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addGroup = void 0;\n\nvar _constants = __webpack_require__(1);\n\n/* eslint-disable import/prefer-default-export */\nvar addGroup = function addGroup(value, id, active, disabled) {\n  return {\n    type: _constants.ACTION_TYPES.ADD_GROUP,\n    value: value,\n    id: id,\n    active: active,\n    disabled: disabled\n  };\n};\n\nexports.addGroup = addGroup;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resetTo = exports.clearAll = void 0;\n\nvar clearAll = function clearAll() {\n  return {\n    type: 'CLEAR_ALL'\n  };\n};\n\nexports.clearAll = clearAll;\n\nvar resetTo = function resetTo(state) {\n  return {\n    type: 'RESET_TO',\n    state: state\n  };\n};\n\nexports.resetTo = resetTo;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setIsLoading = void 0;\n\n/* eslint-disable import/prefer-default-export */\nvar setIsLoading = function setIsLoading(isLoading) {\n  return {\n    type: 'SET_IS_LOADING',\n    isLoading: isLoading\n  };\n};\n\nexports.setIsLoading = setIsLoading;\n\n/***/ })\n/******/ ]);\n});",null]}