{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/base/Base.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/base/Base.js","mtime":1584368630967},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.join\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.function.name\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.regexp.constructor\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/es.weak-map\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _vanillaTextMask = require(\"vanilla-text-mask\");\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _tooltip = _interopRequireDefault(require(\"tooltip.js\"));\n\nvar FormioUtils = _interopRequireWildcard(require(\"../../utils/utils\"));\n\nvar _Formio = _interopRequireDefault(require(\"../../Formio\"));\n\nvar _Validator = _interopRequireDefault(require(\"../Validator\"));\n\nvar _widgets = _interopRequireDefault(require(\"../../widgets\"));\n\nvar _Component2 = _interopRequireDefault(require(\"../../Component\"));\n\nvar _dragula = _interopRequireDefault(require(\"dragula/dist/dragula\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar CKEDITOR = 'https://cdn.form.io/ckeditor/12.2.0/ckeditor.js';\n/**\n * This is the BaseComponent class which all elements within the FormioForm derive from.\n */\n\nvar BaseComponent =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(BaseComponent, _Component);\n\n  _createClass(BaseComponent, null, [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      return _lodash.default.merge.apply(_lodash.default, [{\n        /**\n         * Determines if this component provides an input.\n         */\n        input: true,\n\n        /**\n         * The data key for this component (how the data is stored in the database).\n         */\n        key: '',\n\n        /**\n         * The input placeholder for this component.\n         */\n        placeholder: '',\n\n        /**\n         * The input prefix\n         */\n        prefix: '',\n\n        /**\n         * The custom CSS class to provide to this component.\n         */\n        customClass: '',\n\n        /**\n         * The input suffix.\n         */\n        suffix: '',\n\n        /**\n         * If this component should allow an array of values to be captured.\n         */\n        multiple: false,\n\n        /**\n         * The default value of this compoennt.\n         */\n        defaultValue: null,\n\n        /**\n         * If the data of this component should be protected (no GET api requests can see the data)\n         */\n        protected: false,\n\n        /**\n         * Validate if the value of this component should be unique within the form.\n         */\n        unique: false,\n\n        /**\n         * If the value of this component should be persisted within the backend api database.\n         */\n        persistent: true,\n\n        /**\n         * Determines if the component should be within the form, but not visible.\n         */\n        hidden: false,\n\n        /**\n         * If the component should be cleared when hidden.\n         */\n        clearOnHide: true,\n\n        /**\n         * If this component should be included as a column within a submission table.\n         */\n        tableView: true,\n\n        /**\n         * If true, will show label when component is in a datagrid.\n         */\n        dataGridLabel: false,\n\n        /**\n         * The input label provided to this component.\n         */\n        label: '',\n        labelPosition: 'top',\n        labelWidth: 30,\n        labelMargin: 3,\n        description: '',\n        errorLabel: '',\n        tooltip: '',\n        hideLabel: false,\n        tabindex: '',\n        disabled: false,\n        autofocus: false,\n        dbIndex: false,\n        customDefaultValue: '',\n        calculateValue: '',\n        allowCalculateOverride: false,\n        widget: null,\n\n        /**\n         * This will refresh this component when this field changes.\n         */\n        refreshOn: '',\n\n        /**\n         * Determines if we should clear our value when a refresh occurs.\n         */\n        clearOnRefresh: false,\n\n        /**\n         * This will perform the validation on either \"change\" or \"blur\" of the input element.\n         */\n        validateOn: 'change',\n\n        /**\n         * The validation criteria for this component.\n         */\n        validate: {\n          /**\n           * If this component is required.\n           */\n          required: false,\n\n          /**\n           * Custom JavaScript validation.\n           */\n          custom: '',\n\n          /**\n           * If the custom validation should remain private (only the backend will see it and execute it).\n           */\n          customPrivate: false\n        },\n\n        /**\n         * The simple conditional settings for a component.\n         */\n        conditional: {\n          show: null,\n          when: null,\n          eq: ''\n        }\n      }].concat(sources));\n    }\n    /**\n     * Provides a table view for this component. Override if you wish to do something different than using getView\n     * method of your instance.\n     *\n     * @param value\n     * @param options\n     */\n\n    /* eslint-disable no-unused-vars */\n\n  }, {\n    key: \"tableView\",\n    value: function tableView(value, options) {}\n    /* eslint-enable no-unused-vars */\n\n    /**\n     * Initialize a new BaseComponent.\n     *\n     * @param {Object} component - The component JSON you wish to initialize.\n     * @param {Object} options - The options for this component.\n     * @param {Object} data - The global data submission object this component will belong.\n     */\n\n    /* eslint-disable max-statements */\n\n  }]);\n\n  function BaseComponent(component, options, data) {\n    var _this;\n\n    _classCallCheck(this, BaseComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseComponent).call(this, options, component && component.id ? component.id : null)); // Determine if we are inside a datagrid.\n\n    _this.inDataGrid = _this.options.inDataGrid;\n    _this.options.inDataGrid = false;\n    /**\n     * Determines if this component has a condition assigned to it.\n     * @type {null}\n     * @private\n     */\n\n    _this._hasCondition = null;\n    /**\n     * A persistent data object that can persist between component instances.\n     */\n\n    _this.persist = {};\n    /**\n     * The data object in which this component resides.\n     * @type {*}\n     */\n\n    _this.data = data || {}; // Allow global override for any component JSON.\n\n    if (_this.options.components && _this.options.components[component.type]) {\n      _lodash.default.merge(component, _this.options.components[component.type]);\n    }\n    /**\n     * The Form.io component JSON schema.\n     * @type {*}\n     */\n\n\n    _this.component = _lodash.default.defaultsDeep(component || {}, _this.defaultSchema); // Add the id to the component.\n\n    _this.component.id = _this.id; // Set the original component.\n\n    _this.originalComponent = _lodash.default.cloneDeep(_this.component);\n    /**\n     * The bounding HTML Element which this component is rendered.\n     * @type {null}\n     */\n\n    _this.element = null;\n    /**\n     * The HTML Element for the table body. This is relevant for the \"multiple\" flag on inputs.\n     * @type {null}\n     */\n\n    _this.tbody = null;\n    /**\n     * The HTMLElement that is assigned to the label of this component.\n     * @type {null}\n     */\n\n    _this.labelElement = null;\n    /**\n     * The HTMLElement for which the errors are rendered for this component (usually underneath the component).\n     * @type {null}\n     */\n\n    _this.errorElement = null;\n    /**\n     * The existing error that this component has.\n     * @type {string}\n     */\n\n    _this.error = '';\n    /**\n     * An array of all of the input HTML Elements that have been added to this component.\n     * @type {Array}\n     */\n\n    _this.inputs = [];\n    /**\n     * The basic component information which tells the BaseComponent how to render the input element of the components that derive from this class.\n     * @type {null}\n     */\n\n    _this.info = null;\n    /**\n     * The row path of this component.\n     * @type {number}\n     */\n\n    _this.row = _this.options.row;\n    /**\n     * Determines if this component is disabled, or not.\n     *\n     * @type {boolean}\n     */\n\n    _this._disabled = false;\n    /**\n     * Determines if this component is visible, or not.\n     */\n\n    _this._visible = true;\n    _this._parentVisible = true;\n    /**\n     * If this input has been input and provided value.\n     *\n     * @type {boolean}\n     */\n\n    _this.pristine = true;\n    /**\n     * Points to the parent component.\n     *\n     * @type {BaseComponent}\n     */\n\n    _this.parent = null;\n    /**\n     * Points to the root component, usually the FormComponent.\n     *\n     * @type {BaseComponent}\n     */\n\n    _this.root = _assertThisInitialized(_this);\n    _this.options.name = _this.options.name || 'data';\n    /**\n     * The validators that are assigned to this component.\n     * @type {[string]}\n     */\n\n    _this.validators = ['required', 'minLength', 'maxLength', 'minWords', 'maxWords', 'custom', 'pattern', 'json', 'mask'];\n    /**\n     * Used to trigger a new change in this component.\n     * @type {function} - Call to trigger a change in this component.\n     */\n\n    var lastChanged = null;\n\n    var _triggerChange = _lodash.default.debounce(function () {\n      var _this2;\n\n      if (_this.root) {\n        _this.root.changing = false;\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (!args[1] && lastChanged) {\n        // Set the changed component if one isn't provided.\n        args[1] = lastChanged;\n      }\n\n      lastChanged = null;\n      return (_this2 = _this).onChange.apply(_this2, args);\n    }, 100);\n\n    _this.triggerChange = function () {\n      if (arguments.length <= 1 ? undefined : arguments[1]) {\n        // Make sure that during the debounce that we always track lastChanged component, even if they\n        // don't provide one later.\n        lastChanged = arguments.length <= 1 ? undefined : arguments[1];\n      }\n\n      if (_this.root) {\n        _this.root.changing = true;\n      }\n\n      return _triggerChange.apply(void 0, arguments);\n    };\n    /**\n     * Used to trigger a redraw event within this component.\n     *\n     * @type {Function}\n     */\n\n\n    _this.triggerRedraw = _lodash.default.debounce(_this.redraw.bind(_assertThisInitialized(_this)), 100); // To force this component to be invalid.\n\n    _this.invalid = false; // Determine if the component has been built.\n\n    _this.isBuilt = false;\n\n    if (_this.component) {\n      _this.type = _this.component.type;\n\n      if (_this.hasInput && _this.key) {\n        _this.options.name += \"[\".concat(_this.key, \"]\");\n      }\n      /**\n       * The element information for creating the input element.\n       * @type {*}\n       */\n\n\n      _this.info = _this.elementInfo();\n    } // Allow anyone to hook into the component creation.\n\n\n    _this.hook('component');\n\n    return _this;\n  }\n  /* eslint-enable max-statements */\n\n\n  _createClass(BaseComponent, [{\n    key: \"getModifiedSchema\",\n\n    /**\n     * Returns only the schema that is different from the default.\n     *\n     * @param schema\n     * @param defaultSchema\n     */\n    value: function getModifiedSchema(schema, defaultSchema) {\n      var _this3 = this;\n\n      var modified = {};\n\n      if (!defaultSchema) {\n        return schema;\n      }\n\n      _lodash.default.each(schema, function (val, key) {\n        if (!_lodash.default.isArray(val) && _lodash.default.isObject(val) && defaultSchema.hasOwnProperty(key)) {\n          var subModified = _this3.getModifiedSchema(val, defaultSchema[key]);\n\n          if (!_lodash.default.isEmpty(subModified)) {\n            modified[key] = subModified;\n          }\n        } else if (key === 'type' || key === 'key' || key === 'label' || key === 'input' || key === 'tableView' || !defaultSchema.hasOwnProperty(key) || _lodash.default.isArray(val) || val !== defaultSchema[key]) {\n          modified[key] = val;\n        }\n      });\n\n      return modified;\n    }\n    /**\n     * Returns the JSON schema for this component.\n     */\n\n  }, {\n    key: \"t\",\n\n    /**\n     * Translate a text using the i18n system.\n     *\n     * @param {string} text - The i18n identifier.\n     * @param {Object} params - The i18n parameters to use for translation.\n     */\n    value: function t(text, params) {\n      params = params || {};\n      params.data = this.rootValue;\n      params.row = this.data;\n      params.component = this.component;\n      return _get(_getPrototypeOf(BaseComponent.prototype), \"t\", this).call(this, text, params);\n    }\n  }, {\n    key: \"performInputMapping\",\n    value: function performInputMapping(input) {\n      return input;\n    }\n  }, {\n    key: \"getBrowserLanguage\",\n    value: function getBrowserLanguage() {\n      var nav = window.navigator;\n      var browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'];\n      var language; // support for HTML 5.1 \"navigator.languages\"\n\n      if (Array.isArray(nav.languages)) {\n        for (var i = 0; i < nav.languages.length; i++) {\n          language = nav.languages[i];\n\n          if (language && language.length) {\n            return language.split(';')[0];\n          }\n        }\n      } // support for other well known properties in browsers\n\n\n      for (var _i = 0; _i < browserLanguagePropertyKeys.length; _i++) {\n        language = nav[browserLanguagePropertyKeys[_i]];\n\n        if (language && language.length) {\n          return language.split(';')[0];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Called before a next page is triggered allowing the components\n     * to perform special functions.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforePage\",\n    value: function beforePage(next) {\n      return _nativePromiseOnly.default.resolve(true);\n    }\n    /**\n     * To maintain reverse compatibility, this is an alias for beforePage(true);\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforeNext\",\n    value: function beforeNext() {\n      return this.beforePage(true);\n    }\n  }, {\n    key: \"beforePrev\",\n    value: function beforePrev() {\n      return this.beforePage(false);\n    }\n    /**\n     * Called before a submission is triggered allowing the components\n     * to perform special async functions.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      return _nativePromiseOnly.default.resolve(true);\n    }\n    /**\n     * Return the submission timezone.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"build\",\n\n    /**\n     * Builds the component.\n     */\n    value: function build(state) {\n      state = state || {};\n      this.calculatedValue = state.calculatedValue;\n\n      if (this.viewOnly) {\n        this.viewOnlyBuild();\n      } else {\n        this.createElement();\n        var labelAtTheBottom = this.component.labelPosition === 'bottom';\n\n        if (!labelAtTheBottom) {\n          this.createLabel(this.element);\n        }\n\n        if (!this.createWrapper()) {\n          this.createInput(this.element);\n        }\n\n        if (labelAtTheBottom) {\n          this.createLabel(this.element);\n        }\n\n        this.createDescription(this.element); // Disable if needed.\n\n        if (this.shouldDisable) {\n          this.disabled = true;\n        } // Restore the value.\n\n\n        this.restoreValue(); // Attach the refresh on events.\n\n        this.attachRefreshOn();\n        this.autofocus();\n      }\n\n      this.attachLogic();\n    }\n  }, {\n    key: \"attachRefreshEvent\",\n    value: function attachRefreshEvent(refreshData) {\n      var _this4 = this;\n\n      this.on('change', function (event) {\n        if (refreshData === 'data') {\n          _this4.refresh(_this4.data);\n        } else if (event.changed && event.changed.component && event.changed.component.key === refreshData & // Make sure the changed component is not in a different \"context\". Solves issues where refreshOn being set\n        // in fields inside EditGrids could alter their state from other rows (which is bad).\n        _this4.inContext(event.changed.instance)) {\n          _this4.refresh(event.changed.value);\n        }\n      }, true);\n    }\n  }, {\n    key: \"attachRefreshOn\",\n    value: function attachRefreshOn() {\n      var _this5 = this;\n\n      // If they wish to refresh on a value, then add that here.\n      if (this.component.refreshOn) {\n        if (Array.isArray(this.component.refreshOn)) {\n          this.component.refreshOn.forEach(function (refreshData) {\n            _this5.attachRefreshEvent(refreshData);\n          });\n        } else {\n          this.attachRefreshEvent(this.component.refreshOn);\n        }\n      }\n    }\n  }, {\n    key: \"viewOnlyBuild\",\n    value: function viewOnlyBuild() {\n      this.createViewOnlyElement();\n      this.createViewOnlyLabel(this.element);\n      this.createViewOnlyValue(this.element);\n    }\n  }, {\n    key: \"createViewOnlyElement\",\n    value: function createViewOnlyElement() {\n      this.element = this.ce('dl', {\n        id: this.id\n      });\n\n      if (this.element) {\n        // Ensure you can get the component info from the element.\n        this.element.component = this;\n      }\n\n      return this.element;\n    }\n  }, {\n    key: \"createViewOnlyLabel\",\n    value: function createViewOnlyLabel(container) {\n      if (this.labelIsHidden()) {\n        return;\n      }\n\n      this.labelElement = this.ce('dt');\n      this.labelElement.appendChild(this.text(this.component.label));\n      this.createTooltip(this.labelElement);\n      container.appendChild(this.labelElement);\n    }\n  }, {\n    key: \"createViewOnlyValue\",\n    value: function createViewOnlyValue(container) {\n      this.valueElement = this.ce('dd');\n      this.setupValueElement(this.valueElement);\n      container.appendChild(this.valueElement);\n    }\n  }, {\n    key: \"setupValueElement\",\n    value: function setupValueElement(element) {\n      var value = this.getValue();\n      value = this.isEmpty(value) ? this.defaultViewOnlyValue : this.getView(value);\n      element.innerHTML = value;\n    }\n  }, {\n    key: \"getView\",\n    value: function getView(value) {\n      if (!value) {\n        return '';\n      }\n\n      var widget = this.widget;\n\n      if (widget && widget.getView) {\n        return widget.getView(value);\n      }\n\n      if (Array.isArray(value)) {\n        return value.join(', ');\n      }\n\n      return value.toString();\n    }\n  }, {\n    key: \"updateItems\",\n    value: function updateItems() {\n      this.restoreValue();\n      this.onChange.apply(this, arguments);\n    }\n  }, {\n    key: \"updateViewOnlyValue\",\n    value: function updateViewOnlyValue() {\n      if (!this.valueElement) {\n        return;\n      }\n\n      this.setupValueElement(this.valueElement);\n    }\n  }, {\n    key: \"createModal\",\n    value: function createModal() {\n      var _this6 = this;\n\n      var modalBody = this.ce('div');\n      var modalOverlay = this.ce('div', {\n        class: 'formio-dialog-overlay'\n      });\n      var closeDialog = this.ce('button', {\n        class: 'formio-dialog-close pull-right btn btn-default btn-xs',\n        'aria-label': 'close'\n      });\n      var modalBodyContainer = this.ce('div', {\n        class: 'formio-dialog-content'\n      }, [modalBody, closeDialog]);\n      var dialog = this.ce('div', {\n        class: 'formio-dialog formio-dialog-theme-default component-settings'\n      }, [modalOverlay, modalBodyContainer]);\n      this.addEventListener(modalOverlay, 'click', function (event) {\n        event.preventDefault();\n        dialog.close();\n      });\n      this.addEventListener(closeDialog, 'click', function (event) {\n        event.preventDefault();\n        dialog.close();\n      });\n      this.addEventListener(dialog, 'close', function () {\n        _this6.removeChildFrom(dialog, document.body);\n      });\n      document.body.appendChild(dialog);\n      document.body.classList.add('modal-open');\n      dialog.body = modalBody;\n      dialog.bodyContainer = modalBodyContainer;\n\n      dialog.close = function () {\n        document.body.classList.remove('modal-open');\n        dialog.dispatchEvent(new CustomEvent('close'));\n\n        _this6.removeChildFrom(dialog, document.body);\n      };\n\n      return dialog;\n    }\n    /**\n     * Retrieves the CSS class name of this component.\n     * @returns {string} - The class name of this component.\n     */\n\n  }, {\n    key: \"getElement\",\n\n    /**\n     * Returns the outside wrapping element of this component.\n     * @returns {HTMLElement}\n     */\n    value: function getElement() {\n      return this.element;\n    }\n    /**\n     * Create the outside wrapping element for this component.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createElement\",\n    value: function createElement() {\n      // If the element is already created, don't recreate.\n      if (this.element) {\n        //update class for case when Logic changed container class (customClass)\n        this.element.className = this.className;\n        return this.element;\n      }\n\n      this.element = this.ce('div', {\n        id: this.id,\n        class: this.className,\n        style: this.customStyle\n      }); // Ensure you can get the component info from the element.\n\n      this.element.component = this;\n      this.hook('element', this.element);\n      return this.element;\n    }\n    /**\n     * Create the input wrapping element. For multiple, this may be the table wrapper for the elements.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"createWrapper\",\n    value: function createWrapper() {\n      if (!this.component.multiple) {\n        return false;\n      } else {\n        var table = this.ce('table', {\n          class: 'table table-bordered'\n        });\n        this.tbody = this.ce('tbody');\n        table.appendChild(this.tbody); // Add a default value.\n\n        var dataValue = this.dataValue;\n\n        if (!dataValue || !dataValue.length) {\n          this.addNewValue(this.defaultValue);\n        } // Build the rows.\n\n\n        this.buildRows();\n        this.setInputStyles(table); // Add the table to the element.\n\n        this.append(table);\n        return true;\n      }\n    }\n  }, {\n    key: \"evalContext\",\n    value: function evalContext(additional) {\n      return _get(_getPrototypeOf(BaseComponent.prototype), \"evalContext\", this).call(this, Object.assign({\n        instance: this,\n        component: this.component,\n        row: this.data,\n        value: this.key && this.hasValue() ? this.dataValue : this.emptyValue,\n        rowIndex: this.rowIndex,\n        data: this.rootValue,\n        submission: this.root ? this.root._submission : {},\n        form: this.root ? this.root._form : {}\n      }, additional));\n    }\n  }, {\n    key: \"setPristine\",\n\n    /**\n     * Sets the pristine flag for this component.\n     *\n     * @param pristine {boolean} - TRUE to make pristine, FALSE not pristine.\n     */\n    value: function setPristine(pristine) {\n      this.pristine = pristine;\n    }\n    /**\n     * Adds a new empty value to the data array.\n     */\n\n  }, {\n    key: \"addNewValue\",\n    value: function addNewValue(value) {\n      if (value === undefined) {\n        value = this.emptyValue;\n      }\n\n      var dataValue = this.dataValue || [];\n\n      if (!Array.isArray(dataValue)) {\n        dataValue = [dataValue];\n      }\n\n      if (Array.isArray(value)) {\n        dataValue = dataValue.concat(value);\n      } else {\n        dataValue.push(value);\n      }\n\n      this.dataValue = dataValue;\n    }\n    /**\n     * Adds a new empty value to the data array, and add a new row to contain it.\n     */\n\n  }, {\n    key: \"addValue\",\n    value: function addValue() {\n      this.addNewValue();\n      this.buildRows();\n      this.checkConditions();\n      this.restoreValue();\n\n      if (this.root) {\n        this.root.onChange();\n      }\n    }\n    /**\n     * Removes a value out of the data array and rebuild the rows.\n     * @param {number} index - The index of the data element to remove.\n     */\n\n  }, {\n    key: \"removeValue\",\n    value: function removeValue(index) {\n      this.splice(index);\n      this.buildRows();\n      this.restoreValue();\n\n      if (this.root) {\n        this.root.onChange();\n      }\n    }\n    /**\n     * Rebuild the rows to contain the values of this component.\n     */\n\n  }, {\n    key: \"buildRows\",\n    value: function buildRows(values) {\n      var _this7 = this;\n\n      if (!this.tbody) {\n        return;\n      }\n\n      var allowReorder = this.allowReorder;\n      this.inputs = [];\n      this.tbody.innerHTML = '';\n      values = values && values.length > 0 ? values : this.dataValue;\n\n      _lodash.default.each(values, function (value, index) {\n        var tr = _this7.ce('tr');\n\n        if (allowReorder) {\n          tr.appendChild(_this7.ce('td', {\n            class: 'formio-drag-column'\n          }, _this7.dragButton()));\n        }\n\n        var td = _this7.ce('td');\n\n        _this7.buildInput(td, value, index);\n\n        tr.appendChild(td);\n\n        if (!_this7.shouldDisable) {\n          var tdAdd = _this7.ce('td', {\n            class: 'formio-remove-column'\n          });\n\n          tdAdd.appendChild(_this7.removeButton(index));\n          tr.appendChild(tdAdd);\n        }\n\n        if (allowReorder) {\n          tr.dragInfo = {\n            index: index\n          };\n        }\n\n        _this7.tbody.appendChild(tr);\n      });\n\n      if (!this.shouldDisable) {\n        var tr = this.ce('tr');\n        var td = this.ce('td', {\n          colspan: allowReorder ? '3' : '2'\n        });\n        td.appendChild(this.addButton());\n        tr.appendChild(td);\n        this.tbody.appendChild(tr);\n      }\n\n      if (this.shouldDisable) {\n        this.disabled = true;\n      }\n\n      if (allowReorder) {\n        this.addDraggable([this.tbody]);\n      }\n    }\n  }, {\n    key: \"addDraggable\",\n    value: function addDraggable(containers) {\n      this.dragula = (0, _dragula.default)(containers, this.getRowDragulaOptions()).on('drop', this.onRowDrop.bind(this));\n    }\n  }, {\n    key: \"getRowDragulaOptions\",\n    value: function getRowDragulaOptions() {\n      return {\n        moves: function moves(draggedElement, oldParent, clickedElement) {\n          //allow dragging only on drag button (not the whole row)\n          return clickedElement.classList.contains('formio-drag-button');\n        }\n      };\n    }\n  }, {\n    key: \"onRowDrop\",\n    value: function onRowDrop(droppedElement, newParent, oldParent, nextSibling) {\n      //move them in data value as well\n      if (!droppedElement.dragInfo || nextSibling && !nextSibling.dragInfo) {\n        console.warn('There is no Drag Info available for either dragged or sibling element');\n        return;\n      }\n\n      var oldPosition = droppedElement.dragInfo.index; //should drop at next sibling position; no next sibling means drop to last position\n\n      var newPosition = nextSibling ? nextSibling.dragInfo.index : this.dataValue.length;\n      var movedBelow = newPosition > oldPosition;\n\n      var dataValue = _lodash.default.cloneDeep(this.dataValue);\n\n      var draggedRowData = dataValue[oldPosition]; //insert element at new position\n\n      dataValue.splice(newPosition, 0, draggedRowData); //remove element from old position (if was moved above, after insertion it's at +1 index)\n\n      dataValue.splice(movedBelow ? oldPosition : oldPosition + 1, 1); //need to re-build rows to re-calculate indexes and other indexed fields for component instance (like rows for ex.)\n\n      this.setValue(dataValue);\n    }\n  }, {\n    key: \"buildInput\",\n    value: function buildInput(container, value) {\n      var input = this.createInput(container);\n      input.value = value;\n    }\n    /**\n     * Adds a new button to add new rows to the multiple input elements.\n     * @returns {HTMLElement} - The \"Add New\" button html element.\n     */\n\n  }, {\n    key: \"addButton\",\n    value: function addButton(justIcon) {\n      var _this8 = this;\n\n      var addButton = this.ce('button', {\n        class: 'btn btn-primary formio-button-add-row'\n      });\n      this.addEventListener(addButton, 'click', function (event) {\n        event.preventDefault();\n\n        _this8.addValue();\n      });\n      var addIcon = this.ce('i', {\n        class: this.iconClass('plus')\n      });\n\n      if (justIcon) {\n        addButton.appendChild(addIcon);\n        return addButton;\n      } else {\n        addButton.appendChild(addIcon);\n        addButton.appendChild(this.text(' '));\n        addButton.appendChild(this.text(this.component.addAnother || 'Add Another'));\n        return addButton;\n      }\n    }\n    /**\n     * The readible name for this component.\n     * @returns {string} - The name of the component.\n     */\n\n  }, {\n    key: \"errorMessage\",\n\n    /**\n     * Get the error message provided a certain type of error.\n     * @param type\n     * @return {*}\n     */\n    value: function errorMessage(type) {\n      return this.component.errors && this.component.errors[type] ? this.component.errors[type] : type;\n    }\n    /**\n     * Creates a new \"remove\" row button and returns the html element of that button.\n     * @param {number} index - The index of the row that should be removed.\n     * @returns {HTMLElement} - The html element of the remove button.\n     */\n\n  }, {\n    key: \"removeButton\",\n    value: function removeButton(index) {\n      var _this9 = this;\n\n      var removeButton = this.ce('button', {\n        type: 'button',\n        class: 'btn btn-default btn-secondary formio-button-remove-row'\n      });\n      this.addEventListener(removeButton, 'click', function (event) {\n        event.preventDefault();\n\n        _this9.removeValue(index);\n      });\n      var removeIcon = this.ce('i', {\n        class: this.iconClass('remove-circle')\n      });\n      removeButton.appendChild(removeIcon);\n      return removeButton;\n    }\n  }, {\n    key: \"dragButton\",\n    value: function dragButton() {\n      return this.ce('button', {\n        class: \"formio-drag-button btn btn-default btn-small \".concat(this.iconClass('menu-hamburger'))\n      });\n    }\n  }, {\n    key: \"labelOnTheLeft\",\n    value: function labelOnTheLeft(position) {\n      return ['left-left', 'left-right'].includes(position);\n    }\n  }, {\n    key: \"labelOnTheRight\",\n    value: function labelOnTheRight(position) {\n      return ['right-left', 'right-right'].includes(position);\n    }\n  }, {\n    key: \"rightAlignedLabel\",\n    value: function rightAlignedLabel(position) {\n      return ['left-right', 'right-right'].includes(position);\n    }\n  }, {\n    key: \"labelOnTheLeftOrRight\",\n    value: function labelOnTheLeftOrRight(position) {\n      return this.labelOnTheLeft(position) || this.labelOnTheRight(position);\n    }\n  }, {\n    key: \"getLabelWidth\",\n    value: function getLabelWidth() {\n      if (!this.component.labelWidth) {\n        this.component.labelWidth = 30;\n      }\n\n      return this.component.labelWidth;\n    }\n  }, {\n    key: \"getLabelMargin\",\n    value: function getLabelMargin() {\n      if (!this.component.labelMargin) {\n        this.component.labelMargin = 3;\n      }\n\n      return this.component.labelMargin;\n    }\n  }, {\n    key: \"setInputStyles\",\n    value: function setInputStyles(input) {\n      if (this.labelIsHidden()) {\n        return;\n      }\n\n      if (this.labelOnTheLeftOrRight(this.component.labelPosition)) {\n        var totalLabelWidth = this.getLabelWidth() + this.getLabelMargin();\n        input.style.width = \"\".concat(100 - totalLabelWidth, \"%\");\n\n        if (this.labelOnTheLeft(this.component.labelPosition)) {\n          input.style.marginLeft = \"\".concat(totalLabelWidth, \"%\");\n        } else {\n          input.style.marginRight = \"\".concat(totalLabelWidth, \"%\");\n        }\n      }\n    }\n  }, {\n    key: \"labelIsHidden\",\n    value: function labelIsHidden() {\n      return !this.component.label || this.component.hideLabel || this.options.inputsOnly || this.inDataGrid && !this.component.dataGridLabel;\n    }\n    /**\n     * Create the HTML element for the label of this component.\n     * @param {HTMLElement} container - The containing element that will contain this label.\n     */\n\n  }, {\n    key: \"createLabel\",\n    value: function createLabel(container) {\n      var isLabelHidden = this.labelIsHidden();\n      var className = 'control-label';\n      var style = '';\n\n      if (!isLabelHidden) {\n        var labelPosition = this.component.labelPosition; // Determine label styles/classes depending on position.\n\n        if (labelPosition === 'bottom') {\n          className += ' control-label--bottom';\n        } else if (labelPosition && labelPosition !== 'top') {\n          var labelWidth = this.getLabelWidth();\n          var labelMargin = this.getLabelMargin(); // Label is on the left or right.\n\n          if (this.labelOnTheLeft(labelPosition)) {\n            style += \"float: left; width: \".concat(labelWidth, \"%; margin-right: \").concat(labelMargin, \"%; \");\n          } else if (this.labelOnTheRight(labelPosition)) {\n            style += \"float: right; width: \".concat(labelWidth, \"%; margin-left: \").concat(labelMargin, \"%; \");\n          }\n\n          if (this.rightAlignedLabel(labelPosition)) {\n            style += 'text-align: right; ';\n          }\n        }\n      } else {\n        this.addClass(container, 'formio-component-label-hidden');\n        className += ' control-label--hidden';\n      }\n\n      if (this.hasInput && this.component.validate && this.component.validate.required) {\n        className += ' field-required';\n      }\n\n      this.labelElement = this.ce('label', {\n        class: className,\n        style: style\n      });\n\n      if (!isLabelHidden) {\n        if (this.info.attr.id) {\n          this.labelElement.setAttribute('for', this.info.attr.id);\n        }\n\n        this.labelElement.appendChild(this.text(this.component.label));\n        this.createTooltip(this.labelElement);\n      }\n\n      container.appendChild(this.labelElement);\n    }\n  }, {\n    key: \"addShortcutToLabel\",\n    value: function addShortcutToLabel(label, shortcut) {\n      if (!label) {\n        label = this.component.label;\n      }\n\n      if (!shortcut) {\n        shortcut = this.component.shortcut;\n      }\n\n      if (!shortcut || !/^[A-Za-z]$/.test(shortcut)) {\n        return label;\n      }\n\n      var match = label.match(new RegExp(shortcut, 'i'));\n\n      if (!match) {\n        return label;\n      }\n\n      var index = match.index + 1;\n      var lowLineCombinator = \"\\u0332\";\n      return label.substring(0, index) + lowLineCombinator + label.substring(index);\n    }\n  }, {\n    key: \"addShortcut\",\n    value: function addShortcut(element, shortcut) {\n      // Avoid infinite recursion.\n      if (this.root === this) {\n        return;\n      }\n\n      if (!element) {\n        element = this.labelElement;\n      }\n\n      if (!shortcut) {\n        shortcut = this.component.shortcut;\n      }\n\n      this.root.addShortcut(element, shortcut);\n    }\n  }, {\n    key: \"removeShortcut\",\n    value: function removeShortcut(element, shortcut) {\n      // Avoid infinite recursion.\n      if (this.root === this) {\n        return;\n      }\n\n      if (!element) {\n        element = this.labelElement;\n      }\n\n      if (!shortcut) {\n        shortcut = this.component.shortcut;\n      }\n\n      this.root.removeShortcut(element, shortcut);\n    }\n    /**\n     * Create the HTML element for the tooltip of this component.\n     * @param {HTMLElement} container - The containing element that will contain this tooltip.\n     */\n\n  }, {\n    key: \"createTooltip\",\n    value: function createTooltip(container, component, classes) {\n      if (this.tooltip) {\n        return;\n      }\n\n      component = component || this.component;\n      classes = classes || \"\".concat(this.iconClass('question-sign'), \" text-muted\");\n\n      if (!component.tooltip) {\n        return;\n      }\n\n      var ttElement = this.ce('i', {\n        class: classes\n      });\n      container.appendChild(this.text(' '));\n      container.appendChild(ttElement);\n      this.tooltip = new _tooltip.default(ttElement, {\n        trigger: 'hover click',\n        placement: 'right',\n        html: true,\n        title: this.interpolate(this.t(component.tooltip)).replace(/(?:\\r\\n|\\r|\\n)/g, '<br />')\n      });\n    }\n    /**\n     * Creates the description block for this input field.\n     * @param container\n     */\n\n  }, {\n    key: \"createDescription\",\n    value: function createDescription(container) {\n      if (!this.component.description) {\n        return;\n      }\n\n      this.description = this.ce('div', {\n        class: 'help-block'\n      });\n      this.description.innerHTML = this.t(this.component.description);\n      container.appendChild(this.description);\n    }\n    /**\n     * Creates a new error element to hold the errors of this element.\n     */\n\n  }, {\n    key: \"createErrorElement\",\n    value: function createErrorElement() {\n      if (!this.errorContainer) {\n        return;\n      }\n\n      this.errorElement = this.ce('div', {\n        class: 'formio-errors invalid-feedback'\n      });\n      this.errorContainer.appendChild(this.errorElement);\n    }\n    /**\n     * Adds a prefix html element.\n     *\n     * @param {HTMLElement} input - The input element.\n     * @param {HTMLElement} inputGroup - The group that will hold this prefix.\n     * @returns {HTMLElement} - The html element for this prefix.\n     */\n\n  }, {\n    key: \"addPrefix\",\n    value: function addPrefix(input, inputGroup) {\n      var prefix = null;\n\n      if (input.widget) {\n        return input.widget.addPrefix(inputGroup);\n      }\n\n      if (this.component.prefix && typeof this.component.prefix === 'string') {\n        prefix = this.ce('div', {\n          class: 'input-group-addon input-group-prepend'\n        });\n        prefix.appendChild(this.ce('span', {\n          class: 'input-group-text'\n        }, this.text(this.component.prefix)));\n        inputGroup.appendChild(prefix);\n      }\n\n      return prefix;\n    }\n    /**\n     * Adds a suffix html element.\n     *\n     * @param {HTMLElement} input - The input element.\n     * @param {HTMLElement} inputGroup - The group that will hold this suffix.\n     * @returns {HTMLElement} - The html element for this suffix.\n     */\n\n  }, {\n    key: \"addSuffix\",\n    value: function addSuffix(input, inputGroup) {\n      var suffix = null;\n\n      if (input.widget) {\n        return input.widget.addSuffix(inputGroup);\n      }\n\n      if (this.component.suffix && typeof this.component.suffix === 'string') {\n        suffix = this.ce('div', {\n          class: 'input-group-addon input-group-append'\n        });\n        suffix.appendChild(this.ce('span', {\n          class: 'input-group-text'\n        }, this.text(this.component.suffix)));\n        inputGroup.appendChild(suffix);\n      }\n\n      return suffix;\n    }\n    /**\n     * Adds a new input group to hold the input html elements.\n     *\n     * @param {HTMLElement} input - The input html element.\n     * @param {HTMLElement} container - The containing html element for this group.\n     * @returns {HTMLElement} - The input group element.\n     */\n\n  }, {\n    key: \"addInputGroup\",\n    value: function addInputGroup(input, container) {\n      var inputGroup = null;\n\n      if (this.component.prefix || this.component.suffix) {\n        inputGroup = this.ce('div', {\n          class: 'input-group'\n        });\n        container.appendChild(inputGroup);\n      }\n\n      return inputGroup;\n    } // Default the mask to the component input mask.\n\n  }, {\n    key: \"setInputMask\",\n    value: function setInputMask(input, inputMask) {\n      return _get(_getPrototypeOf(BaseComponent.prototype), \"setInputMask\", this).call(this, input, inputMask || this.component.inputMask, !this.component.placeholder);\n    }\n    /**\n     * Creates a new input element.\n     * @param {HTMLElement} container - The container which should hold this new input element.\n     * @returns {HTMLElement} - Either the input or the group that contains the input.\n     */\n\n  }, {\n    key: \"createInput\",\n    value: function createInput(container) {\n      var input = this.ce(this.info.type, this.info.attr);\n      this.setInputMask(input);\n      input.widget = this.createWidget();\n      var inputGroup = this.addInputGroup(input, container);\n      this.addPrefix(input, inputGroup);\n      this.addInput(input, inputGroup || container);\n      this.addSuffix(input, inputGroup);\n      this.errorContainer = container;\n      this.setInputStyles(inputGroup || input); // Attach the input to the widget.\n\n      if (input.widget) {\n        input.widget.attach(input);\n      }\n\n      return inputGroup || input;\n    }\n    /**\n     * Returns the instance of the widget for this component.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"createWidget\",\n\n    /**\n     * Creates an instance of a widget for this component.\n     *\n     * @return {null}\n     */\n    value: function createWidget() {\n      var _this10 = this;\n\n      // Return null if no widget is found.\n      if (!this.component.widget) {\n        return null;\n      } // Get the widget settings.\n\n\n      var settings = typeof this.component.widget === 'string' ? {\n        type: this.component.widget\n      } : this.component.widget; // Make sure we have a widget.\n\n      if (!_widgets.default.hasOwnProperty(settings.type)) {\n        return null;\n      } // Pass along some options.\n\n\n      settings.icons = this.options.icons;\n      settings.i18n = this.options.i18n;\n      settings.language = this.options.language; // Add validity method for widget\n\n      if (settings.type === 'calendar') {\n        this.validators.push('calendar');\n\n        settings.checkDataValidity = function () {\n          _this10.setPristine(false);\n\n          return _this10.checkValidity(_this10.data, true);\n        };\n      } // Create the widget.\n\n\n      var widget = new _widgets.default[settings.type](settings, this.component);\n      widget.on('update', function () {\n        return _this10.updateValue();\n      }, true);\n      widget.on('redraw', function () {\n        return _this10.redraw();\n      }, true);\n      this._widget = widget;\n      return widget;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw(shouldRedrawInBuilder) {\n      // Don't bother if we have not built yet.\n      // Don't redraw if it's builder - because component would lose builder buttons\n      if (!this.isBuilt || !shouldRedrawInBuilder && this.options.builder) {\n        return;\n      }\n\n      this.build(this.clear());\n    }\n  }, {\n    key: \"destroyInputs\",\n    value: function destroyInputs() {\n      var _this11 = this;\n\n      _lodash.default.each(this.inputs, function (input) {\n        input = _this11.performInputMapping(input);\n\n        if (input.mask && input.mask.destroy) {\n          input.mask.destroy();\n        }\n\n        if (input.widget) {\n          input.widget.destroy();\n        }\n      });\n\n      if (this.tooltip) {\n        this.tooltip.dispose();\n        this.tooltip = null;\n      }\n\n      this.inputs = [];\n    }\n    /**\n     * Remove all event handlers.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var state = _get(_getPrototypeOf(BaseComponent.prototype), \"destroy\", this).apply(this, arguments) || {};\n      this.destroyInputs();\n      state.calculatedValue = this.calculatedValue;\n      return state;\n    }\n    /**\n     * Render a template string into html.\n     *\n     * @param template\n     * @param data\n     * @param actions\n     *\n     * @return {HTMLElement} - The created element.\n     */\n\n  }, {\n    key: \"renderTemplate\",\n    value: function renderTemplate(template, data) {\n      var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.renderTemplateToElement(this.ce('div'), template, data, actions);\n    }\n  }, {\n    key: \"renderElement\",\n    value: function renderElement(template, data) {\n      var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this.renderTemplate(template, data, actions).firstChild;\n    }\n  }, {\n    key: \"renderTemplateToElement\",\n    value: function renderTemplateToElement(element, template, data) {\n      var actions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      element.innerHTML = this.interpolate(template, data);\n      this.attachActions(element, actions);\n      return element;\n    }\n  }, {\n    key: \"attachActions\",\n    value: function attachActions(element, actions) {\n      actions.forEach(function (action) {\n        var elements = element.getElementsByClassName(action.class);\n        Array.prototype.forEach.call(elements, function (element) {\n          element.addEventListener(action.event, action.action);\n        });\n      });\n    }\n    /**\n     * Determines if this component has a condition defined.\n     *\n     * @return {null}\n     */\n\n  }, {\n    key: \"hasCondition\",\n    value: function hasCondition() {\n      if (this._hasCondition !== null) {\n        return this._hasCondition;\n      }\n\n      this._hasCondition = FormioUtils.hasCondition(this.component);\n      return this._hasCondition;\n    }\n    /**\n     * Check if this component is conditionally visible.\n     *\n     * @param data\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"conditionallyVisible\",\n    value: function conditionallyVisible(data) {\n      data = data || this.rootValue;\n\n      if (this.options.builder || !this.hasCondition()) {\n        return true;\n      }\n\n      return this.checkCondition(null, data);\n    }\n    /**\n     * Checks the condition of this component.\n     *\n     * @param row - The row contextual data.\n     * @param data - The global data object.\n     *\n     * @return {boolean} - True if the condition applies to this component.\n     */\n\n  }, {\n    key: \"checkCondition\",\n    value: function checkCondition(row, data) {\n      return FormioUtils.checkCondition(this.component, row || this.data, data || this.rootValue, this.root ? this.root._form : {}, this);\n    }\n    /**\n     * Check for conditionals and hide/show the element based on those conditions.\n     */\n\n  }, {\n    key: \"checkConditions\",\n    value: function checkConditions(data) {\n      data = data || this.rootValue; // Check advanced conditions\n\n      var result = this.show(this.conditionallyVisible(data));\n\n      if (!this.options.builder && this.fieldLogic(data)) {\n        this.redraw();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"fieldLogic\",\n\n    /**\n     * Check all triggers and apply necessary actions.\n     *\n     * @param data\n     */\n    value: function fieldLogic(data) {\n      var _this12 = this;\n\n      data = data || this.rootValue;\n      var logics = this.logic; // If there aren't logic, don't go further.\n\n      if (logics.length === 0) {\n        return;\n      }\n\n      var newComponent = _lodash.default.cloneDeep(this.originalComponent);\n\n      var changed = logics.reduce(function (changed, logic) {\n        var result = FormioUtils.checkTrigger(newComponent, logic.trigger, _this12.data, data, _this12.root ? _this12.root._form : {}, _this12);\n\n        if (result) {\n          changed |= _this12.applyActions(logic.actions, result, data, newComponent);\n        }\n\n        return changed;\n      }, false); // If component definition changed, replace and mark as changed.\n\n      if (!_lodash.default.isEqual(this.component, newComponent)) {\n        this.component = newComponent;\n        changed = true;\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"applyActions\",\n    value: function applyActions(actions, result, data, newComponent) {\n      var _this13 = this;\n\n      return actions.reduce(function (changed, action) {\n        switch (action.type) {\n          case 'property':\n            FormioUtils.setActionProperty(newComponent, action, _this13.data, data, newComponent, result, _this13);\n\n            if (!_lodash.default.isEqual(_this13, newComponent)) {\n              changed = true;\n            }\n\n            break;\n\n          case 'value':\n            {\n              var oldValue = _this13.getValue();\n\n              var newValue = _this13.evaluate(action.value, {\n                value: _lodash.default.clone(oldValue),\n                data: data,\n                component: newComponent,\n                result: result\n              }, 'value');\n\n              if (!_lodash.default.isEqual(oldValue, newValue)) {\n                _this13.setValue(newValue);\n\n                changed = true;\n              }\n\n              break;\n            }\n\n          case 'validation':\n            // TODO\n            break;\n        }\n\n        return changed;\n      }, false);\n    }\n    /**\n     * Add a new input error to this element.\n     *\n     * @param message\n     * @param dirty\n     */\n\n  }, {\n    key: \"addInputError\",\n    value: function addInputError(message, dirty) {\n      var _this14 = this;\n\n      if (!message) {\n        return;\n      }\n\n      if (this.errorElement) {\n        var errorMessage = this.ce('p', {\n          class: 'help-block'\n        });\n        var entityRegex = /&(:?amp|lt|gt|quot|#39|#x2F);/gi;\n\n        if (message.match(entityRegex)) {\n          errorMessage.innerHTML = message;\n        } else {\n          errorMessage.appendChild(this.text(message));\n        }\n\n        this.errorElement.appendChild(errorMessage);\n      } // Add error classes\n\n\n      this.addClass(this.element, 'has-error');\n      this.inputs.forEach(function (input) {\n        return _this14.addClass(_this14.performInputMapping(input), 'is-invalid');\n      });\n\n      if (dirty && this.options.highlightErrors) {\n        this.addClass(this.element, 'alert alert-danger');\n      }\n    }\n    /**\n     * Checks to see if a separate component is in the \"context\" of this component. This is determined by first checking\n     * if they share the same \"data\" object. It will then walk up the parent tree and compare its parents data objects\n     * with the components data and returns true if they are in the same context.\n     *\n     * Different rows of the same EditGrid, for example, are in different contexts.\n     *\n     * @param component\n     */\n\n  }, {\n    key: \"inContext\",\n    value: function inContext(component) {\n      if (component.data === this.data) {\n        return true;\n      }\n\n      var parent = this.parent;\n\n      while (parent) {\n        if (parent.data === component.data) {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Hide or Show an element.\n     *\n     * @param show\n     */\n\n  }, {\n    key: \"show\",\n    value: function show(_show, noClear) {\n      if (!this.options.builder && this.options.hide && this.options.hide[this.component.key]) {\n        _show = false;\n      } else if (this.options.builder || this.options.show && this.options.show[this.component.key]) {\n        _show = true;\n      } // Execute only if visibility changes or if we are in builder mode or if hidden fields should be shown.\n\n\n      if (!_show === !this._visible || this.options.builder || this.options.showHiddenFields) {\n        if (!_show) {\n          this.clearOnHide(false);\n        }\n\n        return _show;\n      }\n\n      this.visible = _show;\n      this.showElement(_show && !this.component.hidden);\n\n      if (!noClear) {\n        this.clearOnHide(_show);\n      }\n\n      return _show;\n    }\n    /**\n     * Show or hide the root element of this component.\n     *\n     * @param element\n     * @param show\n     */\n\n  }, {\n    key: \"showElement\",\n    value: function showElement(element, show) {\n      if (typeof element === 'boolean') {\n        show = element;\n        element = this.getElement();\n      }\n\n      if (element) {\n        if (show) {\n          element.removeAttribute('hidden');\n          element.style.visibility = 'visible';\n          element.style.position = 'relative';\n        } else if (this.parent && this.parent.parent && this.parent.parent.component.type === 'columns' && this.parent.parent.component.autoAdjust) {\n          element.style.visibility = 'hidden';\n          element.style.position = 'relative';\n        } else {\n          element.setAttribute('hidden', true);\n          element.style.visibility = 'hidden';\n          element.style.position = 'absolute';\n        }\n      }\n\n      return show;\n    }\n  }, {\n    key: \"clearOnHide\",\n    value: function clearOnHide(show) {\n      // clearOnHide defaults to true for old forms (without the value set) so only trigger if the value is false.\n      if (this.component.clearOnHide !== false && !this.options.readOnly) {\n        if (!show) {\n          this.deleteValue();\n        } else if (!this.hasValue()) {\n          // If shown, ensure the default is set.\n          this.setValue(this.defaultValue, {\n            noUpdateEvent: true\n          });\n        }\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(flags, fromRoot) {\n      flags = flags || {};\n\n      if (flags.modified) {\n        // Add a modified class if this element was manually modified.\n        this.pristine = false;\n        this.addClass(this.getElement(), 'formio-modified');\n      } // If we are supposed to validate on blur, then don't trigger validation yet.\n\n\n      if (this.component.validateOn === 'blur' && !this.errors.length) {\n        flags.noValidate = true;\n      }\n\n      if (this.component.onChange) {\n        this.evaluate(this.component.onChange);\n      } // Set the changed variable.\n\n\n      var changed = {\n        instance: this,\n        component: this.component,\n        value: this.dataValue,\n        flags: flags\n      }; // Emit the change.\n\n      this.emit('componentChange', changed); // Bubble this change up to the top.\n\n      if (this.root && !fromRoot) {\n        this.root.triggerChange(flags, changed);\n      }\n    }\n  }, {\n    key: \"addInputSubmitListener\",\n    value: function addInputSubmitListener(input) {\n      var _this15 = this;\n\n      if (!this.options.submitOnEnter) {\n        return;\n      }\n\n      this.addEventListener(input, 'keypress', function (event) {\n        var key = event.keyCode || event.which;\n\n        if (key === 13) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          _this15.emit('submitButton');\n        }\n      });\n    }\n    /**\n     * Add new input element listeners.\n     *\n     * @param input\n     */\n\n  }, {\n    key: \"addInputEventListener\",\n    value: function addInputEventListener(input) {\n      var _this16 = this;\n\n      this.addEventListener(input, this.info.changeEvent, function () {\n        return _this16.updateValue({\n          modified: true\n        });\n      });\n    }\n    /**\n     * Add a new input to this comonent.\n     *\n     * @param input\n     * @param container\n     * @param noSet\n     */\n\n  }, {\n    key: \"addInput\",\n    value: function addInput(input, container) {\n      if (!input) {\n        return;\n      }\n\n      if (input && container) {\n        input = container.appendChild(input);\n      }\n\n      this.inputs.push(input);\n      this.hook('input', input, container);\n      this.addFocusBlurEvents(input);\n      this.addInputEventListener(input);\n      this.addInputSubmitListener(input);\n      return input;\n    }\n  }, {\n    key: \"addFocusBlurEvents\",\n    value: function addFocusBlurEvents(element) {\n      var _this17 = this;\n\n      this.addEventListener(element, 'focus', function () {\n        if (_this17.root.focusedComponent !== _this17) {\n          if (_this17.root.pendingBlur) {\n            _this17.root.pendingBlur();\n          }\n\n          _this17.root.focusedComponent = _this17;\n\n          _this17.emit('focus', _this17);\n        } else if (_this17.root.focusedComponent === _this17 && _this17.root.pendingBlur) {\n          _this17.root.pendingBlur.cancel();\n\n          _this17.root.pendingBlur = null;\n        }\n      });\n      this.addEventListener(element, 'blur', function () {\n        _this17.root.pendingBlur = FormioUtils.delay(function () {\n          _this17.emit('blur', _this17);\n\n          if (_this17.component.validateOn === 'blur') {\n            _this17.root.triggerChange({}, {\n              instance: _this17,\n              component: _this17.component,\n              value: _this17.dataValue,\n              flags: {}\n            });\n          }\n\n          _this17.root.focusedComponent = null;\n          _this17.root.pendingBlur = null;\n        });\n      });\n    }\n  }, {\n    key: \"addCKE\",\n    value: function addCKE(element, settings, onChange) {\n      settings = _lodash.default.isEmpty(settings) ? {} : settings;\n      settings.base64Upload = true;\n      return _Formio.default.requireLibrary('ckeditor', 'ClassicEditor', CKEDITOR, true).then(function () {\n        if (!element.parentNode) {\n          return _nativePromiseOnly.default.reject();\n        }\n\n        return ClassicEditor.create(element, settings).then(function (editor) {\n          editor.model.document.on('change', function () {\n            return onChange(editor.data.get());\n          });\n          return editor;\n        });\n      });\n    }\n  }, {\n    key: \"addQuill\",\n    value: function addQuill(element, settings, onChange) {\n      var _this18 = this;\n\n      settings = _lodash.default.isEmpty(settings) ? this.wysiwygDefault : settings; // Lazy load the quill css.\n\n      _Formio.default.requireLibrary(\"quill-css-\".concat(settings.theme), 'Quill', [{\n        type: 'styles',\n        src: \"https://cdn.quilljs.com/1.3.6/quill.\".concat(settings.theme, \".css\")\n      }], true); // Lazy load the quill library.\n\n\n      return _Formio.default.requireLibrary('quill', 'Quill', 'https://cdn.quilljs.com/1.3.6/quill.min.js', true).then(function () {\n        if (!element.parentNode) {\n          return _nativePromiseOnly.default.reject();\n        }\n\n        _this18.quill = new Quill(element, settings);\n        /** This block of code adds the [source] capabilities.  See https://codepen.io/anon/pen/ZyEjrQ **/\n\n        var txtArea = document.createElement('textarea');\n        txtArea.setAttribute('class', 'quill-source-code');\n\n        _this18.quill.addContainer('ql-custom').appendChild(txtArea);\n\n        var qlSource = element.parentNode.querySelector('.ql-source');\n\n        if (qlSource) {\n          _this18.addEventListener(qlSource, 'click', function (event) {\n            event.preventDefault();\n\n            if (txtArea.style.display === 'inherit') {\n              _this18.quill.setContents(_this18.quill.clipboard.convert(txtArea.value));\n            }\n\n            txtArea.style.display = txtArea.style.display === 'none' ? 'inherit' : 'none';\n          });\n        }\n        /** END CODEBLOCK **/\n        // Make sure to select cursor when they click on the element.\n\n\n        _this18.addEventListener(element, 'click', function () {\n          return _this18.quill.focus();\n        }); // Allows users to skip toolbar items when tabbing though form\n\n\n        var elm = document.querySelectorAll('.ql-formats > button');\n\n        for (var i = 0; i < elm.length; i++) {\n          elm[i].setAttribute('tabindex', '-1');\n        }\n\n        _this18.quill.on('text-change', function () {\n          txtArea.value = _this18.quill.root.innerHTML;\n          onChange(txtArea);\n        });\n\n        return _this18.quill;\n      });\n    }\n    /**\n     * The empty value for this component.\n     *\n     * @return {null}\n     */\n\n  }, {\n    key: \"hasValue\",\n\n    /**\n     * Returns if this component has a value set.\n     *\n     */\n    value: function hasValue(data) {\n      return _lodash.default.has(data || this.data, this.key);\n    }\n    /**\n     * Get the value of this component.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"splice\",\n\n    /**\n     * Splice a value from the dataValue.\n     *\n     * @param index\n     */\n    value: function splice(index) {\n      if (this.hasValue()) {\n        var dataValue = this.dataValue || [];\n\n        if (_lodash.default.isArray(dataValue) && dataValue.hasOwnProperty(index)) {\n          dataValue.splice(index, 1);\n          this.dataValue = dataValue;\n          this.triggerChange();\n        }\n      }\n    }\n    /**\n     * Deletes the value of the component.\n     */\n\n  }, {\n    key: \"deleteValue\",\n    value: function deleteValue() {\n      this.setValue(null, {\n        noUpdateEvent: true,\n        noDefault: true\n      });\n\n      _lodash.default.unset(this.data, this.key);\n    }\n    /**\n     * Get the value at a specific index.\n     *\n     * @param index\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getValueAt\",\n    value: function getValueAt(index) {\n      var input = this.performInputMapping(this.inputs[index]);\n\n      if (input.widget) {\n        return input.widget.getValue();\n      }\n\n      return input ? input.value : undefined;\n    }\n    /**\n     * Get the input value of this component.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (!this.hasInput) {\n        return;\n      }\n\n      if (this.viewOnly) {\n        return this.dataValue;\n      }\n\n      var values = [];\n\n      for (var i in this.inputs) {\n        if (this.inputs.hasOwnProperty(i)) {\n          if (!this.component.multiple) {\n            return this.getValueAt(i);\n          }\n\n          values.push(this.getValueAt(i));\n        }\n      }\n\n      return values;\n    }\n    /**\n     * Determine if the value of this component has changed.\n     *\n     * @param newValue\n     * @param oldValue\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasChanged\",\n    value: function hasChanged(newValue, oldValue) {\n      if ((newValue === undefined || newValue === null) && (oldValue === undefined || oldValue === null || this.isEmpty(oldValue))) {\n        return false;\n      }\n\n      return !_lodash.default.isEqual(newValue, oldValue);\n    }\n    /**\n     * Update the value on change.\n     *\n     * @param flags\n     * @param changed\n     */\n\n  }, {\n    key: \"updateOnChange\",\n    value: function updateOnChange(flags, changed) {\n      if (!flags.noUpdateEvent && changed) {\n        this.triggerChange(flags);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Update a value of this component.\n     *\n     * @param flags\n     */\n\n  }, {\n    key: \"updateValue\",\n    value: function updateValue(flags, value) {\n      if (!this.hasInput) {\n        return false;\n      }\n\n      flags = flags || {};\n      var newValue = value;\n\n      if (!this.visible && this.component.clearOnHide) {\n        newValue = this.dataValue;\n      } else if (value === undefined || value === null) {\n        newValue = this.getValue(flags);\n      }\n\n      var changed = newValue !== undefined ? this.hasChanged(newValue, this.dataValue) : false;\n      this.dataValue = newValue;\n\n      if (this.viewOnly) {\n        this.updateViewOnlyValue(newValue);\n      }\n\n      this.updateOnChange(flags, changed);\n      return changed;\n    }\n  }, {\n    key: \"restoreValue\",\n\n    /**\n     * Restore the value of a control.\n     */\n    value: function restoreValue() {\n      if (this.hasSetValue) {\n        this.setValue(this.dataValue, {\n          noUpdateEvent: true\n        });\n      } else {\n        var defaultValue = this.defaultValue;\n\n        if (!_lodash.default.isNil(defaultValue)) {\n          this.setValue(defaultValue, {\n            noUpdateEvent: true\n          });\n        }\n      }\n    }\n    /**\n     * Perform a calculated value operation.\n     *\n     * @param data - The global data object.\n     *\n     * @return {boolean} - If the value changed during calculation.\n     */\n\n  }, {\n    key: \"calculateValue\",\n    value: function calculateValue(data, flags) {\n      // If no calculated value or\n      // hidden and set to clearOnHide (Don't calculate a value for a hidden field set to clear when hidden)\n      if (!this.component.calculateValue || (!this.visible || this.component.hidden) && this.component.clearOnHide) {\n        return false;\n      } // Get the dataValue.\n\n\n      var firstPass = false;\n      var dataValue = null;\n      var allowOverride = this.component.allowCalculateOverride;\n\n      if (allowOverride) {\n        dataValue = this.dataValue;\n      } // First pass, the calculatedValue is undefined.\n\n\n      if (this.calculatedValue === undefined) {\n        firstPass = true;\n        this.calculatedValue = null;\n      } // Check to ensure that the calculated value is different than the previously calculated value.\n\n\n      if (allowOverride && this.calculatedValue !== null && !_lodash.default.isEqual(dataValue, this.calculatedValue)) {\n        return false;\n      } // Calculate the new value.\n\n\n      var calculatedValue = this.evaluate(this.component.calculateValue, {\n        value: this.defaultValue,\n        data: data\n      }, 'value'); // If this is the firstPass, and the dataValue is different than to the calculatedValue.\n\n      if (allowOverride && firstPass && !this.isEmpty(dataValue) && !_lodash.default.isEqual(dataValue, calculatedValue)) {\n        // Return that we have a change so it will perform another pass.\n        this.calculatedValue = calculatedValue;\n        return true;\n      }\n\n      flags = flags || {};\n      flags.noCheck = true;\n      var changed = this.setValue(calculatedValue, flags);\n      this.calculatedValue = this.dataValue;\n      return changed;\n    }\n    /**\n     * Get this component's label text.\n     *\n     */\n\n  }, {\n    key: \"getRoot\",\n\n    /**\n     * Get FormioForm element at the root of this component tree.\n     *\n     */\n    value: function getRoot() {\n      return this.root;\n    }\n    /**\n     * Returns the invalid message, or empty string if the component is valid.\n     *\n     * @param data\n     * @param dirty\n     * @return {*}\n     */\n\n  }, {\n    key: \"invalidMessage\",\n    value: function invalidMessage(data, dirty, ignoreCondition) {\n      // Force valid if component is conditionally hidden.\n      if (!ignoreCondition && !this.checkCondition(null, data)) {\n        return '';\n      } // See if this is forced invalid.\n\n\n      if (this.invalid) {\n        return this.invalid;\n      } // No need to check for errors if there is no input or if it is pristine.\n\n\n      if (!this.hasInput) {\n        return '';\n      }\n\n      return _Validator.default.check(this, data);\n    }\n    /**\n     * Returns if the component is valid or not.\n     *\n     * @param data\n     * @param dirty\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(data, dirty) {\n      return !this.invalidMessage(data, dirty);\n    }\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity(data, dirty, rowData) {\n      if (this.shouldSkipValidation(data, dirty, rowData)) {\n        this.setCustomValidity('');\n        return true;\n      }\n\n      var error = _Validator.default.check(this, data);\n\n      if (error && (dirty || !this.pristine)) {\n        var message = this.invalidMessage(data, dirty, true);\n        this.setCustomValidity(message, dirty);\n      } else {\n        this.setCustomValidity('');\n      }\n\n      return !error;\n    }\n    /* eslint-disable max-len */\n\n  }, {\n    key: \"getRawValue\",\n    value: function getRawValue() {\n      console.warn('component.getRawValue() has been deprecated. Use component.validationValue or component.dataValue instead.');\n      return this.validationValue;\n    }\n    /* eslint-enable max-len */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(value) {\n      return value == null || value.length === 0 || _lodash.default.isEqual(value, this.emptyValue);\n    }\n    /**\n     * Check if a component is eligible for multiple validation\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"validateMultiple\",\n    value: function validateMultiple(value) {\n      return this.component.multiple && Array.isArray(value);\n    }\n  }, {\n    key: \"setCustomValidity\",\n    value: function setCustomValidity(message, dirty) {\n      var _this19 = this;\n\n      if (this.errorElement && this.errorContainer) {\n        this.errorElement.innerHTML = '';\n        this.removeChildFrom(this.errorElement, this.errorContainer);\n      }\n\n      if (!dirty && this.pristine) {\n        message = '';\n      }\n\n      if (message) {\n        this.error = {\n          component: this.component,\n          message: message\n        };\n        this.emit('componentError', this.error);\n        this.createErrorElement();\n        this.addInputError(message, dirty);\n      } else {\n        this.inputs.forEach(function (input) {\n          return _this19.removeClass(_this19.performInputMapping(input), 'is-invalid');\n        });\n\n        if (this.options.highlightErrors) {\n          this.removeClass(this.element, 'alert alert-danger');\n        }\n\n        this.removeClass(this.element, 'has-error');\n        this.error = null;\n      }\n\n      this.inputs.forEach(function (input) {\n        input = _this19.performInputMapping(input);\n\n        if (typeof input.setCustomValidity === 'function') {\n          input.setCustomValidity(message, dirty);\n        }\n      });\n    }\n  }, {\n    key: \"shouldSkipValidation\",\n    value: function shouldSkipValidation(data, dirty, rowData) {\n      var _this20 = this;\n\n      var rules = [// Force valid if component is hidden.\n      function () {\n        return !_this20.visible;\n      }, // Force valid if component is conditionally hidden.\n      function () {\n        return !_this20.checkCondition(rowData, data);\n      }];\n      return rules.some(function (pred) {\n        return pred();\n      });\n    }\n    /**\n     * Set the value at a specific index.\n     *\n     * @param index\n     * @param value\n     */\n\n  }, {\n    key: \"setValueAt\",\n    value: function setValueAt(index, value, flags) {\n      flags = flags || {};\n\n      if (!flags.noDefault && (value === null || value === undefined)) {\n        value = this.defaultValue;\n      }\n\n      var input = this.performInputMapping(this.inputs[index]);\n\n      if (input.mask) {\n        input.mask.textMaskInputElement.update(value);\n      } else {\n        input.value = value;\n      }\n\n      if (input.widget) {\n        input.widget.setValue(value);\n      }\n    }\n  }, {\n    key: \"getFlags\",\n    value: function getFlags() {\n      return typeof arguments[1] === 'boolean' ? {\n        noUpdateEvent: arguments[1],\n        noValidate: arguments[2]\n      } : arguments[1] || {};\n    } // Maintain reverse compatibility.\n\n  }, {\n    key: \"whenReady\",\n    value: function whenReady() {\n      console.warn('The whenReady() method has been deprecated. Please use the dataReady property instead.');\n      return this.dataReady;\n    }\n  }, {\n    key: \"refresh\",\n\n    /**\n     * Refreshes the component with a new value.\n     *\n     * @param value\n     */\n    value: function refresh(value) {\n      if (this.hasOwnProperty('refreshOnValue')) {\n        this.refreshOnChanged = !_lodash.default.isEqual(value, this.refreshOnValue);\n      } else {\n        this.refreshOnChanged = true;\n      }\n\n      this.refreshOnValue = value;\n\n      if (this.refreshOnChanged) {\n        if (this.component.clearOnRefresh) {\n          this.setValue(null);\n        }\n\n        this.triggerRedraw();\n      }\n    }\n    /**\n     * Set the value of this component.\n     *\n     * @param value\n     * @param flags\n     *\n     * @return {boolean} - If the value changed.\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, flags) {\n      flags = this.getFlags.apply(this, arguments);\n\n      if (!this.hasInput) {\n        return false;\n      }\n\n      if (this.component.multiple && !Array.isArray(value)) {\n        value = value ? [value] : [];\n      }\n\n      this.buildRows(value);\n      var isArray = Array.isArray(value);\n\n      for (var i in this.inputs) {\n        if (this.inputs.hasOwnProperty(i)) {\n          this.setValueAt(i, isArray ? value[i] : value, flags);\n        }\n      }\n\n      return this.updateValue(flags);\n    }\n    /**\n     * Resets the value of this component.\n     */\n\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      this.setValue(this.emptyValue, {\n        noUpdateEvent: true,\n        noValidate: true\n      });\n\n      _lodash.default.unset(this.data, this.key);\n    }\n    /**\n     * Prints out the value of this component as a string value.\n     */\n\n  }, {\n    key: \"asString\",\n    value: function asString(value) {\n      value = value || this.getValue();\n      return Array.isArray(value) ? value.join(', ') : value ? value.toString() : null;\n    }\n    /**\n     * Return if the component is disabled.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"setDisabled\",\n    value: function setDisabled(element, disabled) {\n      element.disabled = disabled;\n\n      if (element.widget) {\n        element.widget.disabled = disabled;\n      }\n\n      if (disabled) {\n        element.setAttribute('disabled', 'disabled');\n      } else {\n        element.removeAttribute('disabled');\n      }\n    }\n  }, {\n    key: \"setLoading\",\n    value: function setLoading(element, loading) {\n      if (element.loading === loading) {\n        return;\n      }\n\n      element.loading = loading;\n\n      if (!element.loader && loading) {\n        element.loader = this.ce('i', {\n          class: \"\".concat(this.iconClass('refresh', true), \" button-icon-right\")\n        });\n      }\n\n      if (element.loader) {\n        if (loading) {\n          this.appendTo(element.loader, element);\n        } else {\n          this.removeChildFrom(element.loader, element);\n        }\n      }\n    }\n  }, {\n    key: \"selectOptions\",\n    value: function selectOptions(select, tag, options, defaultValue) {\n      var _this21 = this;\n\n      _lodash.default.each(options, function (option) {\n        var attrs = {\n          value: option.value\n        };\n\n        if (defaultValue !== undefined && option.value === defaultValue) {\n          attrs.selected = 'selected';\n        }\n\n        var optionElement = _this21.ce('option', attrs);\n\n        optionElement.appendChild(_this21.text(option.label));\n        select.appendChild(optionElement);\n      });\n    }\n  }, {\n    key: \"setSelectValue\",\n    value: function setSelectValue(select, value) {\n      var options = select.querySelectorAll('option');\n\n      _lodash.default.each(options, function (option) {\n        if (option.value === value) {\n          option.setAttribute('selected', 'selected');\n        } else {\n          option.removeAttribute('selected');\n        }\n      });\n\n      if (select.onchange) {\n        select.onchange();\n      }\n\n      if (select.onselect) {\n        select.onchange();\n      }\n    }\n    /**\n     * Destroys and clears a component and returns the current state.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var state = this.destroy() || {};\n      this.empty(this.getElement());\n      return state;\n    }\n    /**\n     * Get the element information.\n     */\n\n  }, {\n    key: \"elementInfo\",\n    value: function elementInfo() {\n      var attributes = {\n        name: this.options.name,\n        type: this.component.inputType || 'text',\n        class: 'form-control',\n        lang: this.options.language,\n        id: this.key || this.id\n      };\n\n      if (this.component.placeholder) {\n        attributes.placeholder = this.t(this.component.placeholder);\n      }\n\n      if (this.component.tabindex) {\n        attributes.tabindex = this.component.tabindex;\n      }\n\n      _lodash.default.defaults(attributes, this.component.attributes);\n\n      return {\n        type: 'input',\n        component: this.component,\n        changeEvent: 'change',\n        attr: attributes\n      };\n    }\n  }, {\n    key: \"autofocus\",\n    value: function autofocus() {\n      var _this22 = this;\n\n      if (this.component.autofocus) {\n        this.on('render', function () {\n          return _this22.focus();\n        }, true);\n      }\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      // Do not focus for readOnly forms.\n      if (this.options.readOnly) {\n        return;\n      }\n\n      var input = this.performInputMapping(this.inputs[0]);\n\n      if (input) {\n        if (input.widget) {\n          input.widget.input.focus();\n        } else {\n          input.focus();\n        }\n      }\n    }\n    /**\n     * Append an element to this elements containing element.\n     *\n     * @param {HTMLElement} element - The DOM element to append to this component.\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(element) {\n      this.appendTo(element, this.element);\n    }\n    /**\n     * Prepend an element to this elements containing element.\n     *\n     * @param {HTMLElement} element - The DOM element to prepend to this component.\n     */\n\n  }, {\n    key: \"prepend\",\n    value: function prepend(element) {\n      this.prependTo(element, this.element);\n    }\n    /**\n     * Removes a child from this component.\n     *\n     * @param {HTMLElement} element - The DOM element to remove from this component.\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(element) {\n      this.removeChildFrom(element, this.element);\n    }\n  }, {\n    key: \"attachLogic\",\n    value: function attachLogic() {\n      var _this23 = this;\n\n      this.logic.forEach(function (logic) {\n        if (logic.trigger.type === 'event') {\n          var event = _this23.interpolate(logic.trigger.event);\n\n          _this23.on(event, function () {\n            var newComponent = _lodash.default.cloneDeep(_this23.originalComponent);\n\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n\n            if (_this23.applyActions(logic.actions, args, _this23.data, newComponent)) {\n              // If component definition changed, replace it.\n              if (!_lodash.default.isEqual(_this23.component, newComponent)) {\n                _this23.component = newComponent;\n              }\n\n              _this23.redraw();\n            }\n          }, true);\n        }\n      });\n    }\n  }, {\n    key: \"hasInput\",\n    get: function get() {\n      return this.component.input || this.inputs.length;\n    }\n  }, {\n    key: \"defaultSchema\",\n    get: function get() {\n      return BaseComponent.schema();\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return _lodash.default.get(this.component, 'key', '');\n    }\n  }, {\n    key: \"currentForm\",\n    get: function get() {\n      return this._currentForm;\n    },\n    set: function set(instance) {\n      this._currentForm = instance;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.getModifiedSchema(_lodash.default.omit(this.component, 'id'), this.defaultSchema);\n    }\n  }, {\n    key: \"submissionTimezone\",\n    get: function get() {\n      this.options.submissionTimezone = this.options.submissionTimezone || _lodash.default.get(this.root, 'options.submissionTimezone');\n      return this.options.submissionTimezone;\n    }\n  }, {\n    key: \"shouldDisable\",\n    get: function get() {\n      return (this.options.readOnly || this.component.disabled) && !this.component.alwaysEnabled;\n    }\n    /**\n     * Helps keep the logic blocks simple to ready.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"canEnable\",\n    get: function get() {\n      return !this.shouldDisable;\n    }\n  }, {\n    key: \"viewOnly\",\n    get: function get() {\n      return this.options.readOnly && this.options.viewAsHtml;\n    }\n  }, {\n    key: \"defaultViewOnlyValue\",\n    get: function get() {\n      return '-';\n    }\n  }, {\n    key: \"className\",\n    get: function get() {\n      var className = this.hasInput ? 'form-group has-feedback ' : '';\n      className += \"formio-component formio-component-\".concat(this.component.type, \" \");\n\n      if (this.key) {\n        className += \"formio-component-\".concat(this.key, \" \");\n      }\n\n      if (this.component.multiple) {\n        className += 'formio-component-multiple ';\n      }\n\n      if (this.component.customClass) {\n        className += this.component.customClass;\n      }\n\n      if (this.hasInput && this.component.validate && this.component.validate.required) {\n        className += ' required';\n      }\n\n      return className;\n    }\n    /**\n     * Build the custom style from the layout values\n     * @return {string} - The custom style\n     */\n\n  }, {\n    key: \"customStyle\",\n    get: function get() {\n      var customCSS = '';\n\n      _lodash.default.each(this.component.style, function (value, key) {\n        if (value !== '') {\n          customCSS += \"\".concat(key, \":\").concat(value, \";\");\n        }\n      });\n\n      return customCSS;\n    }\n  }, {\n    key: \"defaultValue\",\n    get: function get() {\n      var defaultValue = this.emptyValue;\n\n      if (this.component.defaultValue) {\n        defaultValue = this.component.defaultValue;\n      }\n\n      if (this.component.customDefaultValue && !this.options.preview) {\n        defaultValue = this.evaluate(this.component.customDefaultValue, {\n          value: ''\n        }, 'value');\n      }\n\n      if (this._inputMask) {\n        defaultValue = (0, _vanillaTextMask.conformToMask)(defaultValue, this._inputMask).conformedValue;\n\n        if (!FormioUtils.matchInputMask(defaultValue, this._inputMask)) {\n          defaultValue = '';\n        }\n      } // Let the widget provide default value if none is already provided.\n\n\n      if (!defaultValue) {\n        var widget = this.widget;\n\n        if (widget) {\n          defaultValue = widget.defaultValue;\n        }\n      } // Clone so that it creates a new instance.\n\n\n      return _lodash.default.clone(defaultValue);\n    }\n  }, {\n    key: \"allowReorder\",\n    get: function get() {\n      return this.component.reorder && !this.options.readOnly;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.t(this.component.label || this.component.placeholder || this.key);\n    }\n    /**\n     * Returns the error label for this component.\n     * @return {*}\n     */\n\n  }, {\n    key: \"errorLabel\",\n    get: function get() {\n      return this.t(this.component.errorLabel || this.component.label || this.component.placeholder || this.key);\n    }\n  }, {\n    key: \"widget\",\n    get: function get() {\n      if (this._widget) {\n        return this._widget;\n      }\n\n      return this.createWidget();\n    }\n  }, {\n    key: \"logic\",\n    get: function get() {\n      return this.component.logic || [];\n    }\n  }, {\n    key: \"visible\",\n    set: function set(visible) {\n      this._visible = visible;\n    },\n    get: function get() {\n      return this._visible && this._parentVisible;\n    }\n  }, {\n    key: \"parentVisible\",\n    set: function set(value) {\n      if (this._parentVisible !== value) {\n        this._parentVisible = value;\n      }\n    },\n    get: function get() {\n      return this._parentVisible;\n    }\n  }, {\n    key: \"wysiwygDefault\",\n    get: function get() {\n      return {\n        theme: 'snow',\n        placeholder: this.t(this.component.placeholder),\n        modules: {\n          clipboard: {\n            matchVisual: false\n          },\n          toolbar: [[{\n            'size': ['small', false, 'large', 'huge']\n          }], // custom dropdown\n          [{\n            'header': [1, 2, 3, 4, 5, 6, false]\n          }], [{\n            'font': []\n          }], ['bold', 'italic', 'underline', 'strike', {\n            'script': 'sub'\n          }, {\n            'script': 'super'\n          }, 'clean'], [{\n            'color': []\n          }, {\n            'background': []\n          }], [{\n            'list': 'ordered'\n          }, {\n            'list': 'bullet'\n          }, {\n            'indent': '-1'\n          }, {\n            'indent': '+1'\n          }, {\n            'align': []\n          }], ['blockquote', 'code-block'], ['link', 'image', 'video', 'formula', 'source']]\n        }\n      };\n    }\n  }, {\n    key: \"emptyValue\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.dataValue;\n    }\n    /**\n     * Get the data value at the root level.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"rootValue\",\n    get: function get() {\n      return this.root ? this.root.data : this.data;\n    }\n    /**\n     * Get the static value of this component.\n     * @return {*}\n     */\n\n  }, {\n    key: \"dataValue\",\n    get: function get() {\n      if (!this.key) {\n        return this.emptyValue;\n      }\n\n      if (!this.hasValue()) {\n        this.dataValue = this.component.multiple ? [] : this.emptyValue;\n      }\n\n      return _lodash.default.get(this.data, this.key);\n    }\n    /**\n     * Sets the static value of this component.\n     *\n     * @param value\n     */\n    ,\n    set: function set(value) {\n      if (!this.key) {\n        return value;\n      }\n\n      if (value === null || value === undefined) {\n        _lodash.default.unset(this.data, this.key);\n\n        return value;\n      }\n\n      _lodash.default.set(this.data, this.key, value);\n\n      return value;\n    }\n  }, {\n    key: \"hasSetValue\",\n    get: function get() {\n      return this.hasValue() && !this.isEmpty(this.dataValue);\n    }\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this.component.label;\n    }\n    /**\n     * Set this component's label text and render it.\n     *\n     * @param value - The new label text.\n     */\n    ,\n    set: function set(value) {\n      this.component.label = value;\n\n      if (this.labelElement) {\n        this.labelElement.innerText = value;\n      }\n    }\n  }, {\n    key: \"validationValue\",\n    get: function get() {\n      // Let widgets have the first attempt.\n      var widget = this.widget;\n\n      if (widget && widget.validationValue) {\n        return widget.validationValue(this.dataValue);\n      }\n\n      return this.dataValue;\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      return this.error ? [this.error] : [];\n    }\n  }, {\n    key: \"dataReady\",\n    get: function get() {\n      return _nativePromiseOnly.default.resolve();\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this._disabled;\n    }\n    /**\n     * Force a component to be disabled regardless if it should or not.\n     *\n     * @param disabled\n     */\n    ,\n\n    /**\n     * Disable this component.\n     *\n     * @param {boolean} disabled\n     */\n    set: function set(disabled) {\n      // Do not allow a component to be disabled if it should be always...\n      if (!disabled && this.shouldDisable || disabled && !this.shouldDisable) {\n        return;\n      }\n\n      this.forceDisabled = disabled;\n    }\n  }, {\n    key: \"forceDisabled\",\n    set: function set(disabled) {\n      var _this24 = this;\n\n      this._disabled = disabled; // Add/remove the disabled class from the element.\n\n      if (disabled) {\n        this.addClass(this.getElement(), 'formio-disabled-input');\n      } else {\n        this.removeClass(this.getElement(), 'formio-disabled-input');\n      } // Disable all inputs.\n\n\n      _lodash.default.each(this.inputs, function (input) {\n        return _this24.setDisabled(_this24.performInputMapping(input), disabled);\n      });\n    }\n    /**\n     * Helps keep the logic blocks easy to read.\n     * @param enabled\n     */\n\n  }, {\n    key: \"forceEnabled\",\n    set: function set(enabled) {\n      this.forceDisabled = !enabled;\n    }\n  }]);\n\n  return BaseComponent;\n}(_Component2.default);\n\nexports.default = BaseComponent;",null]}