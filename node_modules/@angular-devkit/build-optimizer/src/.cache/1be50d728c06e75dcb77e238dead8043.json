{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/utils/formUtils.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/utils/formUtils.js","mtime":1581861143602},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["\"use strict\";\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.join\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/es.string.match\");\n\nrequire(\"core-js/modules/es.string.replace\");\n\nrequire(\"core-js/modules/es.string.split\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isLayoutComponent = isLayoutComponent;\nexports.eachComponent = eachComponent;\nexports.matchComponent = matchComponent;\nexports.getComponent = getComponent;\nexports.searchComponents = searchComponents;\nexports.findComponents = findComponents;\nexports.findComponent = findComponent;\nexports.removeComponent = removeComponent;\nexports.generateFormChange = generateFormChange;\nexports.applyFormChanges = applyFormChanges;\nexports.flattenComponents = flattenComponents;\nexports.hasCondition = hasCondition;\nexports.parseFloatExt = parseFloatExt;\nexports.formatAsCurrency = formatAsCurrency;\nexports.escapeRegExCharacters = escapeRegExCharacters;\nexports.getValue = getValue;\nexports.getStrings = getStrings;\n\nvar _get = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _set = _interopRequireDefault(require(\"lodash/set\"));\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _clone = _interopRequireDefault(require(\"lodash/clone\"));\n\nvar _forOwn = _interopRequireDefault(require(\"lodash/forOwn\"));\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _isNaN = _interopRequireDefault(require(\"lodash/isNaN\"));\n\nvar _isNil = _interopRequireDefault(require(\"lodash/isNil\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\nvar _round = _interopRequireDefault(require(\"lodash/round\"));\n\nvar _chunk = _interopRequireDefault(require(\"lodash/chunk\"));\n\nvar _pad = _interopRequireDefault(require(\"lodash/pad\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nvar _fastJsonPatch = _interopRequireDefault(require(\"fast-json-patch\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Determine if a component is a layout component or not.\n *\n * @param {Object} component\n *   The component to check.\n *\n * @returns {Boolean}\n *   Whether or not the component is a layout component.\n */\nfunction isLayoutComponent(component) {\n  return Boolean(component.columns && Array.isArray(component.columns) || component.rows && Array.isArray(component.rows) || component.components && Array.isArray(component.components));\n}\n/**\n * Iterate through each component within a form.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Function} fn\n *   The iteration function to invoke for each component.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n * @param {String} path\n *   The current data path of the element. Example: data.user.firstName\n * @param {Object} parent\n *   The parent object.\n */\n\n\nfunction eachComponent(components, fn, includeAll, path, parent) {\n  if (!components) return;\n  path = path || '';\n  components.forEach(function (component) {\n    if (!component) {\n      return;\n    }\n\n    var hasColumns = component.columns && Array.isArray(component.columns);\n    var hasRows = component.rows && Array.isArray(component.rows);\n    var hasComps = component.components && Array.isArray(component.components);\n    var noRecurse = false;\n    var newPath = component.key ? path ? \"\".concat(path, \".\").concat(component.key) : component.key : ''; // Keep track of parent references.\n\n    if (parent) {\n      // Ensure we don't create infinite JSON structures.\n      component.parent = (0, _clone.default)(parent);\n      delete component.parent.components;\n      delete component.parent.componentMap;\n      delete component.parent.columns;\n      delete component.parent.rows;\n    }\n\n    if (includeAll || component.tree || !hasColumns && !hasRows && !hasComps) {\n      noRecurse = fn(component, newPath);\n    }\n\n    var subPath = function subPath() {\n      if (component.key && !['panel', 'table', 'well', 'columns', 'fieldset', 'tabs', 'form'].includes(component.type) && (['datagrid', 'container', 'editgrid'].includes(component.type) || component.tree)) {\n        return newPath;\n      } else if (component.key && component.type === 'form') {\n        return \"\".concat(newPath, \".data\");\n      }\n\n      return path;\n    };\n\n    if (!noRecurse) {\n      if (hasColumns) {\n        component.columns.forEach(function (column) {\n          return eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null);\n        });\n      } else if (hasRows) {\n        component.rows.forEach(function (row) {\n          if (Array.isArray(row)) {\n            row.forEach(function (column) {\n              return eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null);\n            });\n          }\n        });\n      } else if (hasComps) {\n        eachComponent(component.components, fn, includeAll, subPath(), parent ? component : null);\n      }\n    }\n  });\n}\n/**\n * Matches if a component matches the query.\n *\n * @param component\n * @param query\n * @return {boolean}\n */\n\n\nfunction matchComponent(component, query) {\n  if ((0, _isString.default)(query)) {\n    return component.key === query;\n  } else {\n    var matches = false;\n    (0, _forOwn.default)(query, function (value, key) {\n      matches = (0, _get.default)(component, key) === value;\n\n      if (!matches) {\n        return false;\n      }\n    });\n    return matches;\n  }\n}\n/**\n * Get a component by its key\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {String|Object} key\n *   The key of the component to get, or a query of the component to search.\n *\n * @returns {Object}\n *   The component that matches the given key, or undefined if not found.\n */\n\n\nfunction getComponent(components, key, includeAll) {\n  var result;\n  eachComponent(components, function (component, path) {\n    if (path === key) {\n      component.path = path;\n      result = component;\n      return true;\n    }\n  }, includeAll);\n  return result;\n}\n/**\n * Finds a component provided a query of properties of that component.\n *\n * @param components\n * @param query\n * @return {*}\n */\n\n\nfunction searchComponents(components, query) {\n  var results = [];\n  eachComponent(components, function (component, path) {\n    if (matchComponent(component, query)) {\n      component.path = path;\n      results.push(component);\n    }\n  }, true);\n  return results;\n}\n/**\n * Deprecated version of findComponents. Renamed to searchComponents.\n *\n * @param components\n * @param query\n * @returns {*}\n */\n\n\nfunction findComponents(components, query) {\n  console.warn('formio.js/utils findComponents is deprecated. Use searchComponents instead.');\n  return searchComponents(components, query);\n}\n\nvar possibleFind = null;\nvar possiblePath = [];\nvar unknownCounter = {};\n\nvar checkComponent = function checkComponent(component, key, path) {\n  // Search for components without a key as well.\n  if (!component.key) {\n    if (!unknownCounter.hasOwnProperty(component.type)) {\n      unknownCounter[component.type] = 0;\n    }\n\n    unknownCounter[component.type]++;\n\n    if (key === component.type + unknownCounter[component.type]) {\n      possibleFind = component;\n      possiblePath = (0, _clone.default)(path);\n    }\n  } else if (possibleFind && component.key === possibleFind.key) {\n    var nextCount = component.key.match(/([0-9]+)$/g);\n\n    if (nextCount) {\n      unknownCounter[component.type] = parseInt(nextCount.pop(), 10);\n      possibleFind = null;\n      possiblePath = [];\n    }\n  }\n\n  if (component.key === key) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * This function will find a component in a form and return the component AND THE PATH to the component in the form.\n *\n * @param components\n * @param key\n * @param fn\n * @param path\n * @returns boolean - If the component was found.\n */\n\n\nfunction findComponent(components, key, path, fn) {\n  if (!components || !key) {\n    return false;\n  }\n\n  if (typeof path === 'function') {\n    fn = path;\n    path = [];\n  }\n\n  path = path || [];\n\n  if (!path.length) {\n    // Reset search params.\n    possibleFind = null;\n    possiblePath = [];\n    unknownCounter = {};\n  }\n\n  var found = false;\n  components.forEach(function (component, index) {\n    var newPath = path.slice();\n    newPath.push(index);\n    if (!component) return;\n\n    if (component.hasOwnProperty('columns') && Array.isArray(component.columns)) {\n      newPath.push('columns');\n      component.columns.forEach(function (column, index) {\n        var colPath = newPath.slice();\n        colPath.push(index);\n        column.type = 'column';\n\n        if (checkComponent(column, key, colPath)) {\n          found = true;\n          fn(column, colPath);\n        } else if (findComponent(column.components, key, colPath.concat(['components']), fn)) {\n          found = true;\n        }\n      });\n    }\n\n    if (component.hasOwnProperty('rows') && Array.isArray(component.rows)) {\n      newPath.push('rows');\n      component.rows.forEach(function (row, index) {\n        var rowPath = newPath.slice();\n        rowPath.push(index);\n        row.forEach(function (column, index) {\n          var colPath = rowPath.slice();\n          colPath.push(index);\n          column.type = 'cell';\n\n          if (checkComponent(column, key, colPath)) {\n            found = true;\n            fn(column, colPath);\n          } else if (findComponent(column.components, key, colPath.concat(['components']), fn)) {\n            found = true;\n          }\n        });\n      });\n    }\n\n    if (component.hasOwnProperty('components') && Array.isArray(component.components) && findComponent(component.components, key, newPath.concat(['components']), fn)) {\n      found = true;\n    } // Check this component.\n\n\n    if (checkComponent(component, key, newPath)) {\n      found = true;\n      fn(component, newPath);\n    }\n  }); // If the component was not found BUT there was a possibility then return it.\n\n  if (!path.length && !found && possibleFind) {\n    found = true;\n    fn(possibleFind, possiblePath);\n  } // Return if this if found.\n\n\n  return found;\n}\n/**\n * Remove a component by path.\n *\n * @param components\n * @param path\n */\n\n\nfunction removeComponent(components, path) {\n  // Using _.unset() leave a null value. Use Array splice instead.\n  var index = path.pop();\n\n  if (path.length !== 0) {\n    components = (0, _get.default)(components, path);\n  }\n\n  components.splice(index, 1);\n}\n\nfunction generateFormChange(type, data) {\n  var change = null;\n  var schema = data.schema;\n\n  switch (type) {\n    case 'add':\n      change = {\n        op: 'add',\n        key: schema.key,\n        container: data.parent.key,\n        index: (0, _findIndex.default)(data.parent.components, {\n          id: data.id\n        }),\n        component: schema\n      };\n      break;\n\n    case 'edit':\n      change = {\n        op: 'edit',\n        key: schema.key,\n        patches: _fastJsonPatch.default.compare(data.originalComponent, schema)\n      }; // Don't save if nothing changed.\n\n      if (!change.patches.length) {\n        change = null;\n      }\n\n      break;\n\n    case 'remove':\n      change = {\n        op: 'remove',\n        key: schema.key\n      };\n      break;\n  }\n\n  return change;\n} // Get the parent component provided a component key.\n\n\nvar getParent = function getParent(form, key, fn) {\n  if (!findComponent(form.components, key, null, fn)) {\n    // Return the root form if no parent is found so it will add the component to the root form.\n    fn(form);\n  }\n};\n\nfunction applyFormChanges(form, changes) {\n  var failed = [];\n  changes.forEach(function (change) {\n    var found = false;\n\n    switch (change.op) {\n      case 'add':\n        var newComponent = change.component;\n        getParent(form, change.container, function (parent) {\n          // A move will first run an add so remove any existing components with matching key before inserting.\n          findComponent(form.components, change.key, null, function (component, path) {\n            // If found, use the existing component. (If someone else edited it, the changes would be here)\n            newComponent = component;\n            removeComponent(form.components, path);\n          });\n          found = true;\n          parent.components.splice(change.index, 0, newComponent);\n        });\n        break;\n\n      case 'remove':\n        findComponent(form.components, change.key, null, function (component, path) {\n          found = true;\n          removeComponent(form.components, path);\n        });\n        break;\n\n      case 'edit':\n        findComponent(form.components, change.key, null, function (component, path) {\n          found = true;\n\n          try {\n            (0, _set.default)(form.components, path, _fastJsonPatch.default.applyPatch(component, change.patches).newDocument);\n          } catch (err) {\n            failed.push(change);\n          }\n        });\n        break;\n\n      case 'move':\n        break;\n    }\n\n    if (!found) {\n      failed.push(change);\n    }\n  });\n  return {\n    form: form,\n    failed: failed\n  };\n}\n/**\n * Flatten the form components for data manipulation.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n *\n * @returns {Object}\n *   The flattened components map.\n */\n\n\nfunction flattenComponents(components, includeAll) {\n  var flattened = {};\n  eachComponent(components, function (component, path) {\n    flattened[path] = component;\n  }, includeAll);\n  return flattened;\n}\n/**\n * Returns if this component has a conditional statement.\n *\n * @param component - The component JSON schema.\n *\n * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.\n */\n\n\nfunction hasCondition(component) {\n  return Boolean(component.customConditional || component.conditional && component.conditional.when || component.conditional && component.conditional.json);\n}\n/**\n * Extension of standard #parseFloat(value) function, that also clears input string.\n *\n * @param {any} value\n *   The value to parse.\n *\n * @returns {Number}\n *   Parsed value.\n */\n\n\nfunction parseFloatExt(value) {\n  return parseFloat((0, _isString.default)(value) ? value.replace(/[^\\de.+-]/gi, '') : value);\n}\n/**\n * Formats provided value in way how Currency component uses it.\n *\n * @param {any} value\n *   The value to format.\n *\n * @returns {String}\n *   Value formatted for Currency component.\n */\n\n\nfunction formatAsCurrency(value) {\n  var parsedValue = parseFloatExt(value);\n\n  if ((0, _isNaN.default)(parsedValue)) {\n    return '';\n  }\n\n  var parts = (0, _round.default)(parsedValue, 2).toString().split('.');\n  parts[0] = (0, _chunk.default)(Array.from(parts[0]).reverse(), 3).reverse().map(function (part) {\n    return part.reverse().join('');\n  }).join(',');\n  parts[1] = (0, _pad.default)(parts[1], 2, '0');\n  return parts.join('.');\n}\n/**\n * Escapes RegEx characters in provided String value.\n *\n * @param {String} value\n *   String for escaping RegEx characters.\n * @returns {string}\n *   String with escaped RegEx characters.\n */\n\n\nfunction escapeRegExCharacters(value) {\n  return value.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n/**\n * Get the value for a component key, in the given submission.\n *\n * @param {Object} submission\n *   A submission object to search.\n * @param {String} key\n *   A for components API key to search for.\n */\n\n\nfunction getValue(submission, key) {\n  var search = function search(data) {\n    if ((0, _isPlainObject.default)(data)) {\n      if ((0, _has.default)(data, key)) {\n        return data[key];\n      }\n\n      var value = null;\n      (0, _forOwn.default)(data, function (prop) {\n        var result = search(prop);\n\n        if (!(0, _isNil.default)(result)) {\n          value = result;\n          return false;\n        }\n      });\n      return value;\n    } else {\n      return null;\n    }\n  };\n\n  return search(submission.data);\n}\n/**\n * Iterate over all components in a form and get string values for translation.\n * @param form\n */\n\n\nfunction getStrings(form) {\n  var _this = this;\n\n  var properties = ['label', 'title', 'legend', 'tooltip', 'description', 'placeholder', 'prefix', 'suffix', 'errorLabel', 'content', 'html'];\n  var strings = [];\n  eachComponent(form.components, function (component) {\n    properties.forEach(function (property) {\n      if (component.hasOwnProperty(property) && component[property]) {\n        strings.push({\n          key: component.key,\n          type: component.type,\n          property: property,\n          string: component[property]\n        });\n      }\n    });\n\n    if ((!component.dataSrc || component.dataSrc === 'values') && component.hasOwnProperty('values') && Array.isArray(component.values) && component.values.length) {\n      component.values.forEach(function (value, index) {\n        strings.push({\n          key: component.key,\n          property: \"value[\".concat(index, \"].label\"),\n          string: component.values[index].label\n        });\n      });\n    } // Hard coded values from Day component\n\n\n    if (component.type === 'day') {\n      ['day', 'month', 'year', 'Day', 'Month', 'Year', 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'].forEach(function (string) {\n        strings.push({\n          key: component.key,\n          property: 'day',\n          string: string\n        });\n      });\n\n      if (component.fields.day.placeholder) {\n        strings.push({\n          key: component.key,\n          property: 'fields.day.placeholder',\n          string: component.fields.day.placeholder\n        });\n      }\n\n      if (component.fields.month.placeholder) {\n        strings.push({\n          key: component.key,\n          property: 'fields.month.placeholder',\n          string: component.fields.month.placeholder\n        });\n      }\n\n      if (component.fields.year.placeholder) {\n        strings.push({\n          key: component.key,\n          property: 'fields.year.placeholder',\n          string: component.fields.year.placeholder\n        });\n      }\n    }\n\n    if (component.type === 'editgrid') {\n      var string = _this.component.addAnother || 'Add Another';\n\n      if (component.addAnother) {\n        strings.push({\n          key: component.key,\n          property: 'addAnother',\n          string: string\n        });\n      }\n    }\n\n    if (component.type === 'select') {\n      ['loading...', 'Type to search'].forEach(function (string) {\n        strings.push({\n          key: component.key,\n          property: 'select',\n          string: string\n        });\n      });\n    }\n  }, true);\n  return strings;\n}",null]}