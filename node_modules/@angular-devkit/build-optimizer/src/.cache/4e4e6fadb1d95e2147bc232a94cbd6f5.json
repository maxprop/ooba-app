{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/price-ranges/connectPriceRanges.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/price-ranges/connectPriceRanges.js","mtime":1581861144636},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _.._lib_utils.js,_generate_ranges.js,lodash_isFinite PURE_IMPORTS_END */\nvar _slicedToArray = /*@__PURE__*/ function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n            break;\n    }\n}\ncatch (err) {\n    _d = true;\n    _e = err;\n}\nfinally {\n    try {\n        if (!_n && _i[\"return\"])\n            _i[\"return\"]();\n    }\n    finally {\n        if (_d)\n            throw _e;\n    }\n} return _arr; } return function (arr, i) { if (Array.isArray(arr)) {\n    return arr;\n}\nelse if (Symbol.iterator in Object(arr)) {\n    return sliceIterator(arr, i);\n}\nelse {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} }; }();\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nfunction _defineProperty(obj, key, value) { if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n}\nelse {\n    obj[key] = value;\n} return obj; }\nimport { checkRendering } from '../../lib/utils.js';\nimport generateRanges from './generate-ranges.js';\nimport isFinite from 'lodash/isFinite';\nvar usage = 'Usage:\\nvar customPriceRanges = connectPriceRanges(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   refine,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  // }\\n});\\nsearch.addWidget(\\n  customPriceRanges({\\n    attributeName,\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectPriceRanges.html\\n';\n/**\n * @typedef {Object} PriceRangesItem\n * @property {number} [from] Lower bound of the price range.\n * @property {number} [to] Higher bound of the price range.\n * @property {string} url The URL for a single item in the price range.\n */\n/**\n * @typedef {Object} CustomPriceRangesWidgetOptions\n * @property {string} attributeName Name of the attribute for faceting.\n */\n/**\n * @typedef {Object} PriceRangesRenderingOptions\n * @property {PriceRangesItem[]} items The prices ranges to display.\n * @property {function(PriceRangesItem)} refine Selects or unselects a price range and trigger a search.\n * @property {Object} widgetParams All original `CustomPriceRangesWidgetOptions` forwarded to the `renderFn`.\n */\n/**\n * **PriceRanges** connector provides the logic to build a custom widget that will let\n * the user refine results based on price ranges.\n *\n * @type {Connector}\n * @param {function(PriceRangesRenderingOptions, boolean)} renderFn Rendering function for the custom **PriceRanges** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomPriceRangesWidgetOptions)} Re-usable widget factory for a custom **PriceRanges** widget.\n * @example\n * function getLabel(item) {\n *   var from = item.from;\n *   var to = item.to;\n *\n *   if (to === undefined) return '≥ $' + from;\n *   if (from === undefined) return '≤ $' + to;\n *   return '$' + from + ' - $' + to;\n * }\n *\n * // custom `renderFn` to render the custom PriceRanges widget\n * function renderFn(PriceRangesRenderingOptions, isFirstRendering) {\n *   if (isFirstRendering) {\n *     PriceRangesRenderingOptions.widgetParams.containerNode.html('<ul></ul>');\n *   }\n *\n *   PriceRangesRenderingOptions.widgetParams.containerNode\n *     .find('ul > li')\n *     .each(function() { $(this).off('click'); });\n *\n *   var list = PriceRangesRenderingOptions.items.map(function(item) {\n *     return '<li><a href=\"' + item.url + '\">' + getLabel(item) + '</a></li>';\n *   });\n *\n *   PriceRangesRenderingOptions.widgetParams.containerNode\n *     .find('ul')\n *     .html(list);\n *\n *   PriceRangesRenderingOptions.widgetParams.containerNode\n *     .find('li')\n *     .each(function(index) {\n *       $(this).on('click', function(event) {\n *         event.stopPropagation();\n *         event.preventDefault();\n *\n *         PriceRangesRenderingOptions.refine(\n *           PriceRangesRenderingOptions.items[index]\n *         );\n *       });\n *     });\n * }\n *\n * // connect `renderFn` to PriceRanges logic\n * var customPriceRanges = instantsearch.connectors.connectPriceRanges(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customPriceRanges({\n *     containerNode: $('#custom-price-ranges-container'),\n *     attributeName: 'price',\n *   })\n * );\n */\nexport default function connectPriceRanges(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attributeName = widgetParams.attributeName;\n        if (!attributeName) {\n            throw new Error(usage);\n        }\n        return {\n            getConfiguration: function getConfiguration() {\n                return { facets: [attributeName] };\n            },\n            _generateRanges: function _generateRanges(results) {\n                var stats = results.getFacetStats(attributeName);\n                return generateRanges(stats);\n            },\n            _extractRefinedRange: function _extractRefinedRange(helper) {\n                var refinements = helper.getRefinements(attributeName);\n                var from = void 0;\n                var to = void 0;\n                if (refinements.length === 0) {\n                    return [];\n                }\n                refinements.forEach(function (v) {\n                    if (v.operator.indexOf('>') !== -1) {\n                        from = Math.floor(v.value[0]);\n                    }\n                    else if (v.operator.indexOf('<') !== -1) {\n                        to = Math.ceil(v.value[0]);\n                    }\n                });\n                return [{ from: from, to: to, isRefined: true }];\n            },\n            _refine: function _refine(helper, _ref) {\n                var from = _ref.from, to = _ref.to;\n                var facetValues = this._extractRefinedRange(helper);\n                helper.clearRefinements(attributeName);\n                if (facetValues.length === 0 || facetValues[0].from !== from || facetValues[0].to !== to) {\n                    if (typeof from !== 'undefined') {\n                        helper.addNumericRefinement(attributeName, '>=', Math.floor(from));\n                    }\n                    if (typeof to !== 'undefined') {\n                        helper.addNumericRefinement(attributeName, '<=', Math.ceil(to));\n                    }\n                }\n                helper.search();\n            },\n            init: function init(_ref2) {\n                var _this = this;\n                var helper = _ref2.helper, instantSearchInstance = _ref2.instantSearchInstance;\n                this.refine = function (opts) {\n                    _this._refine(helper, opts);\n                };\n                renderFn({\n                    instantSearchInstance: instantSearchInstance,\n                    items: [],\n                    refine: this.refine,\n                    widgetParams: widgetParams\n                }, true);\n            },\n            render: function render(_ref3) {\n                var results = _ref3.results, helper = _ref3.helper, state = _ref3.state, createURL = _ref3.createURL, instantSearchInstance = _ref3.instantSearchInstance;\n                var facetValues = void 0;\n                if (results && results.hits && results.hits.length > 0) {\n                    facetValues = this._extractRefinedRange(helper);\n                    if (facetValues.length === 0) {\n                        facetValues = this._generateRanges(results);\n                    }\n                }\n                else {\n                    facetValues = [];\n                }\n                facetValues.map(function (facetValue) {\n                    var newState = state.clearRefinements(attributeName);\n                    if (!facetValue.isRefined) {\n                        if (facetValue.from !== undefined) {\n                            newState = newState.addNumericRefinement(attributeName, '>=', Math.floor(facetValue.from));\n                        }\n                        if (facetValue.to !== undefined) {\n                            newState = newState.addNumericRefinement(attributeName, '<=', Math.ceil(facetValue.to));\n                        }\n                    }\n                    facetValue.url = createURL(newState);\n                    return facetValue;\n                });\n                renderFn({\n                    items: facetValues,\n                    refine: this.refine,\n                    widgetParams: widgetParams,\n                    instantSearchInstance: instantSearchInstance\n                }, false);\n            },\n            dispose: function dispose(_ref4) {\n                var state = _ref4.state;\n                unmountFn();\n                var nextState = state.removeFacetRefinement(attributeName).removeFacet(attributeName);\n                return nextState;\n            },\n            getWidgetState: function getWidgetState(uiState, _ref5) {\n                var searchParameters = _ref5.searchParameters;\n                var _searchParameters$get = searchParameters.getNumericRefinements(attributeName), _searchParameters$get2 = _searchParameters$get['>='], min = _searchParameters$get2 === undefined ? '' : _searchParameters$get2, _searchParameters$get3 = _searchParameters$get['<='], max = _searchParameters$get3 === undefined ? '' : _searchParameters$get3;\n                if (min === '' && max === '' || uiState && uiState.priceRanges && uiState.priceRanges[attributeName] === min + ':' + max) {\n                    return uiState;\n                }\n                return _extends({}, uiState, {\n                    priceRanges: _extends({}, uiState.priceRanges, _defineProperty({}, attributeName, min + ':' + max))\n                });\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {\n                var uiState = _ref6.uiState;\n                var value = uiState && uiState.priceRanges && uiState.priceRanges[attributeName];\n                if (!value || value.indexOf(':') === -1) {\n                    return searchParameters;\n                }\n                var _searchParameters$get4 = searchParameters.getNumericRefinements(attributeName), _searchParameters$get5 = _searchParameters$get4['>='], previousMin = _searchParameters$get5 === undefined ? [NaN] : _searchParameters$get5, _searchParameters$get6 = _searchParameters$get4['<='], previousMax = _searchParameters$get6 === undefined ? [NaN] : _searchParameters$get6;\n                var clearedParams = searchParameters.clearRefinements(attributeName);\n                var _value$split$map = value.split(':').map(parseFloat), _value$split$map2 = _slicedToArray(_value$split$map, 2), lowerBound = _value$split$map2[0], upperBound = _value$split$map2[1];\n                if (previousMin.includes(lowerBound) && previousMax.includes(upperBound)) {\n                    return searchParameters;\n                }\n                if (isFinite(lowerBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '>=', lowerBound);\n                }\n                if (isFinite(upperBound)) {\n                    clearedParams = clearedParams.addNumericRefinement(attributeName, '<=', upperBound);\n                }\n                return clearedParams;\n            }\n        };\n    };\n}\n",null]}