{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/url-sync.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/url-sync.js","mtime":1581861144660},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START algoliasearch_helper,algoliasearch_helper_src_url,lodash_isEqual PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nvar _createClass = /*@__PURE__*/ function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n        descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n} } return function (Constructor, protoProps, staticProps) { if (protoProps)\n    defineProperties(Constructor.prototype, protoProps); if (staticProps)\n    defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n} }\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport urlHelper from 'algoliasearch-helper/src/url';\nimport isEqual from 'lodash/isEqual';\nvar AlgoliaSearchHelper = algoliasearchHelper.AlgoliaSearchHelper;\n/**\n * @typedef {object} UrlUtil\n * @property {string} character the character used in the url\n * @property {function} onpopstate add an event listener for the URL change\n * @property {function} pushState creates a new entry in the browser history\n * @property {function} readUrl reads the query string of the parameters\n */\n/**\n * Handles the legacy browsers\n * @type {UrlUtil}\n */\nvar hashUrlUtils = {\n    ignoreNextPopState: false,\n    character: '#',\n    onpopstate: function onpopstate(cb) {\n        var _this = this;\n        this._onHashChange = function (hash) {\n            if (_this.ignoreNextPopState) {\n                _this.ignoreNextPopState = false;\n                return;\n            }\n            cb(hash);\n        };\n        window.addEventListener('hashchange', this._onHashChange);\n    },\n    pushState: function pushState(qs) {\n        // hash change or location assign does trigger an hashchange event\n        // so every time we change it manually, we inform the code\n        // to ignore the next hashchange event\n        // see https://github.com/algolia/instantsearch.js/issues/2012\n        this.ignoreNextPopState = true;\n        window.location.assign(getFullURL(this.createURL(qs)));\n    },\n    createURL: function createURL(qs) {\n        return window.location.search + this.character + qs;\n    },\n    readUrl: function readUrl() {\n        return window.location.hash.slice(1);\n    },\n    dispose: function dispose() {\n        window.removeEventListener('hashchange', this._onHashChange);\n        window.location.assign(getFullURL(''));\n    }\n};\n/**\n * Handles the modern API\n * @type {UrlUtil}\n */\nvar modernUrlUtils = {\n    character: '?',\n    onpopstate: function onpopstate(cb) {\n        this._onPopState = function () {\n            return cb.apply(undefined, arguments);\n        };\n        window.addEventListener('popstate', this._onPopState);\n    },\n    pushState: function pushState(qs, _ref) {\n        var getHistoryState = _ref.getHistoryState;\n        window.history.pushState(getHistoryState(), '', getFullURL(this.createURL(qs)));\n    },\n    createURL: function createURL(qs) {\n        return this.character + qs + document.location.hash;\n    },\n    readUrl: function readUrl() {\n        return window.location.search.slice(1);\n    },\n    dispose: function dispose() {\n        window.removeEventListener('popstate', this._onPopState);\n        window.history.pushState(null, null, getFullURL(''));\n    }\n};\n// we always push the full url to the url bar. Not a relative one.\n// So that we handle cases like using a <base href>, see\n// https://github.com/algolia/instantsearch.js/issues/790 for the original issue\nfunction getFullURL(relative) {\n    return getLocationOrigin() + window.location.pathname + relative;\n}\n// IE <= 11 has no location.origin or buggy\nfunction getLocationOrigin() {\n    // eslint-disable-next-line max-len\n    return window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n}\n// see InstantSearch.js file for urlSync options\nvar URLSync = /*@__PURE__*/ function () {\n    function URLSync(urlUtils, options) {\n        _classCallCheck(this, URLSync);\n        this.urlUtils = urlUtils;\n        this.originalConfig = null;\n        this.mapping = options.mapping || {};\n        this.getHistoryState = options.getHistoryState || function () {\n            return null;\n        };\n        this.threshold = options.threshold || 700;\n        this.trackedParameters = options.trackedParameters || ['query', 'attribute:*', 'index', 'page', 'hitsPerPage'];\n        this.firstRender = true;\n        this.searchParametersFromUrl = AlgoliaSearchHelper.getConfigurationFromQueryString(this.urlUtils.readUrl(), { mapping: this.mapping });\n    }\n    _createClass(URLSync, [{\n            key: 'init',\n            value: function init(_ref2) {\n                var state = _ref2.state;\n                this.initState = state;\n            }\n        }, {\n            key: 'getConfiguration',\n            value: function getConfiguration(currentConfiguration) {\n                // we need to create a REAL helper to then get its state. Because some parameters\n                // like hierarchicalFacet.rootPath are then triggering a default refinement that would\n                // be not present if it was not going trough the SearchParameters constructor\n                this.originalConfig = algoliasearchHelper({}, currentConfiguration.index, currentConfiguration).state;\n                return this.searchParametersFromUrl;\n            }\n        }, {\n            key: 'render',\n            value: function render(_ref3) {\n                var _this2 = this;\n                var helper = _ref3.helper, state = _ref3.state;\n                if (this.firstRender) {\n                    this.firstRender = false;\n                    this.onHistoryChange(this.onPopState.bind(this, helper));\n                    helper.on('change', function (s) {\n                        return _this2.renderURLFromState(s);\n                    });\n                    var initStateQs = this.getQueryString(this.initState);\n                    var stateQs = this.getQueryString(state);\n                    if (initStateQs !== stateQs) {\n                        // force update the URL, if the state has changed since the initial URL read\n                        // We do this in order to make a URL update when there is search function\n                        // that prevent the search of the initial rendering\n                        // See: https://github.com/algolia/instantsearch.js/issues/2523#issuecomment-339356157\n                        this.renderURLFromState(state);\n                    }\n                }\n            }\n        }, {\n            key: 'dispose',\n            value: function dispose(_ref4) {\n                var helper = _ref4.helper;\n                helper.removeListener('change', this.renderURLFromState);\n                this.urlUtils.dispose();\n            }\n        }, {\n            key: 'onPopState',\n            value: function onPopState(helper, fullState) {\n                clearTimeout(this.urlUpdateTimeout);\n                // compare with helper.state\n                var partialHelperState = helper.getState(this.trackedParameters);\n                var fullHelperState = _extends({}, this.originalConfig, partialHelperState);\n                if (isEqual(fullHelperState, fullState))\n                    return;\n                helper.overrideStateWithoutTriggeringChangeEvent(fullState).search();\n            }\n        }, {\n            key: 'renderURLFromState',\n            value: function renderURLFromState(state) {\n                var _this3 = this;\n                var qs = this.getQueryString(state);\n                clearTimeout(this.urlUpdateTimeout);\n                this.urlUpdateTimeout = setTimeout(function () {\n                    _this3.urlUtils.pushState(qs, { getHistoryState: _this3.getHistoryState });\n                }, this.threshold);\n            }\n        }, {\n            key: 'getQueryString',\n            value: function getQueryString(state) {\n                var currentQueryString = this.urlUtils.readUrl();\n                var foreignConfig = AlgoliaSearchHelper.getForeignConfigurationInQueryString(currentQueryString, { mapping: this.mapping });\n                return urlHelper.getQueryStringFromState(state.filter(this.trackedParameters), {\n                    moreAttributes: foreignConfig,\n                    mapping: this.mapping,\n                    safe: true\n                });\n            }\n            // External APIs\n        }, {\n            key: 'createURL',\n            value: function createURL(state, _ref5) {\n                var absolute = _ref5.absolute;\n                var filteredState = state.filter(this.trackedParameters);\n                var relative = this.urlUtils.createURL(algoliasearchHelper.url.getQueryStringFromState(filteredState, {\n                    mapping: this.mapping\n                }));\n                return absolute ? getFullURL(relative) : relative;\n            }\n        }, {\n            key: 'onHistoryChange',\n            value: function onHistoryChange(fn) {\n                var _this4 = this;\n                this.urlUtils.onpopstate(function () {\n                    var qs = _this4.urlUtils.readUrl();\n                    var partialState = AlgoliaSearchHelper.getConfigurationFromQueryString(qs, { mapping: _this4.mapping });\n                    var fullState = _extends({}, _this4.originalConfig, partialState);\n                    fn(fullState);\n                });\n            }\n        }]);\n    return URLSync;\n}();\n/**\n * Instantiate a url sync widget. This widget let you synchronize the search\n * parameters with the URL. It can operate with legacy API and hash or it can use\n * the modern history API. By default, it will use the modern API, but if you are\n * looking for compatibility with IE8 and IE9, then you should set 'useHash' to\n * true.\n * @param {object} options all the parameters to configure the URL synchronization. It\n * may contain the following keys :\n *  - threshold:number time in ms after which a new state is created in the browser\n * history. The default value is 700.\n *  - trackedParameters:string[] parameters that will be synchronized in the\n * URL. By default, it will track the query, all the refinable attributes (facets and numeric\n * filters), the index and the page.\n *  - useHash:boolean if set to true, the url will be hash based. Otherwise,\n * it'll use the query parameters using the modern history API.\n * @return {object} the widget instance\n */\nfunction urlSync() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var useHash = options.useHash || false;\n    var customUrlUtils = options.urlUtils;\n    var urlUtils = customUrlUtils || (useHash ? hashUrlUtils : modernUrlUtils);\n    return new URLSync(urlUtils, options);\n}\nexport default urlSync;\n",null]}