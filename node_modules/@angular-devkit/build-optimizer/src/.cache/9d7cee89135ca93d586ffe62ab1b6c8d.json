{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/nested/NestedComponent.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/formiojs/components/nested/NestedComponent.js","mtime":1581861142284},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.concat\");\n\nrequire(\"core-js/modules/es.array.find-index\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.array.map\");\n\nrequire(\"core-js/modules/es.array.slice\");\n\nrequire(\"core-js/modules/es.array.splice\");\n\nrequire(\"core-js/modules/es.object.assign\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor\");\n\nrequire(\"core-js/modules/es.object.get-prototype-of\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.reflect.get\");\n\nrequire(\"core-js/modules/es.reflect.set\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.includes\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _nativePromiseOnly = _interopRequireDefault(require(\"native-promise-only\"));\n\nvar _Base = _interopRequireDefault(require(\"../base/Base\"));\n\nvar _Components = _interopRequireDefault(require(\"../Components\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction set(target, property, value, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }\n\nfunction _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar NestedComponent =\n/*#__PURE__*/\nfunction (_BaseComponent) {\n  _inherits(NestedComponent, _BaseComponent);\n\n  _createClass(NestedComponent, null, [{\n    key: \"schema\",\n    value: function schema() {\n      for (var _len = arguments.length, extend = new Array(_len), _key = 0; _key < _len; _key++) {\n        extend[_key] = arguments[_key];\n      }\n\n      return _Base.default.schema.apply(_Base.default, [{}].concat(extend));\n    }\n  }]);\n\n  function NestedComponent(component, options, data) {\n    var _this;\n\n    _classCallCheck(this, NestedComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NestedComponent).call(this, component, options, data));\n    _this.type = 'components';\n    _this.components = [];\n    _this.hidden = [];\n    _this.collapsed = !!_this.component.collapsed;\n    return _this;\n  }\n\n  _createClass(NestedComponent, [{\n    key: \"build\",\n    value: function build(state, showLabel) {\n      this.createElement();\n\n      if (showLabel) {\n        this.createLabel(this.element);\n      }\n\n      this.addComponents(null, null, null, state);\n      this.attachLogic();\n    }\n  }, {\n    key: \"getComponents\",\n    value: function getComponents() {\n      return this.components;\n    }\n  }, {\n    key: \"getAllComponents\",\n    value: function getAllComponents() {\n      return this.getComponents().reduce(function (components, component) {\n        var result = component;\n\n        if (component && component.getAllComponents) {\n          result = component.getAllComponents();\n        }\n\n        return components.concat(result);\n      }, []);\n    }\n    /**\n     * Perform a deep iteration over every component, including those\n     * within other container based components.\n     *\n     * @param {function} fn - Called for every component.\n     */\n\n  }, {\n    key: \"everyComponent\",\n    value: function everyComponent(fn) {\n      var components = this.getComponents();\n\n      _lodash.default.each(components, function (component, index) {\n        if (fn(component, components, index) === false) {\n          return false;\n        }\n\n        if (typeof component.everyComponent === 'function') {\n          if (component.everyComponent(fn) === false) {\n            return false;\n          }\n        }\n      });\n    }\n    /**\n     * Perform an iteration over each component within this container component.\n     *\n     * @param {function} fn - Called for each component\n     */\n\n  }, {\n    key: \"eachComponent\",\n    value: function eachComponent(fn) {\n      _lodash.default.each(this.getComponents(), function (component, index) {\n        if (fn(component, index) === false) {\n          return false;\n        }\n      });\n    }\n    /**\n     * Returns a component provided a key. This performs a deep search within the\n     * component tree.\n     *\n     * @param {string} key - The key of the component to retrieve.\n     * @param {function} fn - Called with the component once found.\n     * @return {Object} - The component that is located.\n     */\n\n  }, {\n    key: \"getComponent\",\n    value: function getComponent(path, fn) {\n      path = Array.isArray(path) ? path : [path];\n\n      var _path = path,\n          _path2 = _toArray(_path),\n          key = _path2[0],\n          remainingPath = _path2.slice(1);\n\n      var comp = null;\n\n      if (!_lodash.default.isString(key)) {\n        return comp;\n      }\n\n      this.everyComponent(function (component, components) {\n        if (component.component.key === key) {\n          comp = component;\n\n          if (remainingPath.length > 0 && 'getComponent' in component) {\n            comp = component.getComponent(remainingPath, fn);\n          } else if (fn) {\n            fn(component, components);\n          }\n\n          return false;\n        }\n      });\n      return comp;\n    }\n    /**\n     * Return a component provided the Id of the component.\n     *\n     * @param {string} id - The Id of the component.\n     * @param {function} fn - Called with the component once it is retrieved.\n     * @return {Object} - The component retrieved.\n     */\n\n  }, {\n    key: \"getComponentById\",\n    value: function getComponentById(id, fn) {\n      var comp = null;\n      this.everyComponent(function (component, components) {\n        if (component.id === id) {\n          comp = component;\n\n          if (fn) {\n            fn(component, components);\n          }\n\n          return false;\n        }\n      });\n      return comp;\n    }\n    /**\n     * Create a new component and add it to the components array.\n     *\n     * @param component\n     * @param data\n     */\n\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component, options, data, before, state) {\n      options = options || this.options;\n      data = data || this.data;\n\n      var comp = _Components.default.create(component, options, data, true);\n\n      comp.parent = this;\n      comp.root = this.root || this;\n\n      if (state && state.persist) {\n        comp.persist = state.persist;\n        delete state.persist;\n      }\n\n      comp.build(state);\n      comp.isBuilt = true;\n\n      if (component.internal) {\n        return comp;\n      }\n\n      if (before) {\n        var index = _lodash.default.findIndex(this.components, {\n          id: before.id\n        });\n\n        if (index !== -1) {\n          this.components.splice(index, 0, comp);\n        } else {\n          this.components.push(comp);\n        }\n      } else {\n        this.components.push(comp);\n      }\n\n      return comp;\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.element;\n    }\n    /**\n     * Add a new component to the components array.\n     *\n     * @param {Object} component - The component JSON schema to add.\n     * @param {HTMLElement} element - The DOM element to append this child to.\n     * @param {Object} data - The submission data object to house the data for this component.\n     * @param {HTMLElement} before - A DOM element to insert this element before.\n     * @param {Boolean} noAdd - If this component should just be created and not added to this nested component.\n     * @param {Object} state - The state of the component getting created.\n     * @return {BaseComponent} - The created component instance.\n     */\n\n  }, {\n    key: \"addComponent\",\n    value: function addComponent(component, element, data, before, noAdd, state) {\n      element = element || this.getContainer();\n      data = data || this.data;\n      var comp = this.createComponent(component, this.options, data, before ? before.component : null, state);\n\n      if (noAdd) {\n        return comp;\n      }\n\n      element = this.hook('addComponent', element, comp, this);\n      var compElement = comp.getElement();\n\n      if (!compElement) {\n        console.warn(\"Component \".concat(component.key, \" has no element.\"));\n        return comp;\n      }\n\n      if (before) {\n        element.insertBefore(compElement, before);\n      } else {\n        element.appendChild(compElement);\n      }\n\n      this.setHidden(comp);\n      return comp;\n    }\n    /**\n     * Remove a component from the components array.\n     *\n     * @param {BaseComponent} component - The component to remove from the components.\n     * @param {Array<BaseComponent>} components - An array of components to remove this component from.\n     */\n\n  }, {\n    key: \"removeComponent\",\n    value: function removeComponent(component, components) {\n      components = components || this.components;\n      var state = component.destroy() || {};\n      state.persist = component.persist;\n      var element = component.getElement();\n\n      if (element && element.parentNode) {\n        this.removeChildFrom(element, element.parentNode);\n      }\n\n      _lodash.default.remove(components, {\n        id: component.id\n      });\n\n      return state;\n    }\n    /**\n     * Removes a component provided the API key of that component.\n     *\n     * @param {string} key - The API key of the component to remove.\n     * @param {function} fn - Called once the component is removed.\n     * @return {null}\n     */\n\n  }, {\n    key: \"removeComponentByKey\",\n    value: function removeComponentByKey(key, fn) {\n      var _this2 = this;\n\n      var comp = this.getComponent(key, function (component, components) {\n        _this2.removeComponent(component, components);\n\n        if (fn) {\n          fn(component, components);\n        }\n      });\n\n      if (!comp) {\n        if (fn) {\n          fn(null);\n        }\n\n        return null;\n      }\n    }\n    /**\n     * Removes a component provided the Id of the component.\n     *\n     * @param {string} id - The Id of the component to remove.\n     * @param {function} fn - Called when the component is removed.\n     * @return {null}\n     */\n\n  }, {\n    key: \"removeComponentById\",\n    value: function removeComponentById(id, fn) {\n      var _this3 = this;\n\n      var comp = this.getComponentById(id, function (component, components) {\n        _this3.removeComponent(component, components);\n\n        if (fn) {\n          fn(component, components);\n        }\n      });\n\n      if (!comp) {\n        if (fn) {\n          fn(null);\n        }\n\n        return null;\n      }\n    }\n  }, {\n    key: \"addComponents\",\n\n    /**\n     *\n     * @param element\n     * @param data\n     */\n    value: function addComponents(element, data, options, state) {\n      var _this4 = this;\n\n      element = element || this.getContainer();\n      data = data || this.data;\n      options = options || this.options;\n      state = state || {};\n\n      if (options.components) {\n        this.components = options.components;\n      } else {\n        var components = this.hook('addComponents', this.componentComponents, this) || [];\n        components.forEach(function (component) {\n          return _this4.addComponent(component, element, data, null, null, _this4.getComponentState(component, state));\n        });\n      }\n    }\n  }, {\n    key: \"getComponentState\",\n    value: function getComponentState() {\n      var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var key = component.key;\n      var components = state.components;\n      var substate = {};\n\n      if (components) {\n        Object.assign(substate, components[key]);\n      }\n\n      return substate;\n    }\n  }, {\n    key: \"updateValue\",\n    value: function updateValue(flags, source) {\n      return this.components.reduce(function (changed, comp) {\n        // Skip over the source if it is provided.\n        if (source && source.id === comp.id) {\n          return changed;\n        }\n\n        return comp.updateValue(flags) || changed;\n      }, false);\n    }\n  }, {\n    key: \"hasChanged\",\n    value: function hasChanged() {\n      return false;\n    }\n    /**\n     * A more performant way to check the conditions, calculations, and validity of\n     * a submission once it has been changed.\n     *\n     * @param data\n     * @param flags\n     */\n\n  }, {\n    key: \"checkData\",\n    value: function checkData(data, flags, source) {\n      flags = flags || {};\n      var valid = true;\n\n      if (flags.noCheck) {\n        return;\n      } // Update the value.\n\n\n      var changed = this.updateValue({\n        noUpdateEvent: true\n      }, source); // Iterate through all components and check conditions, and calculate values.\n\n      this.getComponents().forEach(function (comp) {\n        changed |= comp.calculateValue(data, {\n          noUpdateEvent: true\n        });\n        comp.checkConditions(data);\n\n        if (!flags.noValidate) {\n          valid &= comp.checkValidity(data);\n        }\n      }); // Trigger the change if the values changed.\n\n      if (changed) {\n        this.triggerChange(flags);\n      } // Return if the value is valid.\n\n\n      return !!valid;\n    }\n  }, {\n    key: \"checkConditions\",\n    value: function checkConditions(data) {\n      this.getComponents().forEach(function (comp) {\n        return comp.checkConditions(data);\n      });\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"checkConditions\", this).call(this, data);\n    }\n  }, {\n    key: \"clearOnHide\",\n    value: function clearOnHide(show) {\n      _get(_getPrototypeOf(NestedComponent.prototype), \"clearOnHide\", this).call(this, show);\n\n      if (this.component.clearOnHide && this.hasValue()) {\n        this.restoreComponentsContext();\n      }\n\n      this.getComponents().forEach(function (component) {\n        return component.clearOnHide(show);\n      });\n    }\n  }, {\n    key: \"restoreComponentsContext\",\n    value: function restoreComponentsContext() {\n      var _this5 = this;\n\n      this.getComponents().forEach(function (component) {\n        return component.data = _this5.dataValue;\n      });\n    }\n  }, {\n    key: \"show\",\n    value: function show(_show) {\n      var shown = _get(_getPrototypeOf(NestedComponent.prototype), \"show\", this).call(this, _show);\n\n      var forceShow = this.options.show && this.options.show[this.component.key];\n      var forceHide = this.options.hide && this.options.hide[this.component.key];\n\n      if (forceShow || forceHide) {\n        this.getComponents().forEach(function (component) {\n          if (forceShow) {\n            component.show(true);\n          } else if (forceHide) {\n            component.show(false);\n          }\n        });\n      } // If hiding a nested component, clear all errors below.\n\n\n      if (!shown) {\n        this.getAllComponents().forEach(function (component) {\n          component.error = '';\n        });\n      }\n\n      return shown;\n    }\n    /**\n     * Allow components to hook into the next page trigger to perform their own logic.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforePage\",\n    value: function beforePage(next) {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (comp) {\n        return comp.beforePage(next);\n      }));\n    }\n    /**\n     * Allow components to hook into the submission to provide their own async data.\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: \"beforeSubmit\",\n    value: function beforeSubmit() {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (comp) {\n        return comp.beforeSubmit();\n      }));\n    }\n  }, {\n    key: \"calculateValue\",\n    value: function calculateValue(data, flags) {\n      // Do not iterate into children and calculateValues if this nested component is conditionally hidden.\n      if (!this.conditionallyVisible()) {\n        return false;\n      }\n\n      return this.getComponents().reduce(function (changed, comp) {\n        return comp.calculateValue(data, flags) || changed;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"calculateValue\", this).call(this, data, flags));\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(data, dirty) {\n      return this.getComponents().reduce(function (valid, comp) {\n        return comp.isValid(data, dirty) && valid;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"isValid\", this).call(this, data, dirty));\n    }\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity(data, dirty) {\n      if (!this.checkCondition(null, data)) {\n        this.setCustomValidity('');\n        return true;\n      }\n\n      return this.getComponents().reduce(function (check, comp) {\n        return comp.checkValidity(data, dirty) && check;\n      }, _get(_getPrototypeOf(NestedComponent.prototype), \"checkValidity\", this).call(this, data, dirty));\n    }\n  }, {\n    key: \"setPristine\",\n    value: function setPristine(pristine) {\n      _get(_getPrototypeOf(NestedComponent.prototype), \"setPristine\", this).call(this, pristine);\n\n      this.getComponents().forEach(function (comp) {\n        return comp.setPristine(pristine);\n      });\n    }\n    /**\n     * Destroys this component.\n     *\n     * @param state\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var state = _get(_getPrototypeOf(NestedComponent.prototype), \"destroy\", this).apply(this, arguments) || {};\n      this.destroyComponents(state);\n      return state;\n    }\n  }, {\n    key: \"destroyComponents\",\n    value: function destroyComponents(state) {\n      var _this6 = this;\n\n      state = state || {};\n      state.components = state.components || {};\n      var components = this.components.slice();\n      components.forEach(function (comp) {\n        var compState = _this6.removeComponent(comp, _this6.components);\n\n        if (comp.key && compState) {\n          state.components[comp.key] = compState;\n        }\n      });\n      this.components = [];\n      this.hidden = [];\n      return state;\n    }\n  }, {\n    key: \"setHidden\",\n    value: function setHidden(component) {\n      if (component.component.hidden || this.hidden && this.hidden.includes(component.key) || !component.conditionallyVisible()) {\n        component.show(false, true);\n      } else {\n        component.show(true, true);\n      }\n    }\n  }, {\n    key: \"hideComponents\",\n    value: function hideComponents(hidden) {\n      var _this7 = this;\n\n      this.hidden = hidden;\n      this.eachComponent(function (component) {\n        return _this7.setHidden(component);\n      });\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.data;\n    }\n  }, {\n    key: \"resetValue\",\n    value: function resetValue() {\n      this.getComponents().forEach(function (comp) {\n        return comp.resetValue();\n      });\n\n      _lodash.default.unset(this.data, this.key);\n\n      this.setPristine(true);\n    }\n  }, {\n    key: \"setNestedValue\",\n    value: function setNestedValue(component, value, flags, changed) {\n      if (component.type === 'button') {\n        return false;\n      }\n\n      if (component.type === 'components') {\n        return component.setValue(value, flags) || changed;\n      } else if (value && component.hasValue(value)) {\n        return component.setValue(_lodash.default.get(value, component.key), flags) || changed;\n      } else {\n        flags.noValidate = true;\n        return component.setValue(component.defaultValue, flags) || changed;\n      }\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, flags) {\n      var _this8 = this;\n\n      if (!value) {\n        return false;\n      }\n\n      flags = this.getFlags.apply(this, arguments);\n      return this.getComponents().reduce(function (changed, component) {\n        return _this8.setNestedValue(component, value, flags, changed);\n      }, false);\n    }\n  }, {\n    key: \"setCollapseHeader\",\n    value: function setCollapseHeader(header) {\n      var _this9 = this;\n\n      if (this.component.collapsible) {\n        this.addClass(header, 'formio-clickable');\n        this.addEventListener(header, 'click', function () {\n          return _this9.toggleCollapse();\n        });\n      }\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(element) {\n      if (!this.component.collapsible || this.options.builder) {\n        return;\n      }\n\n      var container = element || this.getContainer();\n\n      if (this.collapsed) {\n        container.setAttribute('hidden', true);\n        container.style.visibility = 'hidden';\n      } else {\n        container.removeAttribute('hidden');\n        container.style.visibility = 'visible';\n      }\n    }\n  }, {\n    key: \"toggleCollapse\",\n    value: function toggleCollapse() {\n      this.collapsed = !this.collapsed;\n      this.setCollapsed();\n    }\n  }, {\n    key: \"defaultSchema\",\n    get: function get() {\n      return NestedComponent.schema();\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      var schema = _get(_getPrototypeOf(NestedComponent.prototype), \"schema\", this);\n\n      var components = _lodash.default.uniqBy(this.getComponents(), 'component.key');\n\n      schema.components = _lodash.default.map(components, 'schema');\n      return schema;\n    }\n  }, {\n    key: \"visible\",\n    set: function set(value) {\n      var _this10 = this;\n\n      _set(_getPrototypeOf(NestedComponent.prototype), \"visible\", value, this, true);\n\n      this.components.forEach(function (component) {\n        component.parentVisible = _this10.visible;\n      });\n    },\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"visible\", this);\n    }\n  }, {\n    key: \"parentVisible\",\n    set: function set(value) {\n      var _this11 = this;\n\n      _set(_getPrototypeOf(NestedComponent.prototype), \"parentVisible\", value, this, true);\n\n      this.components.forEach(function (component) {\n        component.parentVisible = _this11.visible;\n      });\n    },\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"parentVisible\", this);\n    }\n  }, {\n    key: \"currentForm\",\n    get: function get() {\n      return _get(_getPrototypeOf(NestedComponent.prototype), \"currentForm\", this);\n    },\n    set: function set(instance) {\n      _set(_getPrototypeOf(NestedComponent.prototype), \"currentForm\", instance, this, true);\n\n      this.getComponents().forEach(function (component) {\n        component.currentForm = instance;\n      });\n    }\n  }, {\n    key: \"componentComponents\",\n    get: function get() {\n      return this.component.components;\n    }\n  }, {\n    key: \"disabled\",\n    set: function set(disabled) {\n      this.components.forEach(function (component) {\n        return component.disabled = disabled;\n      });\n    }\n  }, {\n    key: \"errors\",\n    get: function get() {\n      return this.getAllComponents().reduce(function (errors, comp) {\n        return errors.concat(comp.errors || []);\n      }, []);\n    }\n  }, {\n    key: \"dataReady\",\n    get: function get() {\n      return _nativePromiseOnly.default.all(this.getComponents().map(function (component) {\n        return component.dataReady;\n      }));\n    }\n  }]);\n\n  return NestedComponent;\n}(_Base.default);\n\nexports.default = NestedComponent;",null]}