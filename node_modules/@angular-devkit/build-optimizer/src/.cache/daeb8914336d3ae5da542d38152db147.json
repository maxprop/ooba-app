{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/hierarchical-menu/connectHierarchicalMenu.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/hierarchical-menu/connectHierarchicalMenu.js","mtime":1581861144630},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START lodash_find,lodash_isEqual,_.._lib_utils.js PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nvar _slicedToArray = /*@__PURE__*/ function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n            break;\n    }\n}\ncatch (err) {\n    _d = true;\n    _e = err;\n}\nfinally {\n    try {\n        if (!_n && _i[\"return\"])\n            _i[\"return\"]();\n    }\n    finally {\n        if (_d)\n            throw _e;\n    }\n} return _arr; } return function (arr, i) { if (Array.isArray(arr)) {\n    return arr;\n}\nelse if (Symbol.iterator in Object(arr)) {\n    return sliceIterator(arr, i);\n}\nelse {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} }; }();\nfunction _defineProperty(obj, key, value) { if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n}\nelse {\n    obj[key] = value;\n} return obj; }\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) {\n    if (keys.indexOf(i) >= 0)\n        continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i))\n        continue;\n    target[i] = obj[i];\n} return target; }\nimport find from 'lodash/find';\nimport isEqual from 'lodash/isEqual';\nimport { checkRendering, warn } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customHierarchicalMenu = connectHierarchicalMenu(function renderFn(params, isFirstRendering) {\\n  // params = {\\n  //   createURL,\\n  //   items,\\n  //   refine,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  // }\\n});\\nsearch.addWidget(\\n  customHierarchicalMenu({\\n    attributes,\\n    [ separator = \\' > \\' ],\\n    [ rootPath = null ],\\n    [ showParentLevel = true ],\\n    [ limit = 10 ],\\n    [ sortBy = [\\'name:asc\\'] ],\\n    [ transformItems ],\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectHierarchicalMenu.html\\n';\n/**\n * @typedef {Object} HierarchicalMenuItem\n * @property {string} value Value of the menu item.\n * @property {string} label Human-readable value of the menu item.\n * @property {number} count Number of matched results after refinement is applied.\n * @property {isRefined} boolean Indicates if the refinement is applied.\n * @property {Object} [data = undefined] n+1 level of items, same structure HierarchicalMenuItem (default: `undefined`).\n */\n/**\n * @typedef {Object} CustomHierarchicalMenuWidgetOptions\n * @property {string[]} attributes Attributes to use to generate the hierarchy of the menu.\n * @property {string} [separator = '>'] Separator used in the attributes to separate level values.\n * @property {string} [rootPath = null] Prefix path to use if the first level is not the root level.\n * @property {boolean} [showParentLevel=false] Show the siblings of the selected parent levels of the current refined value. This\n * does not impact the root level.\n * @property {number} [limit = 10] Max number of value to display.\n * @property  {string[]|function} [sortBy = ['name:asc']] How to sort refinements. Possible values: `count|isRefined|name:asc|name:desc`.\n *\n * You can also use a sort function that behaves like the standard Javascript [compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Syntax).\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n/**\n * @typedef {Object} HierarchicalMenuRenderingOptions\n * @property {function(item.value): string} createURL Creates an url for the next state for a clicked item.\n * @property {HierarchicalMenuItem[]} items Values to be rendered.\n * @property {function(item.value)} refine Sets the path of the hierarchical filter and triggers a new search.\n * @property {Object} widgetParams All original `CustomHierarchicalMenuWidgetOptions` forwarded to the `renderFn`.\n */\n/**\n * **HierarchicalMenu** connector provides the logic to build a custom widget\n * that will give the user the ability to explore facets in a tree-like structure.\n *\n * This is commonly used for multi-level categorization of products on e-commerce\n * websites. From a UX point of view, we suggest not displaying more than two\n * levels deep.\n *\n * There's a complete example available on how to write a custom **HierarchicalMenu**:\n *  [hierarchicalMenu.js](https://github.com/algolia/instantsearch.js/blob/develop/dev/app/jquery/widgets/hierarchicalMenu.js)\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/hierarchical-menu/js/\n * @param {function(HierarchicalMenuRenderingOptions)} renderFn Rendering function for the custom **HierarchicalMenu** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomHierarchicalMenuWidgetOptions)} Re-usable widget factory for a custom **HierarchicalMenu** widget.\n */\nexport default function connectHierarchicalMenu(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attributes = widgetParams.attributes, _widgetParams$separat = widgetParams.separator, separator = _widgetParams$separat === undefined ? ' > ' : _widgetParams$separat, _widgetParams$rootPat = widgetParams.rootPath, rootPath = _widgetParams$rootPat === undefined ? null : _widgetParams$rootPat, _widgetParams$showPar = widgetParams.showParentLevel, showParentLevel = _widgetParams$showPar === undefined ? true : _widgetParams$showPar, _widgetParams$limit = widgetParams.limit, limit = _widgetParams$limit === undefined ? 10 : _widgetParams$limit, _widgetParams$sortBy = widgetParams.sortBy, sortBy = _widgetParams$sortBy === undefined ? ['name:asc'] : _widgetParams$sortBy, _widgetParams$transfo = widgetParams.transformItems, transformItems = _widgetParams$transfo === undefined ? function (items) {\n            return items;\n        } : _widgetParams$transfo;\n        if (!attributes || !attributes.length) {\n            throw new Error(usage);\n        }\n        // we need to provide a hierarchicalFacet name for the search state\n        // so that we can always map $hierarchicalFacetName => real attributes\n        // we use the first attribute name\n        var _attributes = _slicedToArray(attributes, 1), hierarchicalFacetName = _attributes[0];\n        return {\n            getConfiguration: function getConfiguration(currentConfiguration) {\n                if (currentConfiguration.hierarchicalFacets) {\n                    var isFacetSet = find(currentConfiguration.hierarchicalFacets, function (_ref) {\n                        var name = _ref.name;\n                        return name === hierarchicalFacetName;\n                    });\n                    if (isFacetSet && !(isEqual(isFacetSet.attributes, attributes) && isFacetSet.separator === separator)) {\n                        warn('using Breadcrumb & HierarchicalMenu on the same facet with different options');\n                        return {};\n                    }\n                }\n                return {\n                    hierarchicalFacets: [{\n                            name: hierarchicalFacetName,\n                            attributes: attributes,\n                            separator: separator,\n                            rootPath: rootPath,\n                            showParentLevel: showParentLevel\n                        }],\n                    maxValuesPerFacet: currentConfiguration.maxValuesPerFacet !== undefined ? Math.max(currentConfiguration.maxValuesPerFacet, limit) : limit\n                };\n            },\n            init: function init(_ref2) {\n                var helper = _ref2.helper, createURL = _ref2.createURL, instantSearchInstance = _ref2.instantSearchInstance;\n                this._refine = function (facetValue) {\n                    helper.toggleRefinement(hierarchicalFacetName, facetValue).search();\n                };\n                // Bind createURL to this specific attribute\n                function _createURL(facetValue) {\n                    return createURL(helper.state.toggleRefinement(hierarchicalFacetName, facetValue));\n                }\n                renderFn({\n                    createURL: _createURL,\n                    items: [],\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    widgetParams: widgetParams\n                }, true);\n            },\n            _prepareFacetValues: function _prepareFacetValues(facetValues, state) {\n                var _this = this;\n                return facetValues.slice(0, limit).map(function (_ref3) {\n                    var label = _ref3.name, value = _ref3.path, subValue = _objectWithoutProperties(_ref3, ['name', 'path']);\n                    if (Array.isArray(subValue.data)) {\n                        subValue.data = _this._prepareFacetValues(subValue.data, state);\n                    }\n                    return _extends({}, subValue, { label: label, value: value });\n                });\n            },\n            render: function render(_ref4) {\n                var results = _ref4.results, state = _ref4.state, createURL = _ref4.createURL, instantSearchInstance = _ref4.instantSearchInstance;\n                var items = transformItems(this._prepareFacetValues(results.getFacetValues(hierarchicalFacetName, { sortBy: sortBy }).data || [], state));\n                // Bind createURL to this specific attribute\n                function _createURL(facetValue) {\n                    return createURL(state.toggleRefinement(hierarchicalFacetName, facetValue));\n                }\n                renderFn({\n                    createURL: _createURL,\n                    items: items,\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    widgetParams: widgetParams\n                }, false);\n            },\n            dispose: function dispose(_ref5) {\n                var state = _ref5.state;\n                // unmount widget from DOM\n                unmountFn();\n                // compute nextState for the search\n                var nextState = state;\n                if (state.isHierarchicalFacetRefined(hierarchicalFacetName)) {\n                    nextState = state.removeHierarchicalFacetRefinement(hierarchicalFacetName);\n                }\n                nextState = nextState.removeHierarchicalFacet(hierarchicalFacetName);\n                if (nextState.maxValuesPerFacet === limit) {\n                    nextState.setQueryParameters('maxValuesPerFacet', undefined);\n                }\n                return nextState;\n            },\n            getWidgetState: function getWidgetState(uiState, _ref6) {\n                var searchParameters = _ref6.searchParameters;\n                var path = searchParameters.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);\n                if (!path || path.length === 0)\n                    return uiState;\n                if (uiState.hierarchicalMenu && isEqual(path, uiState.hierarchicalMenu[hierarchicalFacetName])) {\n                    return uiState;\n                }\n                return _extends({}, uiState, {\n                    hierarchicalMenu: _extends({}, uiState.hierarchicalMenu, _defineProperty({}, hierarchicalFacetName, path))\n                });\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref7) {\n                var uiState = _ref7.uiState;\n                if (uiState.hierarchicalMenu && uiState.hierarchicalMenu[hierarchicalFacetName]) {\n                    return searchParameters.clearRefinements(hierarchicalFacetName).toggleRefinement(hierarchicalFacetName, uiState.hierarchicalMenu[hierarchicalFacetName].join(separator));\n                }\n                else {\n                    return searchParameters;\n                }\n            }\n        };\n    };\n}\n",null]}