{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/routers/history.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/lib/routers/history.js","mtime":1581861144653},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START qs PURE_IMPORTS_END */\nvar _createClass = /*@__PURE__*/ function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n        descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n} } return function (Constructor, protoProps, staticProps) { if (protoProps)\n    defineProperties(Constructor.prototype, protoProps); if (staticProps)\n    defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n} }\nimport qs from 'qs';\nfunction defaultCreateURL(_ref) {\n    var qsModule = _ref.qsModule, routeState = _ref.routeState, location = _ref.location;\n    var protocol = location.protocol, hostname = location.hostname, _location$port = location.port, port = _location$port === undefined ? '' : _location$port, pathname = location.pathname, hash = location.hash;\n    var queryString = qsModule.stringify(routeState);\n    var portWithPrefix = port === '' ? '' : ':' + port;\n    // IE <= 11 has no location.origin or buggy. Therefore we don't rely on it\n    if (!routeState || Object.keys(routeState).length === 0)\n        return protocol + '//' + hostname + portWithPrefix + pathname + hash;\n    else\n        return protocol + '//' + hostname + portWithPrefix + pathname + '?' + queryString + hash;\n}\nfunction defaultParseURL(_ref2) {\n    var qsModule = _ref2.qsModule, location = _ref2.location;\n    // `qs` by default converts arrays with more than 20 items to an object.\n    // We want to avoid this because the data structure manipulated can therefore vary.\n    // Setting the limit to `100` seems a good number because the engine's default is 100\n    // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).\n    //\n    // Using an `arrayLimit` of `n` allows `n + 1` items.\n    //\n    // See:\n    //   - https://github.com/ljharb/qs#parsing-arrays\n    //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/\n    return qsModule.parse(location.search.slice(1), { arrayLimit: 99 });\n}\nvar BrowserHistory = /*@__PURE__*/ function () {\n    /**\n     * Initializes a new storage provider that will sync the search state in the URL\n     * using web API (window.location.pushState and onpopstate event).\n     * @param {object} $0 the options.\n     * @param {function(object):string} [$0.windowTitle] function that transforms a UI state\n     * into a title for the page. It takes one parameter: a syncable object (generated by the mapping\n     * provided to the URL sync). It should return a string that will be the title.\n     * @param {number} [$0.writeDelay = 400] time before a write is actually done.\n     * Prevent having too much entries in the history and thus make the back button more friendly.\n     * @param {function(qs, object):string} [$0.createURL] generates the full URL. If not provided,\n     * the storage adaptor will mapped all syncable keys to the query string of the URL. The first\n     * parameter is a utility object that has two methods: `stringify` that creates a query string\n     * from an object and `parse` that transforms a query string into an object.\n     * @param {function(qs): object} [$0.parseURL] parses an URL into an object. It should symetrical\n     * to `createURL`. It gets as an argument an object that contains two methods: `stringify` that\n     * creates a query string from an object and `parse` that transforms a query string into an object.\n     */\n    function BrowserHistory() {\n        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, windowTitle = _ref3.windowTitle, _ref3$writeDelay = _ref3.writeDelay, writeDelay = _ref3$writeDelay === undefined ? 400 : _ref3$writeDelay, _ref3$createURL = _ref3.createURL, createURL = _ref3$createURL === undefined ? defaultCreateURL : _ref3$createURL, _ref3$parseURL = _ref3.parseURL, parseURL = _ref3$parseURL === undefined ? defaultParseURL : _ref3$parseURL;\n        _classCallCheck(this, BrowserHistory);\n        this.windowTitle = windowTitle;\n        this.writeTimer = undefined;\n        this.writeDelay = writeDelay;\n        this._createURL = createURL;\n        this.parseURL = parseURL;\n    }\n    /**\n     * This method pushes a search state into the URL.\n     * @param {object} routeState a syncable UI state\n     * @return {undefined}\n     */\n    _createClass(BrowserHistory, [{\n            key: 'write',\n            value: function write(routeState) {\n                var _this = this;\n                var url = this.createURL(routeState);\n                var title = this.windowTitle && this.windowTitle(routeState);\n                if (this.writeTimer) {\n                    window.clearTimeout(this.writeTimer);\n                }\n                this.writeTimer = setTimeout(function () {\n                    if (title)\n                        window.document.title = title;\n                    window.history.pushState(routeState, title || '', url);\n                    _this.writeTimer = undefined;\n                }, this.writeDelay);\n            }\n            /**\n             * This methods read the URL and returns a syncable UI search state.\n             * @return {object} the equivalent to what is store in the URL as an object\n             */\n        }, {\n            key: 'read',\n            value: function read() {\n                return this.parseURL({ qsModule: qs, location: window.location });\n            }\n            /**\n             * This methods sets a callback on the `onpopstate` event of the history API\n             * of the current page. This way, the URL sync can keep track of the changes.\n             * @param {function(object)} cb the callback that will receive the latest routeState.\n             * It is called when the URL is updated.\n             * @returns {undefined}\n             */\n        }, {\n            key: 'onUpdate',\n            value: function onUpdate(cb) {\n                var _this2 = this;\n                this._onPopState = function (event) {\n                    if (_this2.writeTimer) {\n                        window.clearTimeout(_this2.writeTimer);\n                        _this2.writeTimer = undefined;\n                    }\n                    var routeState = event.state;\n                    // at initial load, the state is read from the URL without\n                    // update. Therefore the state object is not there. In this\n                    // case we fallback and read the URL.\n                    if (!routeState) {\n                        cb(_this2.read());\n                    }\n                    else {\n                        cb(routeState);\n                    }\n                };\n                window.addEventListener('popstate', this._onPopState);\n            }\n            /**\n             * This method creates a complete URL from a given syncable UI state.\n             *\n             * It always generates the full url, not a relative one.\n             * This way we can handle cases like using a <base href>, see\n             * https://github.com/algolia/instantsearch.js/issues/790 for the original issue\n             *\n             * @param {object} routeState a syncable UI state\n             * @returns {string} the full URL for the provided syncable state\n             */\n        }, {\n            key: 'createURL',\n            value: function createURL(routeState) {\n                return this._createURL({\n                    qsModule: qs,\n                    routeState: routeState,\n                    location: window.location\n                });\n            }\n            /**\n             * This method removes the event listener and cleans up the URL.\n             * @returns {undefined}\n             */\n        }, {\n            key: 'dispose',\n            value: function dispose() {\n                window.removeEventListener('popstate', this._onPopState);\n                if (this.writeTimer)\n                    window.clearTimeout(this.writeTimer);\n                this.write();\n            }\n        }]);\n    return BrowserHistory;\n}();\nexport default function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n    return new (Function.prototype.bind.apply(BrowserHistory, [null].concat(args)))();\n}\n",null]}