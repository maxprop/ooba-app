{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/tooltip.js/dist/esm/tooltip.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/tooltip.js/dist/esm/tooltip.js","mtime":1581861147100},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.3.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/** PURE_IMPORTS_START popper.js PURE_IMPORTS_END */\nimport Popper from 'popper.js';\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\nvar classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n};\nvar createClass = /*@__PURE__*/ function () {\n    function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor)\n                descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function (Constructor, protoProps, staticProps) {\n        if (protoProps)\n            defineProperties(Constructor.prototype, protoProps);\n        if (staticProps)\n            defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nvar _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n};\nvar DEFAULT_OPTIONS = {\n    container: false,\n    delay: 0,\n    html: false,\n    placement: 'top',\n    title: '',\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    offset: 0,\n    arrowSelector: '.tooltip-arrow, .tooltip__arrow',\n    innerSelector: '.tooltip-inner, .tooltip__inner'\n};\nvar Tooltip = /*@__PURE__*/ function () {\n    /**\n     * Create a new Tooltip.js instance\n     * @class Tooltip\n     * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).\n     * @param {Object} options\n     * @param {String} options.placement='top'\n     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n     *      left(-start, -end)`\n     * @param {String} [options.arrowSelector='.tooltip-arrow, .tooltip__arrow'] - className used to locate the DOM arrow element in the tooltip.\n     * @param {String} [options.innerSelector='.tooltip-inner, .tooltip__inner'] - className used to locate the DOM inner element in the tooltip.\n     * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.\n     * @param {Number|Object} options.delay=0\n     *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.\n     *      If a number is supplied, delay is applied to both hide/show.\n     *      Object structure is: `{ show: 500, hide: 100 }`\n     * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `textContent`.\n     * @param {String} [options.template='<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>']\n     *      Base HTML to used when creating the tooltip.\n     *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.\n     *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.\n     *      The outermost wrapper element should have the `.tooltip` class.\n     * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.\n     * @param {String} [options.trigger='hover focus']\n     *      How tooltip is triggered - click, hover, focus, manual.\n     *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.\n     * @param {Boolean} options.closeOnClickOutside=false - Close a popper on click outside of the popper and reference element. This has effect only when options.trigger is 'click'.\n     * @param {String|HTMLElement} options.boundariesElement\n     *      The element used as boundaries for the tooltip. For more information refer to Popper.js'\n     *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)\n     * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'\n     *      [offset docs](https://popper.js.org/popper-documentation.html)\n     * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'\n     *      [options docs](https://popper.js.org/popper-documentation.html)\n     * @return {Object} instance - The generated tooltip instance\n     */\n    function Tooltip(reference, options) {\n        classCallCheck(this, Tooltip);\n        _initialiseProps.call(this);\n        // apply user options over default ones\n        options = _extends({}, DEFAULT_OPTIONS, options);\n        reference.jquery && (reference = reference[0]);\n        // cache reference and options\n        this.reference = reference;\n        this.options = options;\n        // get events list\n        var events = typeof options.trigger === 'string' ? options.trigger.split(' ').filter(function (trigger) {\n            return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;\n        }) : [];\n        // set initial state\n        this._isOpen = false;\n        this._popperOptions = {};\n        // set event listeners\n        this._setEventListeners(reference, events, options);\n    }\n    //\n    // Public methods\n    //\n    /**\n     * Reveals an element's tooltip. This is considered a \"manual\" triggering of the tooltip.\n     * Tooltips with zero-length titles are never displayed.\n     * @method Tooltip#show\n     * @memberof Tooltip\n     */\n    /**\n     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     * @method Tooltip#hide\n     * @memberof Tooltip\n     */\n    /**\n     * Hides and destroys an element’s tooltip.\n     * @method Tooltip#dispose\n     * @memberof Tooltip\n     */\n    /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     * @method Tooltip#toggle\n     * @memberof Tooltip\n     */\n    /**\n     * Updates the tooltip's title content\n     * @method Tooltip#updateTitleContent\n     * @memberof Tooltip\n     * @param {String|HTMLElement} title - The new content to use for the title\n     */\n    //\n    // Private methods\n    //\n    createClass(Tooltip, [{\n            key: '_create',\n            /**\n             * Creates a new tooltip node\n             * @memberof Tooltip\n             * @private\n             * @param {HTMLElement} reference\n             * @param {String} template\n             * @param {String|HTMLElement|TitleFunction} title\n             * @param {Boolean} allowHtml\n             * @return {HTMLElement} tooltipNode\n             */\n            value: function _create(reference, template, title, allowHtml) {\n                // create tooltip element\n                var tooltipGenerator = window.document.createElement('div');\n                tooltipGenerator.innerHTML = template.trim();\n                var tooltipNode = tooltipGenerator.childNodes[0];\n                // add unique ID to our tooltip (needed for accessibility reasons)\n                tooltipNode.id = 'tooltip_' + Math.random().toString(36).substr(2, 10);\n                // set initial `aria-hidden` state to `false` (it's visible!)\n                tooltipNode.setAttribute('aria-hidden', 'false');\n                // add title to tooltip\n                var titleNode = tooltipGenerator.querySelector(this.options.innerSelector);\n                this._addTitleContent(reference, title, allowHtml, titleNode);\n                // return the generated tooltip node\n                return tooltipNode;\n            }\n        }, {\n            key: '_addTitleContent',\n            value: function _addTitleContent(reference, title, allowHtml, titleNode) {\n                if (title.nodeType === 1 || title.nodeType === 11) {\n                    // if title is a element node or document fragment, append it only if allowHtml is true\n                    allowHtml && titleNode.appendChild(title);\n                }\n                else if (isFunction(title)) {\n                    // Recursively call ourself so that the return value of the function gets handled appropriately - either\n                    // as a dom node, a string, or even as another function.\n                    this._addTitleContent(reference, title.call(reference), allowHtml, titleNode);\n                }\n                else {\n                    // if it's just a simple text, set textContent or innerHtml depending by `allowHtml` value\n                    allowHtml ? titleNode.innerHTML = title : titleNode.textContent = title;\n                }\n            }\n        }, {\n            key: '_show',\n            value: function _show(reference, options) {\n                // don't show if it's already visible\n                // or if it's not being showed\n                if (this._isOpen && !this._isOpening) {\n                    return this;\n                }\n                this._isOpen = true;\n                // if the tooltipNode already exists, just show it\n                if (this._tooltipNode) {\n                    this._tooltipNode.style.visibility = 'visible';\n                    this._tooltipNode.setAttribute('aria-hidden', 'false');\n                    this.popperInstance.update();\n                    return this;\n                }\n                // get title\n                var title = reference.getAttribute('title') || options.title;\n                // don't show tooltip if no title is defined\n                if (!title) {\n                    return this;\n                }\n                // create tooltip node\n                var tooltipNode = this._create(reference, options.template, title, options.html);\n                // Add `aria-describedby` to our reference element for accessibility reasons\n                reference.setAttribute('aria-describedby', tooltipNode.id);\n                // append tooltip to container\n                var container = this._findContainer(options.container, reference);\n                this._append(tooltipNode, container);\n                this._popperOptions = _extends({}, options.popperOptions, {\n                    placement: options.placement\n                });\n                this._popperOptions.modifiers = _extends({}, this._popperOptions.modifiers, {\n                    arrow: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.arrow, {\n                        element: options.arrowSelector\n                    }),\n                    offset: _extends({}, this._popperOptions.modifiers && this._popperOptions.modifiers.offset, {\n                        offset: options.offset || this._popperOptions.modifiers && this._popperOptions.modifiers.offset && this._popperOptions.modifiers.offset.offset || options.offset\n                    })\n                });\n                if (options.boundariesElement) {\n                    this._popperOptions.modifiers.preventOverflow = {\n                        boundariesElement: options.boundariesElement\n                    };\n                }\n                this.popperInstance = new Popper(reference, tooltipNode, this._popperOptions);\n                this._tooltipNode = tooltipNode;\n                return this;\n            }\n        }, {\n            key: '_hide',\n            value: function _hide() {\n                // don't hide if it's already hidden\n                if (!this._isOpen) {\n                    return this;\n                }\n                this._isOpen = false;\n                // hide tooltipNode\n                this._tooltipNode.style.visibility = 'hidden';\n                this._tooltipNode.setAttribute('aria-hidden', 'true');\n                return this;\n            }\n        }, {\n            key: '_dispose',\n            value: function _dispose() {\n                var _this = this;\n                // remove event listeners first to prevent any unexpected behaviour\n                this._events.forEach(function (_ref) {\n                    var func = _ref.func, event = _ref.event;\n                    _this.reference.removeEventListener(event, func);\n                });\n                this._events = [];\n                if (this._tooltipNode) {\n                    this._hide();\n                    // destroy instance\n                    this.popperInstance.destroy();\n                    // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element\n                    if (!this.popperInstance.options.removeOnDestroy) {\n                        this._tooltipNode.parentNode.removeChild(this._tooltipNode);\n                        this._tooltipNode = null;\n                    }\n                }\n                return this;\n            }\n        }, {\n            key: '_findContainer',\n            value: function _findContainer(container, reference) {\n                // if container is a query, get the relative element\n                if (typeof container === 'string') {\n                    container = window.document.querySelector(container);\n                }\n                else if (container === false) {\n                    // if container is `false`, set it to reference parent\n                    container = reference.parentNode;\n                }\n                return container;\n            }\n            /**\n             * Append tooltip to container\n             * @memberof Tooltip\n             * @private\n             * @param {HTMLElement} tooltipNode\n             * @param {HTMLElement|String|false} container\n             */\n        }, {\n            key: '_append',\n            value: function _append(tooltipNode, container) {\n                container.appendChild(tooltipNode);\n            }\n        }, {\n            key: '_setEventListeners',\n            value: function _setEventListeners(reference, events, options) {\n                var _this2 = this;\n                var directEvents = [];\n                var oppositeEvents = [];\n                events.forEach(function (event) {\n                    switch (event) {\n                        case 'hover':\n                            directEvents.push('mouseenter');\n                            oppositeEvents.push('mouseleave');\n                            break;\n                        case 'focus':\n                            directEvents.push('focus');\n                            oppositeEvents.push('blur');\n                            break;\n                        case 'click':\n                            directEvents.push('click');\n                            oppositeEvents.push('click');\n                            break;\n                    }\n                });\n                // schedule show tooltip\n                directEvents.forEach(function (event) {\n                    var func = function func(evt) {\n                        if (_this2._isOpening === true) {\n                            return;\n                        }\n                        evt.usedByTooltip = true;\n                        _this2._scheduleShow(reference, options.delay, options, evt);\n                    };\n                    _this2._events.push({ event: event, func: func });\n                    reference.addEventListener(event, func);\n                });\n                // schedule hide tooltip\n                oppositeEvents.forEach(function (event) {\n                    var func = function func(evt) {\n                        if (evt.usedByTooltip === true) {\n                            return;\n                        }\n                        _this2._scheduleHide(reference, options.delay, options, evt);\n                    };\n                    _this2._events.push({ event: event, func: func });\n                    reference.addEventListener(event, func);\n                    if (event === 'click' && options.closeOnClickOutside) {\n                        document.addEventListener('mousedown', function (e) {\n                            if (!_this2._isOpening) {\n                                return;\n                            }\n                            var popper = _this2.popperInstance.popper;\n                            if (reference.contains(e.target) || popper.contains(e.target)) {\n                                return;\n                            }\n                            func(e);\n                        }, true);\n                    }\n                });\n            }\n        }, {\n            key: '_scheduleShow',\n            value: function _scheduleShow(reference, delay, options /*, evt */) {\n                var _this3 = this;\n                this._isOpening = true;\n                // defaults to 0\n                var computedDelay = delay && delay.show || delay || 0;\n                this._showTimeout = window.setTimeout(function () {\n                    return _this3._show(reference, options);\n                }, computedDelay);\n            }\n        }, {\n            key: '_scheduleHide',\n            value: function _scheduleHide(reference, delay, options, evt) {\n                var _this4 = this;\n                this._isOpening = false;\n                // defaults to 0\n                var computedDelay = delay && delay.hide || delay || 0;\n                window.clearTimeout(this._showTimeout);\n                window.setTimeout(function () {\n                    if (_this4._isOpen === false) {\n                        return;\n                    }\n                    if (!document.body.contains(_this4._tooltipNode)) {\n                        return;\n                    }\n                    // if we are hiding because of a mouseleave, we must check that the new\n                    // reference isn't the tooltip, because in this case we don't want to hide it\n                    if (evt.type === 'mouseleave') {\n                        var isSet = _this4._setTooltipNodeEvent(evt, reference, delay, options);\n                        // if we set the new event, don't hide the tooltip yet\n                        // the new event will take care to hide it if necessary\n                        if (isSet) {\n                            return;\n                        }\n                    }\n                    _this4._hide(reference, options);\n                }, computedDelay);\n            }\n        }, {\n            key: '_updateTitleContent',\n            value: function _updateTitleContent(title) {\n                if (typeof this._tooltipNode === 'undefined') {\n                    if (typeof this.options.title !== 'undefined') {\n                        this.options.title = title;\n                    }\n                    return;\n                }\n                var titleNode = this._tooltipNode.querySelector(this.options.innerSelector);\n                this._clearTitleContent(titleNode, this.options.html, this.reference.getAttribute('title') || this.options.title);\n                this._addTitleContent(this.reference, title, this.options.html, titleNode);\n                this.options.title = title;\n                this.popperInstance.update();\n            }\n        }, {\n            key: '_clearTitleContent',\n            value: function _clearTitleContent(titleNode, allowHtml, lastTitle) {\n                if (lastTitle.nodeType === 1 || lastTitle.nodeType === 11) {\n                    allowHtml && titleNode.removeChild(lastTitle);\n                }\n                else {\n                    allowHtml ? titleNode.innerHTML = '' : titleNode.textContent = '';\n                }\n            }\n        }]);\n    return Tooltip;\n}();\n/**\n * Title function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback TitleFunction\n * @return {String} placement - The desired title.\n */\nvar _initialiseProps = function _initialiseProps() {\n    var _this5 = this;\n    this.show = function () {\n        return _this5._show(_this5.reference, _this5.options);\n    };\n    this.hide = function () {\n        return _this5._hide();\n    };\n    this.dispose = function () {\n        return _this5._dispose();\n    };\n    this.toggle = function () {\n        if (_this5._isOpen) {\n            return _this5.hide();\n        }\n        else {\n            return _this5.show();\n        }\n    };\n    this.updateTitleContent = function (title) {\n        return _this5._updateTitleContent(title);\n    };\n    this._events = [];\n    this._setTooltipNodeEvent = function (evt, reference, delay, options) {\n        var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;\n        var callback = function callback(evt2) {\n            var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget;\n            // Remove event listener after call\n            _this5._tooltipNode.removeEventListener(evt.type, callback);\n            // If the new reference is not the reference element\n            if (!reference.contains(relatedreference2)) {\n                // Schedule to hide tooltip\n                _this5._scheduleHide(reference, options.delay, options, evt2);\n            }\n        };\n        if (_this5._tooltipNode.contains(relatedreference)) {\n            // listen to mouseleave on the tooltip element to be able to hide the tooltip\n            _this5._tooltipNode.addEventListener(evt.type, callback);\n            return true;\n        }\n        return false;\n    };\n};\nexport default Tooltip;\n//# sourceMappingURL=tooltip.js.map\n",null]}