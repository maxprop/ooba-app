{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js","mtime":1581861144639},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _.._lib_utils.js PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nimport { checkRendering } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customSearchBox = connectSearchBox(function render(params, isFirstRendering) {\\n  // params = {\\n  //   query,\\n  //   onHistoryChange,\\n  //   refine,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  //   clear,\\n  // }\\n});\\nsearch.addWidget(\\n  customSearchBox({\\n    [ queryHook ],\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectSearchBox.html\\n';\n/**\n * @typedef {Object} CustomSearchBoxWidgetOptions\n * @property {function(string, function(string))} [queryHook = undefined] A function that will be called every time\n * a new value for the query is set. The first parameter is the query and the second is a\n * function to actually trigger the search. The function takes the query as the parameter.\n *\n * This queryHook can be used to debounce the number of searches done from the searchBox.\n */\n/**\n * @typedef {Object} SearchBoxRenderingOptions\n * @property {string} query The query from the last search.\n * @property {function(SearchParameters)} onHistoryChange Registers a callback when the browser history changes.\n * @property {function(string)} refine Sets a new query and searches.\n * @property {function()} clear Remove the query and perform search.\n * @property {Object} widgetParams All original `CustomSearchBoxWidgetOptions` forwarded to the `renderFn`.\n * @property {boolean} isSearchStalled `true` if the search results takes more than a certain time to come back\n * from Algolia servers. This can be configured on the InstantSearch constructor with the attribute\n * `stalledSearchDelay` which is 200ms, by default.\n */\n/**\n * **SearchBox** connector provides the logic to build a widget that will let the user search for a query.\n *\n * The connector provides to the rendering: `refine()` to set the query. The behaviour of this function\n * may be impacted by the `queryHook` widget parameter.\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/search-box/js/\n * @param {function(SearchBoxRenderingOptions, boolean)} renderFn Rendering function for the custom **SearchBox** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomSearchBoxWidgetOptions)} Re-usable widget factory for a custom **SearchBox** widget.\n * @example\n * // custom `renderFn` to render the custom SearchBox widget\n * function renderFn(SearchBoxRenderingOptions, isFirstRendering) {\n *   if (isFirstRendering) {\n *     SearchBoxRenderingOptions.widgetParams.containerNode.html('<input type=\"text\" />');\n *     SearchBoxRenderingOptions.widgetParams.containerNode\n *       .find('input')\n *       .on('keyup', function() {\n *         SearchBoxRenderingOptions.refine($(this).val());\n *       });\n *     SearchBoxRenderingOptions.widgetParams.containerNode\n *       .find('input')\n *       .val(SearchBoxRenderingOptions.query);\n *   }\n * }\n *\n * // connect `renderFn` to SearchBox logic\n * var customSearchBox = instantsearch.connectors.connectSearchBox(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customSearchBox({\n *     containerNode: $('#custom-searchbox'),\n *   })\n * );\n */\nexport default function connectSearchBox(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var queryHook = widgetParams.queryHook;\n        function clear(helper) {\n            return function () {\n                helper.setQuery('');\n                helper.search();\n            };\n        }\n        return {\n            _clear: function _clear() { },\n            _cachedClear: function _cachedClear() {\n                this._clear();\n            },\n            init: function init(_ref) {\n                var helper = _ref.helper, onHistoryChange = _ref.onHistoryChange, instantSearchInstance = _ref.instantSearchInstance;\n                this._cachedClear = this._cachedClear.bind(this);\n                this._clear = clear(helper);\n                this._refine = function () {\n                    var previousQuery = void 0;\n                    var setQueryAndSearch = function setQueryAndSearch(q) {\n                        var doSearch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                        if (q !== helper.state.query) {\n                            previousQuery = helper.state.query;\n                            helper.setQuery(q);\n                        }\n                        if (doSearch && previousQuery !== undefined && previousQuery !== q)\n                            helper.search();\n                    };\n                    return queryHook ? function (q) {\n                        return queryHook(q, setQueryAndSearch);\n                    } : setQueryAndSearch;\n                }();\n                this._onHistoryChange = onHistoryChange;\n                renderFn({\n                    query: helper.state.query,\n                    onHistoryChange: this._onHistoryChange,\n                    refine: this._refine,\n                    clear: this._cachedClear,\n                    widgetParams: widgetParams,\n                    instantSearchInstance: instantSearchInstance\n                }, true);\n            },\n            render: function render(_ref2) {\n                var helper = _ref2.helper, instantSearchInstance = _ref2.instantSearchInstance, searchMetadata = _ref2.searchMetadata;\n                this._clear = clear(helper);\n                renderFn({\n                    query: helper.state.query,\n                    onHistoryChange: this._onHistoryChange,\n                    refine: this._refine,\n                    clear: this._cachedClear,\n                    widgetParams: widgetParams,\n                    instantSearchInstance: instantSearchInstance,\n                    isSearchStalled: searchMetadata.isSearchStalled\n                }, false);\n            },\n            dispose: function dispose(_ref3) {\n                var state = _ref3.state;\n                unmountFn();\n                return state.setQuery('');\n            },\n            getWidgetState: function getWidgetState(uiState, _ref4) {\n                var searchParameters = _ref4.searchParameters;\n                var query = searchParameters.query;\n                if (query === '' || uiState && uiState.query === query) {\n                    return uiState;\n                }\n                return _extends({}, uiState, {\n                    query: query\n                });\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n                var uiState = _ref5.uiState;\n                return searchParameters.setQuery(uiState.query || '');\n            }\n        };\n    };\n}\n",null]}