{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js","mtime":1581861144627},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START lodash_noop,_.._lib_utils PURE_IMPORTS_END */\nimport noop from 'lodash/noop';\nimport { checkRendering, parseAroundLatLngFromString } from '../../lib/utils';\nvar usage = 'Usage:\\n\\nvar customGeoSearch = connectGeoSearch(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   position,\\n  //   refine,\\n  //   clearMapRefinement,\\n  //   isRefinedWithMap,\\n  //   toggleRefineOnMapMove,\\n  //   isRefineOnMapMove,\\n  //   setMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   widgetParams,\\n  //   instantSearchInstance,\\n  // }\\n});\\n\\nsearch.addWidget(\\n  customGeoSearch({\\n    [ enableRefineOnMapMove = true ],\\n    [ enableGeolocationWithIP = true ],\\n    [ position ],\\n    [ radius ],\\n    [ precision ],\\n    [ transformItems ],\\n  })\\n);\\n\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectGeoSearch.html\\n';\n/**\n * @typedef {Object} LatLng\n * @property {number} lat The latitude in degrees.\n * @property {number} lng The longitude in degrees.\n */\n/**\n * @typedef {Object} Bounds\n * @property {LatLng} northEast The top right corner of the map view.\n * @property {LatLng} southWest The bottom left corner of the map view.\n */\n/**\n * @typedef {Object} CustomGeoSearchWidgetOptions\n * @property {boolean} [enableRefineOnMapMove=true] If true, refine will be triggered as you move the map.\n * @property {boolean} [enableGeolocationWithIP=true] If true, the IP will be use for the geolocation. When the `position` option is provided this option will be ignored. See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLngViaIP) for more information.\n * @property {LatLng} [position] Position that will be use to search around. <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLng) for more information.\n * @property {number} [radius] Maximum radius to search around the position (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundRadius) for more information.\n * @property {number} [precision] Precision of geo search (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundPrecision) for more information.\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n/**\n * @typedef {Object} GeoSearchRenderingOptions\n * @property {Object[]} items The matched hits from Algolia API.\n * @property {function(Bounds)} refine Sets a bounding box to filter the results from the given map bounds.\n * @property {function()} clearMapRefinement Reset the current bounding box refinement.\n * @property {function(): boolean} isRefinedWithMap Return true if the current refinement is set with the map bounds.\n * @property {function()} toggleRefineOnMapMove Toggle the fact that the user is able to refine on map move.\n * @property {function(): boolean} isRefineOnMapMove Return true if the user is able to refine on map move.\n * @property {function()} setMapMoveSinceLastRefine Set the fact that the map has moved since the last refinement, should be call on each map move. The call to the function triggers a new rendering only when the value change.\n * @property {function(): boolean} hasMapMoveSinceLastRefine Return true if the map has move since the last refinement.\n * @property {Object} widgetParams All original `CustomGeoSearchWidgetOptions` forwarded to the `renderFn`.\n * @property {LatLng} [position] The current position of the search.\n */\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n *\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/geo-search/js/\n * @param {function(GeoSearchRenderingOptions, boolean)} renderFn Rendering function for the custom **GeoSearch** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomGeoSearchWidgetOptions)} Re-usable widget factory for a custom **GeoSearch** widget.\n * @staticExample\n * // This example use Leaflet for the rendering, be sure to have the library correctly setup\n * // before trying the demo. You can find more details in their documentation (link below).\n * // We choose Leaflet for the example but you can use any libraries that you want.\n * // See: http://leafletjs.com/examples/quick-start\n *\n * let map = null;\n * let markers = [];\n *\n * // custom `renderFn` to render the custom GeoSearch widget\n * function renderFn(GeoSearchRenderingOptions, isFirstRendering) {\n *   const { items, widgetParams } = GeoSearchRenderingOptions;\n *\n *   if (isFirstRendering) {\n *     map = L.map(widgetParams.container);\n *\n *     L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n *       attribution:\n *         '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n *     }).addTo(map);\n *   }\n *\n *   markers.forEach(marker => marker.remove());\n *\n *   markers = items.map(({ _geoloc }) =>\n *     L.marker([_geoloc.lat, _geoloc.lng]).addTo(map)\n *   );\n *\n *   if (markers.length) {\n *     map.fitBounds(L.featureGroup(markers).getBounds());\n *   }\n * }\n *\n * // connect `renderFn` to GeoSearch logic\n * const customGeoSearch = instantsearch.connectors.connectGeoSearch(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customGeoSearch({\n *     container: document.getElementById('custom-geo-search'),\n *   })\n * );\n */\nvar connectGeoSearch = function connectGeoSearch(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var _widgetParams$enableR = widgetParams.enableRefineOnMapMove, enableRefineOnMapMove = _widgetParams$enableR === undefined ? true : _widgetParams$enableR, _widgetParams$enableG = widgetParams.enableGeolocationWithIP, enableGeolocationWithIP = _widgetParams$enableG === undefined ? true : _widgetParams$enableG, position = widgetParams.position, radius = widgetParams.radius, precision = widgetParams.precision, _widgetParams$transfo = widgetParams.transformItems, transformItems = _widgetParams$transfo === undefined ? function (items) {\n            return items;\n        } : _widgetParams$transfo;\n        var widgetState = {\n            isRefineOnMapMove: enableRefineOnMapMove,\n            hasMapMoveSinceLastRefine: false,\n            lastRefinePosition: '',\n            lastRefineBoundingBox: '',\n            internalToggleRefineOnMapMove: noop,\n            internalSetMapMoveSinceLastRefine: noop\n        };\n        var getPositionFromState = function getPositionFromState(state) {\n            return state.aroundLatLng && parseAroundLatLngFromString(state.aroundLatLng);\n        };\n        var refine = function refine(helper) {\n            return function (_ref) {\n                var ne = _ref.northEast, sw = _ref.southWest;\n                var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n                helper.setQueryParameter('insideBoundingBox', boundingBox).search();\n                widgetState.hasMapMoveSinceLastRefine = false;\n                widgetState.lastRefineBoundingBox = boundingBox;\n            };\n        };\n        var clearMapRefinement = function clearMapRefinement(helper) {\n            return function () {\n                helper.setQueryParameter('insideBoundingBox').search();\n            };\n        };\n        var isRefinedWithMap = function isRefinedWithMap(state) {\n            return function () {\n                return Boolean(state.insideBoundingBox);\n            };\n        };\n        var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n            return widgetState.internalToggleRefineOnMapMove();\n        };\n        var createInternalToggleRefinementonMapMove = function createInternalToggleRefinementonMapMove(render, args) {\n            return function () {\n                widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n                render(args);\n            };\n        };\n        var isRefineOnMapMove = function isRefineOnMapMove() {\n            return widgetState.isRefineOnMapMove;\n        };\n        var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n            return widgetState.internalSetMapMoveSinceLastRefine();\n        };\n        var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(render, args) {\n            return function () {\n                var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n                widgetState.hasMapMoveSinceLastRefine = true;\n                if (shouldTriggerRender) {\n                    render(args);\n                }\n            };\n        };\n        var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n            return widgetState.hasMapMoveSinceLastRefine;\n        };\n        var init = function init(initArgs) {\n            var state = initArgs.state, helper = initArgs.helper, instantSearchInstance = initArgs.instantSearchInstance;\n            var isFirstRendering = true;\n            widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(noop, initArgs);\n            widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(noop, initArgs);\n            renderFn({\n                items: [],\n                position: getPositionFromState(state),\n                refine: refine(helper),\n                clearMapRefinement: clearMapRefinement(helper),\n                isRefinedWithMap: isRefinedWithMap(state),\n                toggleRefineOnMapMove: toggleRefineOnMapMove,\n                isRefineOnMapMove: isRefineOnMapMove,\n                setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n                hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n                widgetParams: widgetParams,\n                instantSearchInstance: instantSearchInstance\n            }, isFirstRendering);\n        };\n        var render = function render(renderArgs) {\n            var results = renderArgs.results, helper = renderArgs.helper, instantSearchInstance = renderArgs.instantSearchInstance;\n            var isFirstRendering = false;\n            // We don't use the state provided by the render function because we need\n            // to be sure that the state is the latest one for the following condition\n            var state = helper.getState();\n            var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n            var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n            if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n                widgetState.hasMapMoveSinceLastRefine = false;\n            }\n            widgetState.lastRefinePosition = state.aroundLatLng || '';\n            widgetState.lastRefineBoundingBox = state.insideBoundingBox || '';\n            widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(render, renderArgs);\n            widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(render, renderArgs);\n            var items = transformItems(results.hits.filter(function (hit) {\n                return hit._geoloc;\n            }));\n            renderFn({\n                items: items,\n                position: getPositionFromState(state),\n                refine: refine(helper),\n                clearMapRefinement: clearMapRefinement(helper),\n                isRefinedWithMap: isRefinedWithMap(state),\n                toggleRefineOnMapMove: toggleRefineOnMapMove,\n                isRefineOnMapMove: isRefineOnMapMove,\n                setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n                hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n                widgetParams: widgetParams,\n                instantSearchInstance: instantSearchInstance\n            }, isFirstRendering);\n        };\n        return {\n            init: init,\n            render: render,\n            getConfiguration: function getConfiguration(previous) {\n                var configuration = {};\n                if (enableGeolocationWithIP && !position && !previous.aroundLatLng && previous.aroundLatLngViaIP === undefined) {\n                    configuration.aroundLatLngViaIP = true;\n                }\n                if (position && !previous.aroundLatLng && !previous.aroundLatLngViaIP) {\n                    configuration.aroundLatLng = position.lat + ', ' + position.lng;\n                }\n                if (radius && !previous.aroundRadius) {\n                    configuration.aroundRadius = radius;\n                }\n                if (precision && !previous.aroundPrecision) {\n                    configuration.aroundPrecision = precision;\n                }\n                return configuration;\n            },\n            dispose: function dispose(_ref2) {\n                var state = _ref2.state;\n                unmountFn();\n                var nextState = state;\n                if (enableGeolocationWithIP && !position) {\n                    nextState = nextState.setQueryParameter('aroundLatLngViaIP');\n                }\n                if (position) {\n                    nextState = nextState.setQueryParameter('aroundLatLng');\n                }\n                if (radius) {\n                    nextState = nextState.setQueryParameter('aroundRadius');\n                }\n                if (precision) {\n                    nextState = nextState.setQueryParameter('aroundPrecision');\n                }\n                nextState = nextState.setQueryParameter('insideBoundingBox');\n                return nextState;\n            }\n        };\n    };\n};\nexport default connectGeoSearch;\n",null]}