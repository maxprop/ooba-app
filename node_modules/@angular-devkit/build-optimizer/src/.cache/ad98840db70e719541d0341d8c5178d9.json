{"remainingRequest":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/menu/connectMenu.js","dependencies":[{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/instantsearch.js/es/connectors/menu/connectMenu.js","mtime":1581861144633},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/cache-loader/dist/cjs.js","mtime":1571276078087},{"path":"/Users/scottjoscelyne/Desktop/oasis/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1571276072802}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _.._lib_utils.js PURE_IMPORTS_END */\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n} return target; };\nvar _slicedToArray = /*@__PURE__*/ function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n            break;\n    }\n}\ncatch (err) {\n    _d = true;\n    _e = err;\n}\nfinally {\n    try {\n        if (!_n && _i[\"return\"])\n            _i[\"return\"]();\n    }\n    finally {\n        if (_d)\n            throw _e;\n    }\n} return _arr; } return function (arr, i) { if (Array.isArray(arr)) {\n    return arr;\n}\nelse if (Symbol.iterator in Object(arr)) {\n    return sliceIterator(arr, i);\n}\nelse {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} }; }();\nfunction _defineProperty(obj, key, value) { if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n}\nelse {\n    obj[key] = value;\n} return obj; }\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) {\n    if (keys.indexOf(i) >= 0)\n        continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i))\n        continue;\n    target[i] = obj[i];\n} return target; }\nimport { checkRendering } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customMenu = connectMenu(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   createURL,\\n  //   refine,\\n  //   instantSearchInstance,\\n  //   canRefine,\\n  //   widgetParams,\\n  //   isShowingMore,\\n  //   toggleShowMore\\n  // }\\n});\\nsearch.addWidget(\\n  customMenu({\\n    attributeName,\\n    [ limit ],\\n    [ showMoreLimit ]\\n    [ sortBy = [\\'name:asc\\'] ]\\n    [ transformItems ]\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectMenu.html\\n';\n/**\n * @typedef {Object} MenuItem\n * @property {string} value The value of the menu item.\n * @property {string} label Human-readable value of the menu item.\n * @property {number} count Number of results matched after refinement is applied.\n * @property {isRefined} boolean Indicates if the refinement is applied.\n */\n/**\n * @typedef {Object} CustomMenuWidgetOptions\n * @property {string} attributeName Name of the attribute for faceting (eg. \"free_shipping\").\n * @property {number} [limit = 10] How many facets values to retrieve.\n * @property {number} [showMoreLimit = undefined] How many facets values to retrieve when `toggleShowMore` is called, this value is meant to be greater than `limit` option.\n * @property {string[]|function} [sortBy = ['name:asc']] How to sort refinements. Possible values: `count|isRefined|name:asc|name:desc`.\n *\n * You can also use a sort function that behaves like the standard Javascript [compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Syntax).\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n/**\n * @typedef {Object} MenuRenderingOptions\n * @property {MenuItem[]} items The elements that can be refined for the current search results.\n * @property {function(item.value): string} createURL Creates the URL for a single item name in the list.\n * @property {function(item.value)} refine Filter the search to item value.\n * @property {boolean} canRefine True if refinement can be applied.\n * @property {Object} widgetParams All original `CustomMenuWidgetOptions` forwarded to the `renderFn`.\n * @property {boolean} isShowingMore True if the menu is displaying all the menu items.\n * @property {function} toggleShowMore Toggles the number of values displayed between `limit` and `showMore.limit`.\n * @property {boolean} canToggleShowMore `true` if the toggleShowMore button can be activated (enough items to display more or\n * already displaying more than `limit` items)\n */\n/**\n * **Menu** connector provides the logic to build a widget that will give the user the ability to choose a single value for a specific facet. The typical usage of menu is for navigation in categories.\n *\n * This connector provides a `toggleShowMore()` function to display more or less items and a `refine()`\n * function to select an item. While selecting a new element, the `refine` will also unselect the\n * one that is currently selected.\n *\n * **Requirement:** the attribute passed as `attributeName` must be present in \"attributes for faceting\" on the Algolia dashboard or configured as attributesForFaceting via a set settings call to the Algolia API.\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/menu/js/\n * @param {function(MenuRenderingOptions, boolean)} renderFn Rendering function for the custom **Menu** widget. widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomMenuWidgetOptions)} Re-usable widget factory for a custom **Menu** widget.\n * @example\n * // custom `renderFn` to render the custom Menu widget\n * function renderFn(MenuRenderingOptions, isFirstRendering) {\n *   if (isFirstRendering) {\n *     MenuRenderingOptions.widgetParams.containerNode\n *       .html('<select></select');\n *\n *     MenuRenderingOptions.widgetParams.containerNode\n *       .find('select')\n *       .on('change', function(event) {\n *         MenuRenderingOptions.refine(event.target.value);\n *       });\n *   }\n *\n *   var options = MenuRenderingOptions.items.map(function(item) {\n *     return item.isRefined\n *       ? '<option value=\"' + item.value + '\" selected>' + item.label + '</option>'\n *       : '<option value=\"' + item.value + '\">' + item.label + '</option>';\n *   });\n *\n *   MenuRenderingOptions.widgetParams.containerNode\n *     .find('select')\n *     .html(options);\n * }\n *\n * // connect `renderFn` to Menu logic\n * var customMenu = instantsearch.connectors.connectMenu(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customMenu({\n *     containerNode: $('#custom-menu-container'),\n *     attributeName: 'categories',\n *     limit: 10,\n *   })\n * );\n */\nexport default function connectMenu(renderFn, unmountFn) {\n    checkRendering(renderFn, usage);\n    return function () {\n        var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attributeName = widgetParams.attributeName, _widgetParams$limit = widgetParams.limit, limit = _widgetParams$limit === undefined ? 10 : _widgetParams$limit, _widgetParams$sortBy = widgetParams.sortBy, sortBy = _widgetParams$sortBy === undefined ? ['name:asc'] : _widgetParams$sortBy, showMoreLimit = widgetParams.showMoreLimit, _widgetParams$transfo = widgetParams.transformItems, transformItems = _widgetParams$transfo === undefined ? function (items) {\n            return items;\n        } : _widgetParams$transfo;\n        if (!attributeName || !isNaN(showMoreLimit) && showMoreLimit < limit) {\n            throw new Error(usage);\n        }\n        return {\n            isShowingMore: false,\n            // Provide the same function to the `renderFn` so that way the user\n            // has to only bind it once when `isFirstRendering` for instance\n            toggleShowMore: function toggleShowMore() { },\n            cachedToggleShowMore: function cachedToggleShowMore() {\n                this.toggleShowMore();\n            },\n            createToggleShowMore: function createToggleShowMore(_ref) {\n                var _this = this;\n                var results = _ref.results, instantSearchInstance = _ref.instantSearchInstance;\n                return function () {\n                    _this.isShowingMore = !_this.isShowingMore;\n                    _this.render({ results: results, instantSearchInstance: instantSearchInstance });\n                };\n            },\n            getLimit: function getLimit() {\n                return this.isShowingMore ? showMoreLimit : limit;\n            },\n            refine: function refine(helper) {\n                return function (facetValue) {\n                    var _helper$getHierarchic = helper.getHierarchicalFacetBreadcrumb(attributeName), _helper$getHierarchic2 = _slicedToArray(_helper$getHierarchic, 1), refinedItem = _helper$getHierarchic2[0];\n                    helper.toggleRefinement(attributeName, facetValue ? facetValue : refinedItem).search();\n                };\n            },\n            getConfiguration: function getConfiguration(configuration) {\n                var widgetConfiguration = {\n                    hierarchicalFacets: [{\n                            name: attributeName,\n                            attributes: [attributeName]\n                        }]\n                };\n                var currentMaxValuesPerFacet = configuration.maxValuesPerFacet || 0;\n                widgetConfiguration.maxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMoreLimit || limit);\n                return widgetConfiguration;\n            },\n            init: function init(_ref2) {\n                var helper = _ref2.helper, createURL = _ref2.createURL, instantSearchInstance = _ref2.instantSearchInstance;\n                this.cachedToggleShowMore = this.cachedToggleShowMore.bind(this);\n                this._createURL = function (facetValue) {\n                    return createURL(helper.state.toggleRefinement(attributeName, facetValue));\n                };\n                this._refine = this.refine(helper);\n                renderFn({\n                    items: [],\n                    createURL: this._createURL,\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    canRefine: false,\n                    widgetParams: widgetParams,\n                    isShowingMore: this.isShowingMore,\n                    toggleShowMore: this.cachedToggleShowMore,\n                    canToggleShowMore: false\n                }, true);\n            },\n            render: function render(_ref3) {\n                var results = _ref3.results, instantSearchInstance = _ref3.instantSearchInstance;\n                var facetItems = results.getFacetValues(attributeName, { sortBy: sortBy }).data || [];\n                var items = transformItems(facetItems.slice(0, this.getLimit()).map(function (_ref4) {\n                    var label = _ref4.name, value = _ref4.path, item = _objectWithoutProperties(_ref4, ['name', 'path']);\n                    return _extends({}, item, {\n                        label: label,\n                        value: value\n                    });\n                }));\n                this.toggleShowMore = this.createToggleShowMore({\n                    results: results,\n                    instantSearchInstance: instantSearchInstance\n                });\n                renderFn({\n                    items: items,\n                    createURL: this._createURL,\n                    refine: this._refine,\n                    instantSearchInstance: instantSearchInstance,\n                    canRefine: items.length > 0,\n                    widgetParams: widgetParams,\n                    isShowingMore: this.isShowingMore,\n                    toggleShowMore: this.cachedToggleShowMore,\n                    canToggleShowMore: this.isShowingMore || facetItems.length > this.getLimit()\n                }, false);\n            },\n            dispose: function dispose(_ref5) {\n                var state = _ref5.state;\n                unmountFn();\n                var nextState = state;\n                if (state.isHierarchicalFacetRefined(attributeName)) {\n                    nextState = state.removeHierarchicalFacetRefinement(attributeName);\n                }\n                nextState = nextState.removeHierarchicalFacet(attributeName);\n                if (nextState.maxValuesPerFacet === limit || showMoreLimit && nextState.maxValuesPerFacet === showMoreLimit) {\n                    nextState.setQueryParameters('maxValuesPerFacet', undefined);\n                }\n                return nextState;\n            },\n            getWidgetState: function getWidgetState(uiState, _ref6) {\n                var searchParameters = _ref6.searchParameters;\n                var _searchParameters$get = searchParameters.getHierarchicalFacetBreadcrumb(attributeName), _searchParameters$get2 = _slicedToArray(_searchParameters$get, 1), refinedItem = _searchParameters$get2[0];\n                if (!refinedItem || uiState.menu && uiState.menu[attributeName] === refinedItem) {\n                    return uiState;\n                }\n                return _extends({}, uiState, {\n                    menu: _extends({}, uiState.menu, _defineProperty({}, attributeName, refinedItem))\n                });\n            },\n            getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref7) {\n                var uiState = _ref7.uiState;\n                if (uiState.menu && uiState.menu[attributeName]) {\n                    var uiStateRefinedItem = uiState.menu[attributeName];\n                    var isAlreadyRefined = searchParameters.isHierarchicalFacetRefined(attributeName, uiStateRefinedItem);\n                    if (isAlreadyRefined)\n                        return searchParameters;\n                    return searchParameters.toggleRefinement(attributeName, uiStateRefinedItem);\n                }\n                if (searchParameters.isHierarchicalFacetRefined(attributeName)) {\n                    var _searchParameters$get3 = searchParameters.getHierarchicalFacetBreadcrumb(attributeName), _searchParameters$get4 = _slicedToArray(_searchParameters$get3, 1), refinedItem = _searchParameters$get4[0];\n                    return searchParameters.toggleRefinement(attributeName, refinedItem);\n                }\n                return searchParameters;\n            }\n        };\n    };\n}\n",null]}